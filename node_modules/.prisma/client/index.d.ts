
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model MemberAccess
 * 
 */
export type MemberAccess = $Result.DefaultSelection<Prisma.$MemberAccessPayload>
/**
 * Model HeroBanner
 * 
 */
export type HeroBanner = $Result.DefaultSelection<Prisma.$HeroBannerPayload>
/**
 * Model FeatureToggle
 * 
 */
export type FeatureToggle = $Result.DefaultSelection<Prisma.$FeatureTogglePayload>
/**
 * Model MemberAccessOverride
 * 
 */
export type MemberAccessOverride = $Result.DefaultSelection<Prisma.$MemberAccessOverridePayload>
/**
 * Model InvitationTemplate
 * 
 */
export type InvitationTemplate = $Result.DefaultSelection<Prisma.$InvitationTemplatePayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseModule
 * 
 */
export type CourseModule = $Result.DefaultSelection<Prisma.$CourseModulePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model CourseProgress
 * 
 */
export type CourseProgress = $Result.DefaultSelection<Prisma.$CourseProgressPayload>
/**
 * Model LessonComment
 * 
 */
export type LessonComment = $Result.DefaultSelection<Prisma.$LessonCommentPayload>
/**
 * Model LessonCommentReply
 * 
 */
export type LessonCommentReply = $Result.DefaultSelection<Prisma.$LessonCommentReplyPayload>
/**
 * Model CourseRecommendation
 * 
 */
export type CourseRecommendation = $Result.DefaultSelection<Prisma.$CourseRecommendationPayload>
/**
 * Model LessonRating
 * 
 */
export type LessonRating = $Result.DefaultSelection<Prisma.$LessonRatingPayload>
/**
 * Model LessonProgressEvent
 * 
 */
export type LessonProgressEvent = $Result.DefaultSelection<Prisma.$LessonProgressEventPayload>
/**
 * Model LessonProgressAggregate
 * 
 */
export type LessonProgressAggregate = $Result.DefaultSelection<Prisma.$LessonProgressAggregatePayload>
/**
 * Model EvolutionApiConfig
 * 
 */
export type EvolutionApiConfig = $Result.DefaultSelection<Prisma.$EvolutionApiConfigPayload>
/**
 * Model ContactSegment
 * 
 */
export type ContactSegment = $Result.DefaultSelection<Prisma.$ContactSegmentPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignRun
 * 
 */
export type CampaignRun = $Result.DefaultSelection<Prisma.$CampaignRunPayload>
/**
 * Model CampaignMetrics
 * 
 */
export type CampaignMetrics = $Result.DefaultSelection<Prisma.$CampaignMetricsPayload>
/**
 * Model CampaignTimelinePoint
 * 
 */
export type CampaignTimelinePoint = $Result.DefaultSelection<Prisma.$CampaignTimelinePointPayload>
/**
 * Model ResourceCategory
 * 
 */
export type ResourceCategory = $Result.DefaultSelection<Prisma.$ResourceCategoryPayload>
/**
 * Model ResourceTag
 * 
 */
export type ResourceTag = $Result.DefaultSelection<Prisma.$ResourceTagPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model ResourceTagAssignment
 * 
 */
export type ResourceTagAssignment = $Result.DefaultSelection<Prisma.$ResourceTagAssignmentPayload>
/**
 * Model ResourceAsset
 * 
 */
export type ResourceAsset = $Result.DefaultSelection<Prisma.$ResourceAssetPayload>
/**
 * Model ResourceDownloadLog
 * 
 */
export type ResourceDownloadLog = $Result.DefaultSelection<Prisma.$ResourceDownloadLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  member: 'member',
  mentor: 'mentor',
  admin: 'admin',
  super_admin: 'super_admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const FeatureAccessKey: {
  hidra: 'hidra',
  cybervault: 'cybervault',
  academy: 'academy',
  admin_console: 'admin_console',
  community: 'community'
};

export type FeatureAccessKey = (typeof FeatureAccessKey)[keyof typeof FeatureAccessKey]


export const CourseStatus: {
  draft: 'draft',
  scheduled: 'scheduled',
  published: 'published',
  archived: 'archived'
};

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]


export const CourseLevel: {
  beginner: 'beginner',
  intermediate: 'intermediate',
  advanced: 'advanced'
};

export type CourseLevel = (typeof CourseLevel)[keyof typeof CourseLevel]


export const Visibility: {
  private: 'private',
  members: 'members',
  mentors: 'mentors',
  public: 'public'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const LessonType: {
  video: 'video',
  article: 'article',
  live: 'live',
  downloadable: 'downloadable',
  quiz: 'quiz'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]


export const RecommendationBadge: {
  new: 'new',
  popular: 'popular',
  mentor_pick: 'mentor_pick'
};

export type RecommendationBadge = (typeof RecommendationBadge)[keyof typeof RecommendationBadge]


export const CampaignStatus: {
  draft: 'draft',
  scheduled: 'scheduled',
  running: 'running',
  paused: 'paused',
  completed: 'completed',
  failed: 'failed'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const CampaignChannel: {
  whatsapp: 'whatsapp'
};

export type CampaignChannel = (typeof CampaignChannel)[keyof typeof CampaignChannel]


export const BannerStatus: {
  active: 'active',
  inactive: 'inactive',
  scheduled: 'scheduled'
};

export type BannerStatus = (typeof BannerStatus)[keyof typeof BannerStatus]


export const FeatureToggleStatus: {
  enabled: 'enabled',
  disabled: 'disabled',
  gradual: 'gradual'
};

export type FeatureToggleStatus = (typeof FeatureToggleStatus)[keyof typeof FeatureToggleStatus]


export const InvitationStatus: {
  pending: 'pending',
  accepted: 'accepted',
  expired: 'expired'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const LessonCommentModerationStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type LessonCommentModerationStatus = (typeof LessonCommentModerationStatus)[keyof typeof LessonCommentModerationStatus]


export const EvolutionConnectionStatus: {
  connected: 'connected',
  disconnected: 'disconnected',
  error: 'error'
};

export type EvolutionConnectionStatus = (typeof EvolutionConnectionStatus)[keyof typeof EvolutionConnectionStatus]


export const ContactImportSource: {
  csv_upload: 'csv_upload',
  manual: 'manual',
  api: 'api'
};

export type ContactImportSource = (typeof ContactImportSource)[keyof typeof ContactImportSource]


export const ResourceType: {
  template: 'template',
  playbook: 'playbook',
  script: 'script',
  asset: 'asset',
  spreadsheet: 'spreadsheet',
  presentation: 'presentation',
  other: 'other'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type FeatureAccessKey = $Enums.FeatureAccessKey

export const FeatureAccessKey: typeof $Enums.FeatureAccessKey

export type CourseStatus = $Enums.CourseStatus

export const CourseStatus: typeof $Enums.CourseStatus

export type CourseLevel = $Enums.CourseLevel

export const CourseLevel: typeof $Enums.CourseLevel

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

export type RecommendationBadge = $Enums.RecommendationBadge

export const RecommendationBadge: typeof $Enums.RecommendationBadge

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type CampaignChannel = $Enums.CampaignChannel

export const CampaignChannel: typeof $Enums.CampaignChannel

export type BannerStatus = $Enums.BannerStatus

export const BannerStatus: typeof $Enums.BannerStatus

export type FeatureToggleStatus = $Enums.FeatureToggleStatus

export const FeatureToggleStatus: typeof $Enums.FeatureToggleStatus

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type LessonCommentModerationStatus = $Enums.LessonCommentModerationStatus

export const LessonCommentModerationStatus: typeof $Enums.LessonCommentModerationStatus

export type EvolutionConnectionStatus = $Enums.EvolutionConnectionStatus

export const EvolutionConnectionStatus: typeof $Enums.EvolutionConnectionStatus

export type ContactImportSource = $Enums.ContactImportSource

export const ContactImportSource: typeof $Enums.ContactImportSource

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberAccess`: Exposes CRUD operations for the **MemberAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberAccesses
    * const memberAccesses = await prisma.memberAccess.findMany()
    * ```
    */
  get memberAccess(): Prisma.MemberAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroBanner`: Exposes CRUD operations for the **HeroBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroBanners
    * const heroBanners = await prisma.heroBanner.findMany()
    * ```
    */
  get heroBanner(): Prisma.HeroBannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureToggle`: Exposes CRUD operations for the **FeatureToggle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureToggles
    * const featureToggles = await prisma.featureToggle.findMany()
    * ```
    */
  get featureToggle(): Prisma.FeatureToggleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberAccessOverride`: Exposes CRUD operations for the **MemberAccessOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberAccessOverrides
    * const memberAccessOverrides = await prisma.memberAccessOverride.findMany()
    * ```
    */
  get memberAccessOverride(): Prisma.MemberAccessOverrideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitationTemplate`: Exposes CRUD operations for the **InvitationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationTemplates
    * const invitationTemplates = await prisma.invitationTemplate.findMany()
    * ```
    */
  get invitationTemplate(): Prisma.InvitationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseModule`: Exposes CRUD operations for the **CourseModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseModules
    * const courseModules = await prisma.courseModule.findMany()
    * ```
    */
  get courseModule(): Prisma.CourseModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseProgress`: Exposes CRUD operations for the **CourseProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseProgresses
    * const courseProgresses = await prisma.courseProgress.findMany()
    * ```
    */
  get courseProgress(): Prisma.CourseProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonComment`: Exposes CRUD operations for the **LessonComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonComments
    * const lessonComments = await prisma.lessonComment.findMany()
    * ```
    */
  get lessonComment(): Prisma.LessonCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonCommentReply`: Exposes CRUD operations for the **LessonCommentReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonCommentReplies
    * const lessonCommentReplies = await prisma.lessonCommentReply.findMany()
    * ```
    */
  get lessonCommentReply(): Prisma.LessonCommentReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseRecommendation`: Exposes CRUD operations for the **CourseRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseRecommendations
    * const courseRecommendations = await prisma.courseRecommendation.findMany()
    * ```
    */
  get courseRecommendation(): Prisma.CourseRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonRating`: Exposes CRUD operations for the **LessonRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonRatings
    * const lessonRatings = await prisma.lessonRating.findMany()
    * ```
    */
  get lessonRating(): Prisma.LessonRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonProgressEvent`: Exposes CRUD operations for the **LessonProgressEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgressEvents
    * const lessonProgressEvents = await prisma.lessonProgressEvent.findMany()
    * ```
    */
  get lessonProgressEvent(): Prisma.LessonProgressEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonProgressAggregate`: Exposes CRUD operations for the **LessonProgressAggregate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgressAggregates
    * const lessonProgressAggregates = await prisma.lessonProgressAggregate.findMany()
    * ```
    */
  get lessonProgressAggregate(): Prisma.LessonProgressAggregateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolutionApiConfig`: Exposes CRUD operations for the **EvolutionApiConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvolutionApiConfigs
    * const evolutionApiConfigs = await prisma.evolutionApiConfig.findMany()
    * ```
    */
  get evolutionApiConfig(): Prisma.EvolutionApiConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSegment`: Exposes CRUD operations for the **ContactSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSegments
    * const contactSegments = await prisma.contactSegment.findMany()
    * ```
    */
  get contactSegment(): Prisma.ContactSegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignRun`: Exposes CRUD operations for the **CampaignRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignRuns
    * const campaignRuns = await prisma.campaignRun.findMany()
    * ```
    */
  get campaignRun(): Prisma.CampaignRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignMetrics`: Exposes CRUD operations for the **CampaignMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMetrics
    * const campaignMetrics = await prisma.campaignMetrics.findMany()
    * ```
    */
  get campaignMetrics(): Prisma.CampaignMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignTimelinePoint`: Exposes CRUD operations for the **CampaignTimelinePoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTimelinePoints
    * const campaignTimelinePoints = await prisma.campaignTimelinePoint.findMany()
    * ```
    */
  get campaignTimelinePoint(): Prisma.CampaignTimelinePointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceCategory`: Exposes CRUD operations for the **ResourceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceCategories
    * const resourceCategories = await prisma.resourceCategory.findMany()
    * ```
    */
  get resourceCategory(): Prisma.ResourceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceTag`: Exposes CRUD operations for the **ResourceTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceTags
    * const resourceTags = await prisma.resourceTag.findMany()
    * ```
    */
  get resourceTag(): Prisma.ResourceTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceTagAssignment`: Exposes CRUD operations for the **ResourceTagAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceTagAssignments
    * const resourceTagAssignments = await prisma.resourceTagAssignment.findMany()
    * ```
    */
  get resourceTagAssignment(): Prisma.ResourceTagAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceAsset`: Exposes CRUD operations for the **ResourceAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceAssets
    * const resourceAssets = await prisma.resourceAsset.findMany()
    * ```
    */
  get resourceAsset(): Prisma.ResourceAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceDownloadLog`: Exposes CRUD operations for the **ResourceDownloadLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceDownloadLogs
    * const resourceDownloadLogs = await prisma.resourceDownloadLog.findMany()
    * ```
    */
  get resourceDownloadLog(): Prisma.ResourceDownloadLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    MemberAccess: 'MemberAccess',
    HeroBanner: 'HeroBanner',
    FeatureToggle: 'FeatureToggle',
    MemberAccessOverride: 'MemberAccessOverride',
    InvitationTemplate: 'InvitationTemplate',
    Invitation: 'Invitation',
    Course: 'Course',
    CourseModule: 'CourseModule',
    Lesson: 'Lesson',
    CourseProgress: 'CourseProgress',
    LessonComment: 'LessonComment',
    LessonCommentReply: 'LessonCommentReply',
    CourseRecommendation: 'CourseRecommendation',
    LessonRating: 'LessonRating',
    LessonProgressEvent: 'LessonProgressEvent',
    LessonProgressAggregate: 'LessonProgressAggregate',
    EvolutionApiConfig: 'EvolutionApiConfig',
    ContactSegment: 'ContactSegment',
    MessageTemplate: 'MessageTemplate',
    Campaign: 'Campaign',
    CampaignRun: 'CampaignRun',
    CampaignMetrics: 'CampaignMetrics',
    CampaignTimelinePoint: 'CampaignTimelinePoint',
    ResourceCategory: 'ResourceCategory',
    ResourceTag: 'ResourceTag',
    Resource: 'Resource',
    ResourceTagAssignment: 'ResourceTagAssignment',
    ResourceAsset: 'ResourceAsset',
    ResourceDownloadLog: 'ResourceDownloadLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "memberAccess" | "heroBanner" | "featureToggle" | "memberAccessOverride" | "invitationTemplate" | "invitation" | "course" | "courseModule" | "lesson" | "courseProgress" | "lessonComment" | "lessonCommentReply" | "courseRecommendation" | "lessonRating" | "lessonProgressEvent" | "lessonProgressAggregate" | "evolutionApiConfig" | "contactSegment" | "messageTemplate" | "campaign" | "campaignRun" | "campaignMetrics" | "campaignTimelinePoint" | "resourceCategory" | "resourceTag" | "resource" | "resourceTagAssignment" | "resourceAsset" | "resourceDownloadLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      MemberAccess: {
        payload: Prisma.$MemberAccessPayload<ExtArgs>
        fields: Prisma.MemberAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          findFirst: {
            args: Prisma.MemberAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          findMany: {
            args: Prisma.MemberAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>[]
          }
          create: {
            args: Prisma.MemberAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          createMany: {
            args: Prisma.MemberAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>[]
          }
          delete: {
            args: Prisma.MemberAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          update: {
            args: Prisma.MemberAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          deleteMany: {
            args: Prisma.MemberAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>[]
          }
          upsert: {
            args: Prisma.MemberAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessPayload>
          }
          aggregate: {
            args: Prisma.MemberAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberAccess>
          }
          groupBy: {
            args: Prisma.MemberAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberAccessCountArgs<ExtArgs>
            result: $Utils.Optional<MemberAccessCountAggregateOutputType> | number
          }
        }
      }
      HeroBanner: {
        payload: Prisma.$HeroBannerPayload<ExtArgs>
        fields: Prisma.HeroBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          findFirst: {
            args: Prisma.HeroBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          findMany: {
            args: Prisma.HeroBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>[]
          }
          create: {
            args: Prisma.HeroBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          createMany: {
            args: Prisma.HeroBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroBannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>[]
          }
          delete: {
            args: Prisma.HeroBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          update: {
            args: Prisma.HeroBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          deleteMany: {
            args: Prisma.HeroBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HeroBannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>[]
          }
          upsert: {
            args: Prisma.HeroBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          aggregate: {
            args: Prisma.HeroBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroBanner>
          }
          groupBy: {
            args: Prisma.HeroBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroBannerCountArgs<ExtArgs>
            result: $Utils.Optional<HeroBannerCountAggregateOutputType> | number
          }
        }
      }
      FeatureToggle: {
        payload: Prisma.$FeatureTogglePayload<ExtArgs>
        fields: Prisma.FeatureToggleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureToggleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureToggleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          findFirst: {
            args: Prisma.FeatureToggleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureToggleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          findMany: {
            args: Prisma.FeatureToggleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>[]
          }
          create: {
            args: Prisma.FeatureToggleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          createMany: {
            args: Prisma.FeatureToggleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureToggleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>[]
          }
          delete: {
            args: Prisma.FeatureToggleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          update: {
            args: Prisma.FeatureToggleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          deleteMany: {
            args: Prisma.FeatureToggleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureToggleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureToggleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>[]
          }
          upsert: {
            args: Prisma.FeatureToggleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTogglePayload>
          }
          aggregate: {
            args: Prisma.FeatureToggleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureToggle>
          }
          groupBy: {
            args: Prisma.FeatureToggleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureToggleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureToggleCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureToggleCountAggregateOutputType> | number
          }
        }
      }
      MemberAccessOverride: {
        payload: Prisma.$MemberAccessOverridePayload<ExtArgs>
        fields: Prisma.MemberAccessOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberAccessOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberAccessOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          findFirst: {
            args: Prisma.MemberAccessOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberAccessOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          findMany: {
            args: Prisma.MemberAccessOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>[]
          }
          create: {
            args: Prisma.MemberAccessOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          createMany: {
            args: Prisma.MemberAccessOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberAccessOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>[]
          }
          delete: {
            args: Prisma.MemberAccessOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          update: {
            args: Prisma.MemberAccessOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          deleteMany: {
            args: Prisma.MemberAccessOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberAccessOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberAccessOverrideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>[]
          }
          upsert: {
            args: Prisma.MemberAccessOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAccessOverridePayload>
          }
          aggregate: {
            args: Prisma.MemberAccessOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberAccessOverride>
          }
          groupBy: {
            args: Prisma.MemberAccessOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberAccessOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberAccessOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<MemberAccessOverrideCountAggregateOutputType> | number
          }
        }
      }
      InvitationTemplate: {
        payload: Prisma.$InvitationTemplatePayload<ExtArgs>
        fields: Prisma.InvitationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findFirst: {
            args: Prisma.InvitationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findMany: {
            args: Prisma.InvitationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          create: {
            args: Prisma.InvitationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          createMany: {
            args: Prisma.InvitationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          delete: {
            args: Prisma.InvitationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          update: {
            args: Prisma.InvitationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.InvitationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.InvitationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          aggregate: {
            args: Prisma.InvitationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationTemplate>
          }
          groupBy: {
            args: Prisma.InvitationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseModule: {
        payload: Prisma.$CourseModulePayload<ExtArgs>
        fields: Prisma.CourseModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findFirst: {
            args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findMany: {
            args: Prisma.CourseModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          create: {
            args: Prisma.CourseModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          createMany: {
            args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          delete: {
            args: Prisma.CourseModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          update: {
            args: Prisma.CourseModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          deleteMany: {
            args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          upsert: {
            args: Prisma.CourseModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          aggregate: {
            args: Prisma.CourseModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseModule>
          }
          groupBy: {
            args: Prisma.CourseModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseModuleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      CourseProgress: {
        payload: Prisma.$CourseProgressPayload<ExtArgs>
        fields: Prisma.CourseProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          findFirst: {
            args: Prisma.CourseProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          findMany: {
            args: Prisma.CourseProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>[]
          }
          create: {
            args: Prisma.CourseProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          createMany: {
            args: Prisma.CourseProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>[]
          }
          delete: {
            args: Prisma.CourseProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          update: {
            args: Prisma.CourseProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          deleteMany: {
            args: Prisma.CourseProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>[]
          }
          upsert: {
            args: Prisma.CourseProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          aggregate: {
            args: Prisma.CourseProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseProgress>
          }
          groupBy: {
            args: Prisma.CourseProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseProgressCountArgs<ExtArgs>
            result: $Utils.Optional<CourseProgressCountAggregateOutputType> | number
          }
        }
      }
      LessonComment: {
        payload: Prisma.$LessonCommentPayload<ExtArgs>
        fields: Prisma.LessonCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          findFirst: {
            args: Prisma.LessonCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          findMany: {
            args: Prisma.LessonCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          create: {
            args: Prisma.LessonCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          createMany: {
            args: Prisma.LessonCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          delete: {
            args: Prisma.LessonCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          update: {
            args: Prisma.LessonCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          deleteMany: {
            args: Prisma.LessonCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          upsert: {
            args: Prisma.LessonCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          aggregate: {
            args: Prisma.LessonCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonComment>
          }
          groupBy: {
            args: Prisma.LessonCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCommentCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentCountAggregateOutputType> | number
          }
        }
      }
      LessonCommentReply: {
        payload: Prisma.$LessonCommentReplyPayload<ExtArgs>
        fields: Prisma.LessonCommentReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonCommentReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonCommentReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          findFirst: {
            args: Prisma.LessonCommentReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonCommentReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          findMany: {
            args: Prisma.LessonCommentReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>[]
          }
          create: {
            args: Prisma.LessonCommentReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          createMany: {
            args: Prisma.LessonCommentReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCommentReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>[]
          }
          delete: {
            args: Prisma.LessonCommentReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          update: {
            args: Prisma.LessonCommentReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          deleteMany: {
            args: Prisma.LessonCommentReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonCommentReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonCommentReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>[]
          }
          upsert: {
            args: Prisma.LessonCommentReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentReplyPayload>
          }
          aggregate: {
            args: Prisma.LessonCommentReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonCommentReply>
          }
          groupBy: {
            args: Prisma.LessonCommentReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCommentReplyCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentReplyCountAggregateOutputType> | number
          }
        }
      }
      CourseRecommendation: {
        payload: Prisma.$CourseRecommendationPayload<ExtArgs>
        fields: Prisma.CourseRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          findFirst: {
            args: Prisma.CourseRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          findMany: {
            args: Prisma.CourseRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>[]
          }
          create: {
            args: Prisma.CourseRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          createMany: {
            args: Prisma.CourseRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>[]
          }
          delete: {
            args: Prisma.CourseRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          update: {
            args: Prisma.CourseRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.CourseRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.CourseRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRecommendationPayload>
          }
          aggregate: {
            args: Prisma.CourseRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseRecommendation>
          }
          groupBy: {
            args: Prisma.CourseRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<CourseRecommendationCountAggregateOutputType> | number
          }
        }
      }
      LessonRating: {
        payload: Prisma.$LessonRatingPayload<ExtArgs>
        fields: Prisma.LessonRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          findFirst: {
            args: Prisma.LessonRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          findMany: {
            args: Prisma.LessonRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>[]
          }
          create: {
            args: Prisma.LessonRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          createMany: {
            args: Prisma.LessonRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>[]
          }
          delete: {
            args: Prisma.LessonRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          update: {
            args: Prisma.LessonRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          deleteMany: {
            args: Prisma.LessonRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>[]
          }
          upsert: {
            args: Prisma.LessonRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonRatingPayload>
          }
          aggregate: {
            args: Prisma.LessonRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonRating>
          }
          groupBy: {
            args: Prisma.LessonRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonRatingCountArgs<ExtArgs>
            result: $Utils.Optional<LessonRatingCountAggregateOutputType> | number
          }
        }
      }
      LessonProgressEvent: {
        payload: Prisma.$LessonProgressEventPayload<ExtArgs>
        fields: Prisma.LessonProgressEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          findFirst: {
            args: Prisma.LessonProgressEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          findMany: {
            args: Prisma.LessonProgressEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>[]
          }
          create: {
            args: Prisma.LessonProgressEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          createMany: {
            args: Prisma.LessonProgressEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonProgressEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>[]
          }
          delete: {
            args: Prisma.LessonProgressEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          update: {
            args: Prisma.LessonProgressEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonProgressEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>[]
          }
          upsert: {
            args: Prisma.LessonProgressEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressEventPayload>
          }
          aggregate: {
            args: Prisma.LessonProgressEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonProgressEvent>
          }
          groupBy: {
            args: Prisma.LessonProgressEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressEventCountArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressEventCountAggregateOutputType> | number
          }
        }
      }
      LessonProgressAggregate: {
        payload: Prisma.$LessonProgressAggregatePayload<ExtArgs>
        fields: Prisma.LessonProgressAggregateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressAggregateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressAggregateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          findFirst: {
            args: Prisma.LessonProgressAggregateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressAggregateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          findMany: {
            args: Prisma.LessonProgressAggregateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>[]
          }
          create: {
            args: Prisma.LessonProgressAggregateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          createMany: {
            args: Prisma.LessonProgressAggregateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonProgressAggregateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>[]
          }
          delete: {
            args: Prisma.LessonProgressAggregateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          update: {
            args: Prisma.LessonProgressAggregateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressAggregateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressAggregateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonProgressAggregateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>[]
          }
          upsert: {
            args: Prisma.LessonProgressAggregateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressAggregatePayload>
          }
          aggregate: {
            args: Prisma.LessonProgressAggregateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonProgressAggregate>
          }
          groupBy: {
            args: Prisma.LessonProgressAggregateGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressAggregateGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressAggregateCountArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressAggregateCountAggregateOutputType> | number
          }
        }
      }
      EvolutionApiConfig: {
        payload: Prisma.$EvolutionApiConfigPayload<ExtArgs>
        fields: Prisma.EvolutionApiConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolutionApiConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolutionApiConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          findFirst: {
            args: Prisma.EvolutionApiConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolutionApiConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          findMany: {
            args: Prisma.EvolutionApiConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>[]
          }
          create: {
            args: Prisma.EvolutionApiConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          createMany: {
            args: Prisma.EvolutionApiConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvolutionApiConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>[]
          }
          delete: {
            args: Prisma.EvolutionApiConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          update: {
            args: Prisma.EvolutionApiConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          deleteMany: {
            args: Prisma.EvolutionApiConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolutionApiConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvolutionApiConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>[]
          }
          upsert: {
            args: Prisma.EvolutionApiConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionApiConfigPayload>
          }
          aggregate: {
            args: Prisma.EvolutionApiConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolutionApiConfig>
          }
          groupBy: {
            args: Prisma.EvolutionApiConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolutionApiConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolutionApiConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EvolutionApiConfigCountAggregateOutputType> | number
          }
        }
      }
      ContactSegment: {
        payload: Prisma.$ContactSegmentPayload<ExtArgs>
        fields: Prisma.ContactSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          findFirst: {
            args: Prisma.ContactSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          findMany: {
            args: Prisma.ContactSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>[]
          }
          create: {
            args: Prisma.ContactSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          createMany: {
            args: Prisma.ContactSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>[]
          }
          delete: {
            args: Prisma.ContactSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          update: {
            args: Prisma.ContactSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          deleteMany: {
            args: Prisma.ContactSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>[]
          }
          upsert: {
            args: Prisma.ContactSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSegmentPayload>
          }
          aggregate: {
            args: Prisma.ContactSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSegment>
          }
          groupBy: {
            args: Prisma.ContactSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSegmentCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignRun: {
        payload: Prisma.$CampaignRunPayload<ExtArgs>
        fields: Prisma.CampaignRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          findFirst: {
            args: Prisma.CampaignRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          findMany: {
            args: Prisma.CampaignRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>[]
          }
          create: {
            args: Prisma.CampaignRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          createMany: {
            args: Prisma.CampaignRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>[]
          }
          delete: {
            args: Prisma.CampaignRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          update: {
            args: Prisma.CampaignRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          deleteMany: {
            args: Prisma.CampaignRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>[]
          }
          upsert: {
            args: Prisma.CampaignRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRunPayload>
          }
          aggregate: {
            args: Prisma.CampaignRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignRun>
          }
          groupBy: {
            args: Prisma.CampaignRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignRunCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignRunCountAggregateOutputType> | number
          }
        }
      }
      CampaignMetrics: {
        payload: Prisma.$CampaignMetricsPayload<ExtArgs>
        fields: Prisma.CampaignMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          findFirst: {
            args: Prisma.CampaignMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          findMany: {
            args: Prisma.CampaignMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          create: {
            args: Prisma.CampaignMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          createMany: {
            args: Prisma.CampaignMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          delete: {
            args: Prisma.CampaignMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          update: {
            args: Prisma.CampaignMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          upsert: {
            args: Prisma.CampaignMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          aggregate: {
            args: Prisma.CampaignMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMetrics>
          }
          groupBy: {
            args: Prisma.CampaignMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricsCountAggregateOutputType> | number
          }
        }
      }
      CampaignTimelinePoint: {
        payload: Prisma.$CampaignTimelinePointPayload<ExtArgs>
        fields: Prisma.CampaignTimelinePointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignTimelinePointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignTimelinePointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          findFirst: {
            args: Prisma.CampaignTimelinePointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignTimelinePointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          findMany: {
            args: Prisma.CampaignTimelinePointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>[]
          }
          create: {
            args: Prisma.CampaignTimelinePointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          createMany: {
            args: Prisma.CampaignTimelinePointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignTimelinePointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>[]
          }
          delete: {
            args: Prisma.CampaignTimelinePointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          update: {
            args: Prisma.CampaignTimelinePointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          deleteMany: {
            args: Prisma.CampaignTimelinePointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignTimelinePointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignTimelinePointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>[]
          }
          upsert: {
            args: Prisma.CampaignTimelinePointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePointPayload>
          }
          aggregate: {
            args: Prisma.CampaignTimelinePointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignTimelinePoint>
          }
          groupBy: {
            args: Prisma.CampaignTimelinePointGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignTimelinePointGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignTimelinePointCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignTimelinePointCountAggregateOutputType> | number
          }
        }
      }
      ResourceCategory: {
        payload: Prisma.$ResourceCategoryPayload<ExtArgs>
        fields: Prisma.ResourceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ResourceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          findMany: {
            args: Prisma.ResourceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>[]
          }
          create: {
            args: Prisma.ResourceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          createMany: {
            args: Prisma.ResourceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ResourceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          update: {
            args: Prisma.ResourceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ResourceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ResourceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ResourceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceCategory>
          }
          groupBy: {
            args: Prisma.ResourceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCategoryCountAggregateOutputType> | number
          }
        }
      }
      ResourceTag: {
        payload: Prisma.$ResourceTagPayload<ExtArgs>
        fields: Prisma.ResourceTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          findFirst: {
            args: Prisma.ResourceTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          findMany: {
            args: Prisma.ResourceTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>[]
          }
          create: {
            args: Prisma.ResourceTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          createMany: {
            args: Prisma.ResourceTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>[]
          }
          delete: {
            args: Prisma.ResourceTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          update: {
            args: Prisma.ResourceTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          deleteMany: {
            args: Prisma.ResourceTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>[]
          }
          upsert: {
            args: Prisma.ResourceTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagPayload>
          }
          aggregate: {
            args: Prisma.ResourceTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceTag>
          }
          groupBy: {
            args: Prisma.ResourceTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceTagCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceTagCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      ResourceTagAssignment: {
        payload: Prisma.$ResourceTagAssignmentPayload<ExtArgs>
        fields: Prisma.ResourceTagAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceTagAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceTagAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ResourceTagAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceTagAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          findMany: {
            args: Prisma.ResourceTagAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>[]
          }
          create: {
            args: Prisma.ResourceTagAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          createMany: {
            args: Prisma.ResourceTagAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceTagAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ResourceTagAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          update: {
            args: Prisma.ResourceTagAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ResourceTagAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceTagAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceTagAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ResourceTagAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceTagAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ResourceTagAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceTagAssignment>
          }
          groupBy: {
            args: Prisma.ResourceTagAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceTagAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceTagAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceTagAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ResourceAsset: {
        payload: Prisma.$ResourceAssetPayload<ExtArgs>
        fields: Prisma.ResourceAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          findFirst: {
            args: Prisma.ResourceAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          findMany: {
            args: Prisma.ResourceAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>[]
          }
          create: {
            args: Prisma.ResourceAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          createMany: {
            args: Prisma.ResourceAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>[]
          }
          delete: {
            args: Prisma.ResourceAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          update: {
            args: Prisma.ResourceAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          deleteMany: {
            args: Prisma.ResourceAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>[]
          }
          upsert: {
            args: Prisma.ResourceAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceAssetPayload>
          }
          aggregate: {
            args: Prisma.ResourceAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceAsset>
          }
          groupBy: {
            args: Prisma.ResourceAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceAssetCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceAssetCountAggregateOutputType> | number
          }
        }
      }
      ResourceDownloadLog: {
        payload: Prisma.$ResourceDownloadLogPayload<ExtArgs>
        fields: Prisma.ResourceDownloadLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceDownloadLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceDownloadLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          findFirst: {
            args: Prisma.ResourceDownloadLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceDownloadLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          findMany: {
            args: Prisma.ResourceDownloadLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>[]
          }
          create: {
            args: Prisma.ResourceDownloadLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          createMany: {
            args: Prisma.ResourceDownloadLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceDownloadLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>[]
          }
          delete: {
            args: Prisma.ResourceDownloadLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          update: {
            args: Prisma.ResourceDownloadLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          deleteMany: {
            args: Prisma.ResourceDownloadLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceDownloadLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceDownloadLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>[]
          }
          upsert: {
            args: Prisma.ResourceDownloadLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceDownloadLogPayload>
          }
          aggregate: {
            args: Prisma.ResourceDownloadLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceDownloadLog>
          }
          groupBy: {
            args: Prisma.ResourceDownloadLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceDownloadLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceDownloadLogCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceDownloadLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    memberAccess?: MemberAccessOmit
    heroBanner?: HeroBannerOmit
    featureToggle?: FeatureToggleOmit
    memberAccessOverride?: MemberAccessOverrideOmit
    invitationTemplate?: InvitationTemplateOmit
    invitation?: InvitationOmit
    course?: CourseOmit
    courseModule?: CourseModuleOmit
    lesson?: LessonOmit
    courseProgress?: CourseProgressOmit
    lessonComment?: LessonCommentOmit
    lessonCommentReply?: LessonCommentReplyOmit
    courseRecommendation?: CourseRecommendationOmit
    lessonRating?: LessonRatingOmit
    lessonProgressEvent?: LessonProgressEventOmit
    lessonProgressAggregate?: LessonProgressAggregateOmit
    evolutionApiConfig?: EvolutionApiConfigOmit
    contactSegment?: ContactSegmentOmit
    messageTemplate?: MessageTemplateOmit
    campaign?: CampaignOmit
    campaignRun?: CampaignRunOmit
    campaignMetrics?: CampaignMetricsOmit
    campaignTimelinePoint?: CampaignTimelinePointOmit
    resourceCategory?: ResourceCategoryOmit
    resourceTag?: ResourceTagOmit
    resource?: ResourceOmit
    resourceTagAssignment?: ResourceTagAssignmentOmit
    resourceAsset?: ResourceAssetOmit
    resourceDownloadLog?: ResourceDownloadLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    courseProgresses: number
    coursesAuthored: number
    moderatedLessonCommentReplies: number
    lessonCommentReplies: number
    moderatedLessonComments: number
    lessonComments: number
    LessonProgressAggregate: number
    LessonProgressEvent: number
    LessonRating: number
    featureTogglesCreated: number
    createdBanners: number
    invitationsAccepted: number
    invitationsSent: number
    overridesGranted: number
    accessOverrides: number
    memberAccessGrants: number
    memberAccesses: number
    sessions: number
    resourceDownloadLogs: number
    resourcesAuthored: number
    campaignRunsInitiated: number
    campaigns: number
    contactSegments: number
    messageTemplates: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseProgresses?: boolean | UserCountOutputTypeCountCourseProgressesArgs
    coursesAuthored?: boolean | UserCountOutputTypeCountCoursesAuthoredArgs
    moderatedLessonCommentReplies?: boolean | UserCountOutputTypeCountModeratedLessonCommentRepliesArgs
    lessonCommentReplies?: boolean | UserCountOutputTypeCountLessonCommentRepliesArgs
    moderatedLessonComments?: boolean | UserCountOutputTypeCountModeratedLessonCommentsArgs
    lessonComments?: boolean | UserCountOutputTypeCountLessonCommentsArgs
    LessonProgressAggregate?: boolean | UserCountOutputTypeCountLessonProgressAggregateArgs
    LessonProgressEvent?: boolean | UserCountOutputTypeCountLessonProgressEventArgs
    LessonRating?: boolean | UserCountOutputTypeCountLessonRatingArgs
    featureTogglesCreated?: boolean | UserCountOutputTypeCountFeatureTogglesCreatedArgs
    createdBanners?: boolean | UserCountOutputTypeCountCreatedBannersArgs
    invitationsAccepted?: boolean | UserCountOutputTypeCountInvitationsAcceptedArgs
    invitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs
    overridesGranted?: boolean | UserCountOutputTypeCountOverridesGrantedArgs
    accessOverrides?: boolean | UserCountOutputTypeCountAccessOverridesArgs
    memberAccessGrants?: boolean | UserCountOutputTypeCountMemberAccessGrantsArgs
    memberAccesses?: boolean | UserCountOutputTypeCountMemberAccessesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    resourceDownloadLogs?: boolean | UserCountOutputTypeCountResourceDownloadLogsArgs
    resourcesAuthored?: boolean | UserCountOutputTypeCountResourcesAuthoredArgs
    campaignRunsInitiated?: boolean | UserCountOutputTypeCountCampaignRunsInitiatedArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    contactSegments?: boolean | UserCountOutputTypeCountContactSegmentsArgs
    messageTemplates?: boolean | UserCountOutputTypeCountMessageTemplatesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseProgressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModeratedLessonCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModeratedLessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressAggregateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonProgressEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeatureTogglesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureToggleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBannerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsAcceptedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOverridesGrantedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessOverrideWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccessOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessOverrideWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberAccessGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourceDownloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceDownloadLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourcesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignRunsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSegmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    progresses: number
    recommendations: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    progresses?: boolean | CourseCountOutputTypeCountProgressesArgs
    recommendations?: boolean | CourseCountOutputTypeCountRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountProgressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRecommendationWhereInput
  }


  /**
   * Count Type CourseModuleCountOutputType
   */

  export type CourseModuleCountOutputType = {
    dependentModules: number
    lessons: number
  }

  export type CourseModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependentModules?: boolean | CourseModuleCountOutputTypeCountDependentModulesArgs
    lessons?: boolean | CourseModuleCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModuleCountOutputType
     */
    select?: CourseModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountDependentModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    comments: number
    progressAggregates: number
    progressEvents: number
    ratings: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | LessonCountOutputTypeCountCommentsArgs
    progressAggregates?: boolean | LessonCountOutputTypeCountProgressAggregatesArgs
    progressEvents?: boolean | LessonCountOutputTypeCountProgressEventsArgs
    ratings?: boolean | LessonCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressAggregatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressAggregateWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressEventWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonRatingWhereInput
  }


  /**
   * Count Type LessonCommentCountOutputType
   */

  export type LessonCommentCountOutputType = {
    replies: number
  }

  export type LessonCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | LessonCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * LessonCommentCountOutputType without action
   */
  export type LessonCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentCountOutputType
     */
    select?: LessonCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCommentCountOutputType without action
   */
  export type LessonCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentReplyWhereInput
  }


  /**
   * Count Type LessonCommentReplyCountOutputType
   */

  export type LessonCommentReplyCountOutputType = {
    replies: number
  }

  export type LessonCommentReplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | LessonCommentReplyCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * LessonCommentReplyCountOutputType without action
   */
  export type LessonCommentReplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReplyCountOutputType
     */
    select?: LessonCommentReplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCommentReplyCountOutputType without action
   */
  export type LessonCommentReplyCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentReplyWhereInput
  }


  /**
   * Count Type EvolutionApiConfigCountOutputType
   */

  export type EvolutionApiConfigCountOutputType = {
    campaigns: number
  }

  export type EvolutionApiConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | EvolutionApiConfigCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * EvolutionApiConfigCountOutputType without action
   */
  export type EvolutionApiConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfigCountOutputType
     */
    select?: EvolutionApiConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvolutionApiConfigCountOutputType without action
   */
  export type EvolutionApiConfigCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type ContactSegmentCountOutputType
   */

  export type ContactSegmentCountOutputType = {
    campaigns: number
  }

  export type ContactSegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ContactSegmentCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ContactSegmentCountOutputType without action
   */
  export type ContactSegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegmentCountOutputType
     */
    select?: ContactSegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactSegmentCountOutputType without action
   */
  export type ContactSegmentCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type MessageTemplateCountOutputType
   */

  export type MessageTemplateCountOutputType = {
    campaigns: number
  }

  export type MessageTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | MessageTemplateCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * MessageTemplateCountOutputType without action
   */
  export type MessageTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplateCountOutputType
     */
    select?: MessageTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageTemplateCountOutputType without action
   */
  export type MessageTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    runs: number
    timeline: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | CampaignCountOutputTypeCountRunsArgs
    timeline?: boolean | CampaignCountOutputTypeCountTimelineArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRunWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTimelinePointWhereInput
  }


  /**
   * Count Type ResourceCategoryCountOutputType
   */

  export type ResourceCategoryCountOutputType = {
    resources: number
  }

  export type ResourceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | ResourceCategoryCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * ResourceCategoryCountOutputType without action
   */
  export type ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategoryCountOutputType
     */
    select?: ResourceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCategoryCountOutputType without action
   */
  export type ResourceCategoryCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type ResourceTagCountOutputType
   */

  export type ResourceTagCountOutputType = {
    tagAssignments: number
  }

  export type ResourceTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagAssignments?: boolean | ResourceTagCountOutputTypeCountTagAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ResourceTagCountOutputType without action
   */
  export type ResourceTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagCountOutputType
     */
    select?: ResourceTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceTagCountOutputType without action
   */
  export type ResourceTagCountOutputTypeCountTagAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceTagAssignmentWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    assets: number
    downloads: number
    tags: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | ResourceCountOutputTypeCountAssetsArgs
    downloads?: boolean | ResourceCountOutputTypeCountDownloadsArgs
    tags?: boolean | ResourceCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceAssetWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountDownloadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceDownloadLogWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceTagAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    profileDisplayName: string | null
    profileAvatarUrl: string | null
    profileBio: string | null
    profileTimezone: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    profileDisplayName: string | null
    profileAvatarUrl: string | null
    profileBio: string | null
    profileTimezone: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    profileDisplayName: number
    profileAvatarUrl: number
    profileBio: number
    profileTimezone: number
    profileBadges: number
    profileSocialLinks: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    profileDisplayName?: true
    profileAvatarUrl?: true
    profileBio?: true
    profileTimezone?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    profileDisplayName?: true
    profileAvatarUrl?: true
    profileBio?: true
    profileTimezone?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    profileDisplayName?: true
    profileAvatarUrl?: true
    profileBio?: true
    profileTimezone?: true
    profileBadges?: true
    profileSocialLinks?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl: string | null
    profileBio: string | null
    profileTimezone: string
    profileBadges: string[]
    profileSocialLinks: JsonValue
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    profileDisplayName?: boolean
    profileAvatarUrl?: boolean
    profileBio?: boolean
    profileTimezone?: boolean
    profileBadges?: boolean
    profileSocialLinks?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseProgresses?: boolean | User$courseProgressesArgs<ExtArgs>
    coursesAuthored?: boolean | User$coursesAuthoredArgs<ExtArgs>
    moderatedLessonCommentReplies?: boolean | User$moderatedLessonCommentRepliesArgs<ExtArgs>
    lessonCommentReplies?: boolean | User$lessonCommentRepliesArgs<ExtArgs>
    moderatedLessonComments?: boolean | User$moderatedLessonCommentsArgs<ExtArgs>
    lessonComments?: boolean | User$lessonCommentsArgs<ExtArgs>
    LessonProgressAggregate?: boolean | User$LessonProgressAggregateArgs<ExtArgs>
    LessonProgressEvent?: boolean | User$LessonProgressEventArgs<ExtArgs>
    LessonRating?: boolean | User$LessonRatingArgs<ExtArgs>
    featureTogglesCreated?: boolean | User$featureTogglesCreatedArgs<ExtArgs>
    createdBanners?: boolean | User$createdBannersArgs<ExtArgs>
    invitationsAccepted?: boolean | User$invitationsAcceptedArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    overridesGranted?: boolean | User$overridesGrantedArgs<ExtArgs>
    accessOverrides?: boolean | User$accessOverridesArgs<ExtArgs>
    memberAccessGrants?: boolean | User$memberAccessGrantsArgs<ExtArgs>
    memberAccesses?: boolean | User$memberAccessesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    resourceDownloadLogs?: boolean | User$resourceDownloadLogsArgs<ExtArgs>
    resourcesAuthored?: boolean | User$resourcesAuthoredArgs<ExtArgs>
    campaignRunsInitiated?: boolean | User$campaignRunsInitiatedArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    contactSegments?: boolean | User$contactSegmentsArgs<ExtArgs>
    evolutionConfig?: boolean | User$evolutionConfigArgs<ExtArgs>
    messageTemplates?: boolean | User$messageTemplatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    profileDisplayName?: boolean
    profileAvatarUrl?: boolean
    profileBio?: boolean
    profileTimezone?: boolean
    profileBadges?: boolean
    profileSocialLinks?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    profileDisplayName?: boolean
    profileAvatarUrl?: boolean
    profileBio?: boolean
    profileTimezone?: boolean
    profileBadges?: boolean
    profileSocialLinks?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    profileDisplayName?: boolean
    profileAvatarUrl?: boolean
    profileBio?: boolean
    profileTimezone?: boolean
    profileBadges?: boolean
    profileSocialLinks?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "role" | "profileDisplayName" | "profileAvatarUrl" | "profileBio" | "profileTimezone" | "profileBadges" | "profileSocialLinks" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseProgresses?: boolean | User$courseProgressesArgs<ExtArgs>
    coursesAuthored?: boolean | User$coursesAuthoredArgs<ExtArgs>
    moderatedLessonCommentReplies?: boolean | User$moderatedLessonCommentRepliesArgs<ExtArgs>
    lessonCommentReplies?: boolean | User$lessonCommentRepliesArgs<ExtArgs>
    moderatedLessonComments?: boolean | User$moderatedLessonCommentsArgs<ExtArgs>
    lessonComments?: boolean | User$lessonCommentsArgs<ExtArgs>
    LessonProgressAggregate?: boolean | User$LessonProgressAggregateArgs<ExtArgs>
    LessonProgressEvent?: boolean | User$LessonProgressEventArgs<ExtArgs>
    LessonRating?: boolean | User$LessonRatingArgs<ExtArgs>
    featureTogglesCreated?: boolean | User$featureTogglesCreatedArgs<ExtArgs>
    createdBanners?: boolean | User$createdBannersArgs<ExtArgs>
    invitationsAccepted?: boolean | User$invitationsAcceptedArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    overridesGranted?: boolean | User$overridesGrantedArgs<ExtArgs>
    accessOverrides?: boolean | User$accessOverridesArgs<ExtArgs>
    memberAccessGrants?: boolean | User$memberAccessGrantsArgs<ExtArgs>
    memberAccesses?: boolean | User$memberAccessesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    resourceDownloadLogs?: boolean | User$resourceDownloadLogsArgs<ExtArgs>
    resourcesAuthored?: boolean | User$resourcesAuthoredArgs<ExtArgs>
    campaignRunsInitiated?: boolean | User$campaignRunsInitiatedArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    contactSegments?: boolean | User$contactSegmentsArgs<ExtArgs>
    evolutionConfig?: boolean | User$evolutionConfigArgs<ExtArgs>
    messageTemplates?: boolean | User$messageTemplatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      courseProgresses: Prisma.$CourseProgressPayload<ExtArgs>[]
      coursesAuthored: Prisma.$CoursePayload<ExtArgs>[]
      moderatedLessonCommentReplies: Prisma.$LessonCommentReplyPayload<ExtArgs>[]
      lessonCommentReplies: Prisma.$LessonCommentReplyPayload<ExtArgs>[]
      moderatedLessonComments: Prisma.$LessonCommentPayload<ExtArgs>[]
      lessonComments: Prisma.$LessonCommentPayload<ExtArgs>[]
      LessonProgressAggregate: Prisma.$LessonProgressAggregatePayload<ExtArgs>[]
      LessonProgressEvent: Prisma.$LessonProgressEventPayload<ExtArgs>[]
      LessonRating: Prisma.$LessonRatingPayload<ExtArgs>[]
      featureTogglesCreated: Prisma.$FeatureTogglePayload<ExtArgs>[]
      createdBanners: Prisma.$HeroBannerPayload<ExtArgs>[]
      invitationsAccepted: Prisma.$InvitationPayload<ExtArgs>[]
      invitationsSent: Prisma.$InvitationPayload<ExtArgs>[]
      overridesGranted: Prisma.$MemberAccessOverridePayload<ExtArgs>[]
      accessOverrides: Prisma.$MemberAccessOverridePayload<ExtArgs>[]
      memberAccessGrants: Prisma.$MemberAccessPayload<ExtArgs>[]
      memberAccesses: Prisma.$MemberAccessPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      resourceDownloadLogs: Prisma.$ResourceDownloadLogPayload<ExtArgs>[]
      resourcesAuthored: Prisma.$ResourcePayload<ExtArgs>[]
      campaignRunsInitiated: Prisma.$CampaignRunPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      contactSegments: Prisma.$ContactSegmentPayload<ExtArgs>[]
      evolutionConfig: Prisma.$EvolutionApiConfigPayload<ExtArgs> | null
      messageTemplates: Prisma.$MessageTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      profileDisplayName: string
      profileAvatarUrl: string | null
      profileBio: string | null
      profileTimezone: string
      profileBadges: string[]
      profileSocialLinks: Prisma.JsonValue
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseProgresses<T extends User$courseProgressesArgs<ExtArgs> = {}>(args?: Subset<T, User$courseProgressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coursesAuthored<T extends User$coursesAuthoredArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesAuthoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderatedLessonCommentReplies<T extends User$moderatedLessonCommentRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$moderatedLessonCommentRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonCommentReplies<T extends User$lessonCommentRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonCommentRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderatedLessonComments<T extends User$moderatedLessonCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$moderatedLessonCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonComments<T extends User$lessonCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LessonProgressAggregate<T extends User$LessonProgressAggregateArgs<ExtArgs> = {}>(args?: Subset<T, User$LessonProgressAggregateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LessonProgressEvent<T extends User$LessonProgressEventArgs<ExtArgs> = {}>(args?: Subset<T, User$LessonProgressEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LessonRating<T extends User$LessonRatingArgs<ExtArgs> = {}>(args?: Subset<T, User$LessonRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featureTogglesCreated<T extends User$featureTogglesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$featureTogglesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBanners<T extends User$createdBannersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitationsAccepted<T extends User$invitationsAcceptedArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsAcceptedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitationsSent<T extends User$invitationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overridesGranted<T extends User$overridesGrantedArgs<ExtArgs> = {}>(args?: Subset<T, User$overridesGrantedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accessOverrides<T extends User$accessOverridesArgs<ExtArgs> = {}>(args?: Subset<T, User$accessOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberAccessGrants<T extends User$memberAccessGrantsArgs<ExtArgs> = {}>(args?: Subset<T, User$memberAccessGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberAccesses<T extends User$memberAccessesArgs<ExtArgs> = {}>(args?: Subset<T, User$memberAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resourceDownloadLogs<T extends User$resourceDownloadLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$resourceDownloadLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resourcesAuthored<T extends User$resourcesAuthoredArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesAuthoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaignRunsInitiated<T extends User$campaignRunsInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignRunsInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactSegments<T extends User$contactSegmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactSegmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolutionConfig<T extends User$evolutionConfigArgs<ExtArgs> = {}>(args?: Subset<T, User$evolutionConfigArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messageTemplates<T extends User$messageTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$messageTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly profileDisplayName: FieldRef<"User", 'String'>
    readonly profileAvatarUrl: FieldRef<"User", 'String'>
    readonly profileBio: FieldRef<"User", 'String'>
    readonly profileTimezone: FieldRef<"User", 'String'>
    readonly profileBadges: FieldRef<"User", 'String[]'>
    readonly profileSocialLinks: FieldRef<"User", 'Json'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.courseProgresses
   */
  export type User$courseProgressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    cursor?: CourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * User.coursesAuthored
   */
  export type User$coursesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.moderatedLessonCommentReplies
   */
  export type User$moderatedLessonCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    where?: LessonCommentReplyWhereInput
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    cursor?: LessonCommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * User.lessonCommentReplies
   */
  export type User$lessonCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    where?: LessonCommentReplyWhereInput
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    cursor?: LessonCommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * User.moderatedLessonComments
   */
  export type User$moderatedLessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * User.lessonComments
   */
  export type User$lessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * User.LessonProgressAggregate
   */
  export type User$LessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    where?: LessonProgressAggregateWhereInput
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    cursor?: LessonProgressAggregateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressAggregateScalarFieldEnum | LessonProgressAggregateScalarFieldEnum[]
  }

  /**
   * User.LessonProgressEvent
   */
  export type User$LessonProgressEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    where?: LessonProgressEventWhereInput
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    cursor?: LessonProgressEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressEventScalarFieldEnum | LessonProgressEventScalarFieldEnum[]
  }

  /**
   * User.LessonRating
   */
  export type User$LessonRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    where?: LessonRatingWhereInput
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    cursor?: LessonRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonRatingScalarFieldEnum | LessonRatingScalarFieldEnum[]
  }

  /**
   * User.featureTogglesCreated
   */
  export type User$featureTogglesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    where?: FeatureToggleWhereInput
    orderBy?: FeatureToggleOrderByWithRelationInput | FeatureToggleOrderByWithRelationInput[]
    cursor?: FeatureToggleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureToggleScalarFieldEnum | FeatureToggleScalarFieldEnum[]
  }

  /**
   * User.createdBanners
   */
  export type User$createdBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    where?: HeroBannerWhereInput
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    cursor?: HeroBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * User.invitationsAccepted
   */
  export type User$invitationsAcceptedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.invitationsSent
   */
  export type User$invitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.overridesGranted
   */
  export type User$overridesGrantedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    where?: MemberAccessOverrideWhereInput
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    cursor?: MemberAccessOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberAccessOverrideScalarFieldEnum | MemberAccessOverrideScalarFieldEnum[]
  }

  /**
   * User.accessOverrides
   */
  export type User$accessOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    where?: MemberAccessOverrideWhereInput
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    cursor?: MemberAccessOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberAccessOverrideScalarFieldEnum | MemberAccessOverrideScalarFieldEnum[]
  }

  /**
   * User.memberAccessGrants
   */
  export type User$memberAccessGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    where?: MemberAccessWhereInput
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    cursor?: MemberAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberAccessScalarFieldEnum | MemberAccessScalarFieldEnum[]
  }

  /**
   * User.memberAccesses
   */
  export type User$memberAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    where?: MemberAccessWhereInput
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    cursor?: MemberAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberAccessScalarFieldEnum | MemberAccessScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.resourceDownloadLogs
   */
  export type User$resourceDownloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    where?: ResourceDownloadLogWhereInput
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    cursor?: ResourceDownloadLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceDownloadLogScalarFieldEnum | ResourceDownloadLogScalarFieldEnum[]
  }

  /**
   * User.resourcesAuthored
   */
  export type User$resourcesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.campaignRunsInitiated
   */
  export type User$campaignRunsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    where?: CampaignRunWhereInput
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    cursor?: CampaignRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignRunScalarFieldEnum | CampaignRunScalarFieldEnum[]
  }

  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.contactSegments
   */
  export type User$contactSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    where?: ContactSegmentWhereInput
    orderBy?: ContactSegmentOrderByWithRelationInput | ContactSegmentOrderByWithRelationInput[]
    cursor?: ContactSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactSegmentScalarFieldEnum | ContactSegmentScalarFieldEnum[]
  }

  /**
   * User.evolutionConfig
   */
  export type User$evolutionConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    where?: EvolutionApiConfigWhereInput
  }

  /**
   * User.messageTemplates
   */
  export type User$messageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    cursor?: MessageTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    device: string | null
    userAgent: string | null
    ipAddress: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    device: string | null
    userAgent: string | null
    ipAddress: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshTokenHash: number
    device: number
    userAgent: number
    ipAddress: number
    lastUsedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    device?: true
    userAgent?: true
    ipAddress?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    device?: true
    userAgent?: true
    ipAddress?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    device?: true
    userAgent?: true
    ipAddress?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshTokenHash: string
    device: string
    userAgent: string
    ipAddress: string
    lastUsedAt: Date | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    device?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    device?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    device?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    device?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshTokenHash" | "device" | "userAgent" | "ipAddress" | "lastUsedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshTokenHash: string
      device: string
      userAgent: string
      ipAddress: string
      lastUsedAt: Date | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshTokenHash: FieldRef<"Session", 'String'>
    readonly device: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly lastUsedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model MemberAccess
   */

  export type AggregateMemberAccess = {
    _count: MemberAccessCountAggregateOutputType | null
    _min: MemberAccessMinAggregateOutputType | null
    _max: MemberAccessMaxAggregateOutputType | null
  }

  export type MemberAccessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: $Enums.FeatureAccessKey | null
    enabled: boolean | null
    grantedById: string | null
    grantedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberAccessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: $Enums.FeatureAccessKey | null
    enabled: boolean | null
    grantedById: string | null
    grantedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberAccessCountAggregateOutputType = {
    id: number
    userId: number
    feature: number
    enabled: number
    permissions: number
    grantedById: number
    grantedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberAccessMinAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    grantedById?: true
    grantedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    grantedById?: true
    grantedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberAccessCountAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    permissions?: true
    grantedById?: true
    grantedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAccess to aggregate.
     */
    where?: MemberAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccesses to fetch.
     */
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberAccesses
    **/
    _count?: true | MemberAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberAccessMaxAggregateInputType
  }

  export type GetMemberAccessAggregateType<T extends MemberAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberAccess[P]>
      : GetScalarType<T[P], AggregateMemberAccess[P]>
  }




  export type MemberAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessWhereInput
    orderBy?: MemberAccessOrderByWithAggregationInput | MemberAccessOrderByWithAggregationInput[]
    by: MemberAccessScalarFieldEnum[] | MemberAccessScalarFieldEnum
    having?: MemberAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberAccessCountAggregateInputType | true
    _min?: MemberAccessMinAggregateInputType
    _max?: MemberAccessMaxAggregateInputType
  }

  export type MemberAccessGroupByOutputType = {
    id: string
    userId: string
    feature: $Enums.FeatureAccessKey
    enabled: boolean
    permissions: string[]
    grantedById: string | null
    grantedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MemberAccessCountAggregateOutputType | null
    _min: MemberAccessMinAggregateOutputType | null
    _max: MemberAccessMaxAggregateOutputType | null
  }

  type GetMemberAccessGroupByPayload<T extends MemberAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberAccessGroupByOutputType[P]>
            : GetScalarType<T[P], MemberAccessGroupByOutputType[P]>
        }
      >
    >


  export type MemberAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccess"]>

  export type MemberAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccess"]>

  export type MemberAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccess"]>

  export type MemberAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "feature" | "enabled" | "permissions" | "grantedById" | "grantedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["memberAccess"]>
  export type MemberAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | MemberAccess$grantedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberAccess"
    objects: {
      grantedBy: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      feature: $Enums.FeatureAccessKey
      enabled: boolean
      permissions: string[]
      grantedById: string | null
      grantedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["memberAccess"]>
    composites: {}
  }

  type MemberAccessGetPayload<S extends boolean | null | undefined | MemberAccessDefaultArgs> = $Result.GetResult<Prisma.$MemberAccessPayload, S>

  type MemberAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberAccessCountAggregateInputType | true
    }

  export interface MemberAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberAccess'], meta: { name: 'MemberAccess' } }
    /**
     * Find zero or one MemberAccess that matches the filter.
     * @param {MemberAccessFindUniqueArgs} args - Arguments to find a MemberAccess
     * @example
     * // Get one MemberAccess
     * const memberAccess = await prisma.memberAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberAccessFindUniqueArgs>(args: SelectSubset<T, MemberAccessFindUniqueArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberAccessFindUniqueOrThrowArgs} args - Arguments to find a MemberAccess
     * @example
     * // Get one MemberAccess
     * const memberAccess = await prisma.memberAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessFindFirstArgs} args - Arguments to find a MemberAccess
     * @example
     * // Get one MemberAccess
     * const memberAccess = await prisma.memberAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberAccessFindFirstArgs>(args?: SelectSubset<T, MemberAccessFindFirstArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessFindFirstOrThrowArgs} args - Arguments to find a MemberAccess
     * @example
     * // Get one MemberAccess
     * const memberAccess = await prisma.memberAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberAccesses
     * const memberAccesses = await prisma.memberAccess.findMany()
     * 
     * // Get first 10 MemberAccesses
     * const memberAccesses = await prisma.memberAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberAccessWithIdOnly = await prisma.memberAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberAccessFindManyArgs>(args?: SelectSubset<T, MemberAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberAccess.
     * @param {MemberAccessCreateArgs} args - Arguments to create a MemberAccess.
     * @example
     * // Create one MemberAccess
     * const MemberAccess = await prisma.memberAccess.create({
     *   data: {
     *     // ... data to create a MemberAccess
     *   }
     * })
     * 
     */
    create<T extends MemberAccessCreateArgs>(args: SelectSubset<T, MemberAccessCreateArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberAccesses.
     * @param {MemberAccessCreateManyArgs} args - Arguments to create many MemberAccesses.
     * @example
     * // Create many MemberAccesses
     * const memberAccess = await prisma.memberAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberAccessCreateManyArgs>(args?: SelectSubset<T, MemberAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberAccesses and returns the data saved in the database.
     * @param {MemberAccessCreateManyAndReturnArgs} args - Arguments to create many MemberAccesses.
     * @example
     * // Create many MemberAccesses
     * const memberAccess = await prisma.memberAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberAccesses and only return the `id`
     * const memberAccessWithIdOnly = await prisma.memberAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberAccess.
     * @param {MemberAccessDeleteArgs} args - Arguments to delete one MemberAccess.
     * @example
     * // Delete one MemberAccess
     * const MemberAccess = await prisma.memberAccess.delete({
     *   where: {
     *     // ... filter to delete one MemberAccess
     *   }
     * })
     * 
     */
    delete<T extends MemberAccessDeleteArgs>(args: SelectSubset<T, MemberAccessDeleteArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberAccess.
     * @param {MemberAccessUpdateArgs} args - Arguments to update one MemberAccess.
     * @example
     * // Update one MemberAccess
     * const memberAccess = await prisma.memberAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberAccessUpdateArgs>(args: SelectSubset<T, MemberAccessUpdateArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberAccesses.
     * @param {MemberAccessDeleteManyArgs} args - Arguments to filter MemberAccesses to delete.
     * @example
     * // Delete a few MemberAccesses
     * const { count } = await prisma.memberAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberAccessDeleteManyArgs>(args?: SelectSubset<T, MemberAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberAccesses
     * const memberAccess = await prisma.memberAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberAccessUpdateManyArgs>(args: SelectSubset<T, MemberAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAccesses and returns the data updated in the database.
     * @param {MemberAccessUpdateManyAndReturnArgs} args - Arguments to update many MemberAccesses.
     * @example
     * // Update many MemberAccesses
     * const memberAccess = await prisma.memberAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberAccesses and only return the `id`
     * const memberAccessWithIdOnly = await prisma.memberAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberAccess.
     * @param {MemberAccessUpsertArgs} args - Arguments to update or create a MemberAccess.
     * @example
     * // Update or create a MemberAccess
     * const memberAccess = await prisma.memberAccess.upsert({
     *   create: {
     *     // ... data to create a MemberAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberAccess we want to update
     *   }
     * })
     */
    upsert<T extends MemberAccessUpsertArgs>(args: SelectSubset<T, MemberAccessUpsertArgs<ExtArgs>>): Prisma__MemberAccessClient<$Result.GetResult<Prisma.$MemberAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessCountArgs} args - Arguments to filter MemberAccesses to count.
     * @example
     * // Count the number of MemberAccesses
     * const count = await prisma.memberAccess.count({
     *   where: {
     *     // ... the filter for the MemberAccesses we want to count
     *   }
     * })
    **/
    count<T extends MemberAccessCountArgs>(
      args?: Subset<T, MemberAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAccessAggregateArgs>(args: Subset<T, MemberAccessAggregateArgs>): Prisma.PrismaPromise<GetMemberAccessAggregateType<T>>

    /**
     * Group by MemberAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberAccessGroupByArgs['orderBy'] }
        : { orderBy?: MemberAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberAccess model
   */
  readonly fields: MemberAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grantedBy<T extends MemberAccess$grantedByArgs<ExtArgs> = {}>(args?: Subset<T, MemberAccess$grantedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberAccess model
   */
  interface MemberAccessFieldRefs {
    readonly id: FieldRef<"MemberAccess", 'String'>
    readonly userId: FieldRef<"MemberAccess", 'String'>
    readonly feature: FieldRef<"MemberAccess", 'FeatureAccessKey'>
    readonly enabled: FieldRef<"MemberAccess", 'Boolean'>
    readonly permissions: FieldRef<"MemberAccess", 'String[]'>
    readonly grantedById: FieldRef<"MemberAccess", 'String'>
    readonly grantedAt: FieldRef<"MemberAccess", 'DateTime'>
    readonly createdAt: FieldRef<"MemberAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberAccess findUnique
   */
  export type MemberAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccess to fetch.
     */
    where: MemberAccessWhereUniqueInput
  }

  /**
   * MemberAccess findUniqueOrThrow
   */
  export type MemberAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccess to fetch.
     */
    where: MemberAccessWhereUniqueInput
  }

  /**
   * MemberAccess findFirst
   */
  export type MemberAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccess to fetch.
     */
    where?: MemberAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccesses to fetch.
     */
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAccesses.
     */
    cursor?: MemberAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAccesses.
     */
    distinct?: MemberAccessScalarFieldEnum | MemberAccessScalarFieldEnum[]
  }

  /**
   * MemberAccess findFirstOrThrow
   */
  export type MemberAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccess to fetch.
     */
    where?: MemberAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccesses to fetch.
     */
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAccesses.
     */
    cursor?: MemberAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAccesses.
     */
    distinct?: MemberAccessScalarFieldEnum | MemberAccessScalarFieldEnum[]
  }

  /**
   * MemberAccess findMany
   */
  export type MemberAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccesses to fetch.
     */
    where?: MemberAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccesses to fetch.
     */
    orderBy?: MemberAccessOrderByWithRelationInput | MemberAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberAccesses.
     */
    cursor?: MemberAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccesses.
     */
    skip?: number
    distinct?: MemberAccessScalarFieldEnum | MemberAccessScalarFieldEnum[]
  }

  /**
   * MemberAccess create
   */
  export type MemberAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberAccess.
     */
    data: XOR<MemberAccessCreateInput, MemberAccessUncheckedCreateInput>
  }

  /**
   * MemberAccess createMany
   */
  export type MemberAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberAccesses.
     */
    data: MemberAccessCreateManyInput | MemberAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberAccess createManyAndReturn
   */
  export type MemberAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * The data used to create many MemberAccesses.
     */
    data: MemberAccessCreateManyInput | MemberAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAccess update
   */
  export type MemberAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberAccess.
     */
    data: XOR<MemberAccessUpdateInput, MemberAccessUncheckedUpdateInput>
    /**
     * Choose, which MemberAccess to update.
     */
    where: MemberAccessWhereUniqueInput
  }

  /**
   * MemberAccess updateMany
   */
  export type MemberAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberAccesses.
     */
    data: XOR<MemberAccessUpdateManyMutationInput, MemberAccessUncheckedUpdateManyInput>
    /**
     * Filter which MemberAccesses to update
     */
    where?: MemberAccessWhereInput
    /**
     * Limit how many MemberAccesses to update.
     */
    limit?: number
  }

  /**
   * MemberAccess updateManyAndReturn
   */
  export type MemberAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * The data used to update MemberAccesses.
     */
    data: XOR<MemberAccessUpdateManyMutationInput, MemberAccessUncheckedUpdateManyInput>
    /**
     * Filter which MemberAccesses to update
     */
    where?: MemberAccessWhereInput
    /**
     * Limit how many MemberAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAccess upsert
   */
  export type MemberAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberAccess to update in case it exists.
     */
    where: MemberAccessWhereUniqueInput
    /**
     * In case the MemberAccess found by the `where` argument doesn't exist, create a new MemberAccess with this data.
     */
    create: XOR<MemberAccessCreateInput, MemberAccessUncheckedCreateInput>
    /**
     * In case the MemberAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberAccessUpdateInput, MemberAccessUncheckedUpdateInput>
  }

  /**
   * MemberAccess delete
   */
  export type MemberAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
    /**
     * Filter which MemberAccess to delete.
     */
    where: MemberAccessWhereUniqueInput
  }

  /**
   * MemberAccess deleteMany
   */
  export type MemberAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAccesses to delete
     */
    where?: MemberAccessWhereInput
    /**
     * Limit how many MemberAccesses to delete.
     */
    limit?: number
  }

  /**
   * MemberAccess.grantedBy
   */
  export type MemberAccess$grantedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MemberAccess without action
   */
  export type MemberAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccess
     */
    select?: MemberAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccess
     */
    omit?: MemberAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessInclude<ExtArgs> | null
  }


  /**
   * Model HeroBanner
   */

  export type AggregateHeroBanner = {
    _count: HeroBannerCountAggregateOutputType | null
    _avg: HeroBannerAvgAggregateOutputType | null
    _sum: HeroBannerSumAggregateOutputType | null
    _min: HeroBannerMinAggregateOutputType | null
    _max: HeroBannerMaxAggregateOutputType | null
  }

  export type HeroBannerAvgAggregateOutputType = {
    order: number | null
  }

  export type HeroBannerSumAggregateOutputType = {
    order: number | null
  }

  export type HeroBannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    primaryCtaLabel: string | null
    primaryCtaHref: string | null
    primaryCtaExternal: boolean | null
    secondaryCtaLabel: string | null
    secondaryCtaHref: string | null
    secondaryCtaExternal: boolean | null
    imageUrl: string | null
    order: number | null
    status: $Enums.BannerStatus | null
    startsAt: Date | null
    endsAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroBannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    primaryCtaLabel: string | null
    primaryCtaHref: string | null
    primaryCtaExternal: boolean | null
    secondaryCtaLabel: string | null
    secondaryCtaHref: string | null
    secondaryCtaExternal: boolean | null
    imageUrl: string | null
    order: number | null
    status: $Enums.BannerStatus | null
    startsAt: Date | null
    endsAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroBannerCountAggregateOutputType = {
    id: number
    title: number
    description: number
    primaryCtaLabel: number
    primaryCtaHref: number
    primaryCtaExternal: number
    secondaryCtaLabel: number
    secondaryCtaHref: number
    secondaryCtaExternal: number
    imageUrl: number
    order: number
    status: number
    startsAt: number
    endsAt: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroBannerAvgAggregateInputType = {
    order?: true
  }

  export type HeroBannerSumAggregateInputType = {
    order?: true
  }

  export type HeroBannerMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    primaryCtaLabel?: true
    primaryCtaHref?: true
    primaryCtaExternal?: true
    secondaryCtaLabel?: true
    secondaryCtaHref?: true
    secondaryCtaExternal?: true
    imageUrl?: true
    order?: true
    status?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroBannerMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    primaryCtaLabel?: true
    primaryCtaHref?: true
    primaryCtaExternal?: true
    secondaryCtaLabel?: true
    secondaryCtaHref?: true
    secondaryCtaExternal?: true
    imageUrl?: true
    order?: true
    status?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroBannerCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    primaryCtaLabel?: true
    primaryCtaHref?: true
    primaryCtaExternal?: true
    secondaryCtaLabel?: true
    secondaryCtaHref?: true
    secondaryCtaExternal?: true
    imageUrl?: true
    order?: true
    status?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBanner to aggregate.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroBanners
    **/
    _count?: true | HeroBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeroBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeroBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroBannerMaxAggregateInputType
  }

  export type GetHeroBannerAggregateType<T extends HeroBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroBanner[P]>
      : GetScalarType<T[P], AggregateHeroBanner[P]>
  }




  export type HeroBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBannerWhereInput
    orderBy?: HeroBannerOrderByWithAggregationInput | HeroBannerOrderByWithAggregationInput[]
    by: HeroBannerScalarFieldEnum[] | HeroBannerScalarFieldEnum
    having?: HeroBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroBannerCountAggregateInputType | true
    _avg?: HeroBannerAvgAggregateInputType
    _sum?: HeroBannerSumAggregateInputType
    _min?: HeroBannerMinAggregateInputType
    _max?: HeroBannerMaxAggregateInputType
  }

  export type HeroBannerGroupByOutputType = {
    id: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal: boolean
    secondaryCtaLabel: string | null
    secondaryCtaHref: string | null
    secondaryCtaExternal: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt: Date | null
    endsAt: Date | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: HeroBannerCountAggregateOutputType | null
    _avg: HeroBannerAvgAggregateOutputType | null
    _sum: HeroBannerSumAggregateOutputType | null
    _min: HeroBannerMinAggregateOutputType | null
    _max: HeroBannerMaxAggregateOutputType | null
  }

  type GetHeroBannerGroupByPayload<T extends HeroBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroBannerGroupByOutputType[P]>
            : GetScalarType<T[P], HeroBannerGroupByOutputType[P]>
        }
      >
    >


  export type HeroBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    primaryCtaLabel?: boolean
    primaryCtaHref?: boolean
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: boolean
    secondaryCtaHref?: boolean
    secondaryCtaExternal?: boolean
    imageUrl?: boolean
    order?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBanner"]>

  export type HeroBannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    primaryCtaLabel?: boolean
    primaryCtaHref?: boolean
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: boolean
    secondaryCtaHref?: boolean
    secondaryCtaExternal?: boolean
    imageUrl?: boolean
    order?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBanner"]>

  export type HeroBannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    primaryCtaLabel?: boolean
    primaryCtaHref?: boolean
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: boolean
    secondaryCtaHref?: boolean
    secondaryCtaExternal?: boolean
    imageUrl?: boolean
    order?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBanner"]>

  export type HeroBannerSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    primaryCtaLabel?: boolean
    primaryCtaHref?: boolean
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: boolean
    secondaryCtaHref?: boolean
    secondaryCtaExternal?: boolean
    imageUrl?: boolean
    order?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroBannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "primaryCtaLabel" | "primaryCtaHref" | "primaryCtaExternal" | "secondaryCtaLabel" | "secondaryCtaHref" | "secondaryCtaExternal" | "imageUrl" | "order" | "status" | "startsAt" | "endsAt" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["heroBanner"]>
  export type HeroBannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HeroBannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HeroBannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HeroBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroBanner"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      primaryCtaLabel: string
      primaryCtaHref: string
      primaryCtaExternal: boolean
      secondaryCtaLabel: string | null
      secondaryCtaHref: string | null
      secondaryCtaExternal: boolean | null
      imageUrl: string
      order: number
      status: $Enums.BannerStatus
      startsAt: Date | null
      endsAt: Date | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroBanner"]>
    composites: {}
  }

  type HeroBannerGetPayload<S extends boolean | null | undefined | HeroBannerDefaultArgs> = $Result.GetResult<Prisma.$HeroBannerPayload, S>

  type HeroBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroBannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroBannerCountAggregateInputType | true
    }

  export interface HeroBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroBanner'], meta: { name: 'HeroBanner' } }
    /**
     * Find zero or one HeroBanner that matches the filter.
     * @param {HeroBannerFindUniqueArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroBannerFindUniqueArgs>(args: SelectSubset<T, HeroBannerFindUniqueArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroBanner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroBannerFindUniqueOrThrowArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindFirstArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroBannerFindFirstArgs>(args?: SelectSubset<T, HeroBannerFindFirstArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindFirstOrThrowArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroBanners
     * const heroBanners = await prisma.heroBanner.findMany()
     * 
     * // Get first 10 HeroBanners
     * const heroBanners = await prisma.heroBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroBannerWithIdOnly = await prisma.heroBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroBannerFindManyArgs>(args?: SelectSubset<T, HeroBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroBanner.
     * @param {HeroBannerCreateArgs} args - Arguments to create a HeroBanner.
     * @example
     * // Create one HeroBanner
     * const HeroBanner = await prisma.heroBanner.create({
     *   data: {
     *     // ... data to create a HeroBanner
     *   }
     * })
     * 
     */
    create<T extends HeroBannerCreateArgs>(args: SelectSubset<T, HeroBannerCreateArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroBanners.
     * @param {HeroBannerCreateManyArgs} args - Arguments to create many HeroBanners.
     * @example
     * // Create many HeroBanners
     * const heroBanner = await prisma.heroBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroBannerCreateManyArgs>(args?: SelectSubset<T, HeroBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroBanners and returns the data saved in the database.
     * @param {HeroBannerCreateManyAndReturnArgs} args - Arguments to create many HeroBanners.
     * @example
     * // Create many HeroBanners
     * const heroBanner = await prisma.heroBanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroBanners and only return the `id`
     * const heroBannerWithIdOnly = await prisma.heroBanner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroBannerCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroBannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HeroBanner.
     * @param {HeroBannerDeleteArgs} args - Arguments to delete one HeroBanner.
     * @example
     * // Delete one HeroBanner
     * const HeroBanner = await prisma.heroBanner.delete({
     *   where: {
     *     // ... filter to delete one HeroBanner
     *   }
     * })
     * 
     */
    delete<T extends HeroBannerDeleteArgs>(args: SelectSubset<T, HeroBannerDeleteArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroBanner.
     * @param {HeroBannerUpdateArgs} args - Arguments to update one HeroBanner.
     * @example
     * // Update one HeroBanner
     * const heroBanner = await prisma.heroBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroBannerUpdateArgs>(args: SelectSubset<T, HeroBannerUpdateArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroBanners.
     * @param {HeroBannerDeleteManyArgs} args - Arguments to filter HeroBanners to delete.
     * @example
     * // Delete a few HeroBanners
     * const { count } = await prisma.heroBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroBannerDeleteManyArgs>(args?: SelectSubset<T, HeroBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroBanners
     * const heroBanner = await prisma.heroBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroBannerUpdateManyArgs>(args: SelectSubset<T, HeroBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroBanners and returns the data updated in the database.
     * @param {HeroBannerUpdateManyAndReturnArgs} args - Arguments to update many HeroBanners.
     * @example
     * // Update many HeroBanners
     * const heroBanner = await prisma.heroBanner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HeroBanners and only return the `id`
     * const heroBannerWithIdOnly = await prisma.heroBanner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HeroBannerUpdateManyAndReturnArgs>(args: SelectSubset<T, HeroBannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HeroBanner.
     * @param {HeroBannerUpsertArgs} args - Arguments to update or create a HeroBanner.
     * @example
     * // Update or create a HeroBanner
     * const heroBanner = await prisma.heroBanner.upsert({
     *   create: {
     *     // ... data to create a HeroBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroBanner we want to update
     *   }
     * })
     */
    upsert<T extends HeroBannerUpsertArgs>(args: SelectSubset<T, HeroBannerUpsertArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HeroBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerCountArgs} args - Arguments to filter HeroBanners to count.
     * @example
     * // Count the number of HeroBanners
     * const count = await prisma.heroBanner.count({
     *   where: {
     *     // ... the filter for the HeroBanners we want to count
     *   }
     * })
    **/
    count<T extends HeroBannerCountArgs>(
      args?: Subset<T, HeroBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroBannerAggregateArgs>(args: Subset<T, HeroBannerAggregateArgs>): Prisma.PrismaPromise<GetHeroBannerAggregateType<T>>

    /**
     * Group by HeroBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroBannerGroupByArgs['orderBy'] }
        : { orderBy?: HeroBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroBanner model
   */
  readonly fields: HeroBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroBanner model
   */
  interface HeroBannerFieldRefs {
    readonly id: FieldRef<"HeroBanner", 'String'>
    readonly title: FieldRef<"HeroBanner", 'String'>
    readonly description: FieldRef<"HeroBanner", 'String'>
    readonly primaryCtaLabel: FieldRef<"HeroBanner", 'String'>
    readonly primaryCtaHref: FieldRef<"HeroBanner", 'String'>
    readonly primaryCtaExternal: FieldRef<"HeroBanner", 'Boolean'>
    readonly secondaryCtaLabel: FieldRef<"HeroBanner", 'String'>
    readonly secondaryCtaHref: FieldRef<"HeroBanner", 'String'>
    readonly secondaryCtaExternal: FieldRef<"HeroBanner", 'Boolean'>
    readonly imageUrl: FieldRef<"HeroBanner", 'String'>
    readonly order: FieldRef<"HeroBanner", 'Int'>
    readonly status: FieldRef<"HeroBanner", 'BannerStatus'>
    readonly startsAt: FieldRef<"HeroBanner", 'DateTime'>
    readonly endsAt: FieldRef<"HeroBanner", 'DateTime'>
    readonly createdById: FieldRef<"HeroBanner", 'String'>
    readonly createdAt: FieldRef<"HeroBanner", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroBanner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroBanner findUnique
   */
  export type HeroBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner findUniqueOrThrow
   */
  export type HeroBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner findFirst
   */
  export type HeroBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBanners.
     */
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner findFirstOrThrow
   */
  export type HeroBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBanners.
     */
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner findMany
   */
  export type HeroBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter, which HeroBanners to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner create
   */
  export type HeroBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * The data needed to create a HeroBanner.
     */
    data: XOR<HeroBannerCreateInput, HeroBannerUncheckedCreateInput>
  }

  /**
   * HeroBanner createMany
   */
  export type HeroBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroBanners.
     */
    data: HeroBannerCreateManyInput | HeroBannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroBanner createManyAndReturn
   */
  export type HeroBannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * The data used to create many HeroBanners.
     */
    data: HeroBannerCreateManyInput | HeroBannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HeroBanner update
   */
  export type HeroBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * The data needed to update a HeroBanner.
     */
    data: XOR<HeroBannerUpdateInput, HeroBannerUncheckedUpdateInput>
    /**
     * Choose, which HeroBanner to update.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner updateMany
   */
  export type HeroBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroBanners.
     */
    data: XOR<HeroBannerUpdateManyMutationInput, HeroBannerUncheckedUpdateManyInput>
    /**
     * Filter which HeroBanners to update
     */
    where?: HeroBannerWhereInput
    /**
     * Limit how many HeroBanners to update.
     */
    limit?: number
  }

  /**
   * HeroBanner updateManyAndReturn
   */
  export type HeroBannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * The data used to update HeroBanners.
     */
    data: XOR<HeroBannerUpdateManyMutationInput, HeroBannerUncheckedUpdateManyInput>
    /**
     * Filter which HeroBanners to update
     */
    where?: HeroBannerWhereInput
    /**
     * Limit how many HeroBanners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HeroBanner upsert
   */
  export type HeroBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * The filter to search for the HeroBanner to update in case it exists.
     */
    where: HeroBannerWhereUniqueInput
    /**
     * In case the HeroBanner found by the `where` argument doesn't exist, create a new HeroBanner with this data.
     */
    create: XOR<HeroBannerCreateInput, HeroBannerUncheckedCreateInput>
    /**
     * In case the HeroBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroBannerUpdateInput, HeroBannerUncheckedUpdateInput>
  }

  /**
   * HeroBanner delete
   */
  export type HeroBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
    /**
     * Filter which HeroBanner to delete.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner deleteMany
   */
  export type HeroBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBanners to delete
     */
    where?: HeroBannerWhereInput
    /**
     * Limit how many HeroBanners to delete.
     */
    limit?: number
  }

  /**
   * HeroBanner without action
   */
  export type HeroBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBannerInclude<ExtArgs> | null
  }


  /**
   * Model FeatureToggle
   */

  export type AggregateFeatureToggle = {
    _count: FeatureToggleCountAggregateOutputType | null
    _avg: FeatureToggleAvgAggregateOutputType | null
    _sum: FeatureToggleSumAggregateOutputType | null
    _min: FeatureToggleMinAggregateOutputType | null
    _max: FeatureToggleMaxAggregateOutputType | null
  }

  export type FeatureToggleAvgAggregateOutputType = {
    rolloutPercentage: number | null
  }

  export type FeatureToggleSumAggregateOutputType = {
    rolloutPercentage: number | null
  }

  export type FeatureToggleMinAggregateOutputType = {
    id: string | null
    featureKey: string | null
    description: string | null
    status: $Enums.FeatureToggleStatus | null
    rolloutPercentage: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureToggleMaxAggregateOutputType = {
    id: string | null
    featureKey: string | null
    description: string | null
    status: $Enums.FeatureToggleStatus | null
    rolloutPercentage: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureToggleCountAggregateOutputType = {
    id: number
    featureKey: number
    description: number
    status: number
    rolloutPercentage: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureToggleAvgAggregateInputType = {
    rolloutPercentage?: true
  }

  export type FeatureToggleSumAggregateInputType = {
    rolloutPercentage?: true
  }

  export type FeatureToggleMinAggregateInputType = {
    id?: true
    featureKey?: true
    description?: true
    status?: true
    rolloutPercentage?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureToggleMaxAggregateInputType = {
    id?: true
    featureKey?: true
    description?: true
    status?: true
    rolloutPercentage?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureToggleCountAggregateInputType = {
    id?: true
    featureKey?: true
    description?: true
    status?: true
    rolloutPercentage?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureToggleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureToggle to aggregate.
     */
    where?: FeatureToggleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureToggles to fetch.
     */
    orderBy?: FeatureToggleOrderByWithRelationInput | FeatureToggleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureToggleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureToggles
    **/
    _count?: true | FeatureToggleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureToggleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureToggleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureToggleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureToggleMaxAggregateInputType
  }

  export type GetFeatureToggleAggregateType<T extends FeatureToggleAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureToggle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureToggle[P]>
      : GetScalarType<T[P], AggregateFeatureToggle[P]>
  }




  export type FeatureToggleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureToggleWhereInput
    orderBy?: FeatureToggleOrderByWithAggregationInput | FeatureToggleOrderByWithAggregationInput[]
    by: FeatureToggleScalarFieldEnum[] | FeatureToggleScalarFieldEnum
    having?: FeatureToggleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureToggleCountAggregateInputType | true
    _avg?: FeatureToggleAvgAggregateInputType
    _sum?: FeatureToggleSumAggregateInputType
    _min?: FeatureToggleMinAggregateInputType
    _max?: FeatureToggleMaxAggregateInputType
  }

  export type FeatureToggleGroupByOutputType = {
    id: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage: number
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: FeatureToggleCountAggregateOutputType | null
    _avg: FeatureToggleAvgAggregateOutputType | null
    _sum: FeatureToggleSumAggregateOutputType | null
    _min: FeatureToggleMinAggregateOutputType | null
    _max: FeatureToggleMaxAggregateOutputType | null
  }

  type GetFeatureToggleGroupByPayload<T extends FeatureToggleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureToggleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureToggleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureToggleGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureToggleGroupByOutputType[P]>
        }
      >
    >


  export type FeatureToggleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    description?: boolean
    status?: boolean
    rolloutPercentage?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureToggle"]>

  export type FeatureToggleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    description?: boolean
    status?: boolean
    rolloutPercentage?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureToggle"]>

  export type FeatureToggleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    description?: boolean
    status?: boolean
    rolloutPercentage?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureToggle"]>

  export type FeatureToggleSelectScalar = {
    id?: boolean
    featureKey?: boolean
    description?: boolean
    status?: boolean
    rolloutPercentage?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureToggleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "featureKey" | "description" | "status" | "rolloutPercentage" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["featureToggle"]>
  export type FeatureToggleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeatureToggleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeatureToggleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeatureTogglePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureToggle"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureKey: string
      description: string
      status: $Enums.FeatureToggleStatus
      rolloutPercentage: number
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureToggle"]>
    composites: {}
  }

  type FeatureToggleGetPayload<S extends boolean | null | undefined | FeatureToggleDefaultArgs> = $Result.GetResult<Prisma.$FeatureTogglePayload, S>

  type FeatureToggleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureToggleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureToggleCountAggregateInputType | true
    }

  export interface FeatureToggleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureToggle'], meta: { name: 'FeatureToggle' } }
    /**
     * Find zero or one FeatureToggle that matches the filter.
     * @param {FeatureToggleFindUniqueArgs} args - Arguments to find a FeatureToggle
     * @example
     * // Get one FeatureToggle
     * const featureToggle = await prisma.featureToggle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureToggleFindUniqueArgs>(args: SelectSubset<T, FeatureToggleFindUniqueArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureToggle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureToggleFindUniqueOrThrowArgs} args - Arguments to find a FeatureToggle
     * @example
     * // Get one FeatureToggle
     * const featureToggle = await prisma.featureToggle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureToggleFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureToggleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureToggle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleFindFirstArgs} args - Arguments to find a FeatureToggle
     * @example
     * // Get one FeatureToggle
     * const featureToggle = await prisma.featureToggle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureToggleFindFirstArgs>(args?: SelectSubset<T, FeatureToggleFindFirstArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureToggle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleFindFirstOrThrowArgs} args - Arguments to find a FeatureToggle
     * @example
     * // Get one FeatureToggle
     * const featureToggle = await prisma.featureToggle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureToggleFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureToggleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureToggles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureToggles
     * const featureToggles = await prisma.featureToggle.findMany()
     * 
     * // Get first 10 FeatureToggles
     * const featureToggles = await prisma.featureToggle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureToggleWithIdOnly = await prisma.featureToggle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureToggleFindManyArgs>(args?: SelectSubset<T, FeatureToggleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureToggle.
     * @param {FeatureToggleCreateArgs} args - Arguments to create a FeatureToggle.
     * @example
     * // Create one FeatureToggle
     * const FeatureToggle = await prisma.featureToggle.create({
     *   data: {
     *     // ... data to create a FeatureToggle
     *   }
     * })
     * 
     */
    create<T extends FeatureToggleCreateArgs>(args: SelectSubset<T, FeatureToggleCreateArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureToggles.
     * @param {FeatureToggleCreateManyArgs} args - Arguments to create many FeatureToggles.
     * @example
     * // Create many FeatureToggles
     * const featureToggle = await prisma.featureToggle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureToggleCreateManyArgs>(args?: SelectSubset<T, FeatureToggleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureToggles and returns the data saved in the database.
     * @param {FeatureToggleCreateManyAndReturnArgs} args - Arguments to create many FeatureToggles.
     * @example
     * // Create many FeatureToggles
     * const featureToggle = await prisma.featureToggle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureToggles and only return the `id`
     * const featureToggleWithIdOnly = await prisma.featureToggle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureToggleCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureToggleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureToggle.
     * @param {FeatureToggleDeleteArgs} args - Arguments to delete one FeatureToggle.
     * @example
     * // Delete one FeatureToggle
     * const FeatureToggle = await prisma.featureToggle.delete({
     *   where: {
     *     // ... filter to delete one FeatureToggle
     *   }
     * })
     * 
     */
    delete<T extends FeatureToggleDeleteArgs>(args: SelectSubset<T, FeatureToggleDeleteArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureToggle.
     * @param {FeatureToggleUpdateArgs} args - Arguments to update one FeatureToggle.
     * @example
     * // Update one FeatureToggle
     * const featureToggle = await prisma.featureToggle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureToggleUpdateArgs>(args: SelectSubset<T, FeatureToggleUpdateArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureToggles.
     * @param {FeatureToggleDeleteManyArgs} args - Arguments to filter FeatureToggles to delete.
     * @example
     * // Delete a few FeatureToggles
     * const { count } = await prisma.featureToggle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureToggleDeleteManyArgs>(args?: SelectSubset<T, FeatureToggleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureToggles
     * const featureToggle = await prisma.featureToggle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureToggleUpdateManyArgs>(args: SelectSubset<T, FeatureToggleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureToggles and returns the data updated in the database.
     * @param {FeatureToggleUpdateManyAndReturnArgs} args - Arguments to update many FeatureToggles.
     * @example
     * // Update many FeatureToggles
     * const featureToggle = await prisma.featureToggle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureToggles and only return the `id`
     * const featureToggleWithIdOnly = await prisma.featureToggle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureToggleUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureToggleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureToggle.
     * @param {FeatureToggleUpsertArgs} args - Arguments to update or create a FeatureToggle.
     * @example
     * // Update or create a FeatureToggle
     * const featureToggle = await prisma.featureToggle.upsert({
     *   create: {
     *     // ... data to create a FeatureToggle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureToggle we want to update
     *   }
     * })
     */
    upsert<T extends FeatureToggleUpsertArgs>(args: SelectSubset<T, FeatureToggleUpsertArgs<ExtArgs>>): Prisma__FeatureToggleClient<$Result.GetResult<Prisma.$FeatureTogglePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureToggles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleCountArgs} args - Arguments to filter FeatureToggles to count.
     * @example
     * // Count the number of FeatureToggles
     * const count = await prisma.featureToggle.count({
     *   where: {
     *     // ... the filter for the FeatureToggles we want to count
     *   }
     * })
    **/
    count<T extends FeatureToggleCountArgs>(
      args?: Subset<T, FeatureToggleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureToggleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureToggle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureToggleAggregateArgs>(args: Subset<T, FeatureToggleAggregateArgs>): Prisma.PrismaPromise<GetFeatureToggleAggregateType<T>>

    /**
     * Group by FeatureToggle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureToggleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureToggleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureToggleGroupByArgs['orderBy'] }
        : { orderBy?: FeatureToggleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureToggleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureToggleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureToggle model
   */
  readonly fields: FeatureToggleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureToggle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureToggleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureToggle model
   */
  interface FeatureToggleFieldRefs {
    readonly id: FieldRef<"FeatureToggle", 'String'>
    readonly featureKey: FieldRef<"FeatureToggle", 'String'>
    readonly description: FieldRef<"FeatureToggle", 'String'>
    readonly status: FieldRef<"FeatureToggle", 'FeatureToggleStatus'>
    readonly rolloutPercentage: FieldRef<"FeatureToggle", 'Int'>
    readonly createdById: FieldRef<"FeatureToggle", 'String'>
    readonly createdAt: FieldRef<"FeatureToggle", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureToggle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureToggle findUnique
   */
  export type FeatureToggleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter, which FeatureToggle to fetch.
     */
    where: FeatureToggleWhereUniqueInput
  }

  /**
   * FeatureToggle findUniqueOrThrow
   */
  export type FeatureToggleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter, which FeatureToggle to fetch.
     */
    where: FeatureToggleWhereUniqueInput
  }

  /**
   * FeatureToggle findFirst
   */
  export type FeatureToggleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter, which FeatureToggle to fetch.
     */
    where?: FeatureToggleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureToggles to fetch.
     */
    orderBy?: FeatureToggleOrderByWithRelationInput | FeatureToggleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureToggles.
     */
    cursor?: FeatureToggleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureToggles.
     */
    distinct?: FeatureToggleScalarFieldEnum | FeatureToggleScalarFieldEnum[]
  }

  /**
   * FeatureToggle findFirstOrThrow
   */
  export type FeatureToggleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter, which FeatureToggle to fetch.
     */
    where?: FeatureToggleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureToggles to fetch.
     */
    orderBy?: FeatureToggleOrderByWithRelationInput | FeatureToggleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureToggles.
     */
    cursor?: FeatureToggleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureToggles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureToggles.
     */
    distinct?: FeatureToggleScalarFieldEnum | FeatureToggleScalarFieldEnum[]
  }

  /**
   * FeatureToggle findMany
   */
  export type FeatureToggleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter, which FeatureToggles to fetch.
     */
    where?: FeatureToggleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureToggles to fetch.
     */
    orderBy?: FeatureToggleOrderByWithRelationInput | FeatureToggleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureToggles.
     */
    cursor?: FeatureToggleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureToggles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureToggles.
     */
    skip?: number
    distinct?: FeatureToggleScalarFieldEnum | FeatureToggleScalarFieldEnum[]
  }

  /**
   * FeatureToggle create
   */
  export type FeatureToggleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureToggle.
     */
    data: XOR<FeatureToggleCreateInput, FeatureToggleUncheckedCreateInput>
  }

  /**
   * FeatureToggle createMany
   */
  export type FeatureToggleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureToggles.
     */
    data: FeatureToggleCreateManyInput | FeatureToggleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureToggle createManyAndReturn
   */
  export type FeatureToggleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureToggles.
     */
    data: FeatureToggleCreateManyInput | FeatureToggleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureToggle update
   */
  export type FeatureToggleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureToggle.
     */
    data: XOR<FeatureToggleUpdateInput, FeatureToggleUncheckedUpdateInput>
    /**
     * Choose, which FeatureToggle to update.
     */
    where: FeatureToggleWhereUniqueInput
  }

  /**
   * FeatureToggle updateMany
   */
  export type FeatureToggleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureToggles.
     */
    data: XOR<FeatureToggleUpdateManyMutationInput, FeatureToggleUncheckedUpdateManyInput>
    /**
     * Filter which FeatureToggles to update
     */
    where?: FeatureToggleWhereInput
    /**
     * Limit how many FeatureToggles to update.
     */
    limit?: number
  }

  /**
   * FeatureToggle updateManyAndReturn
   */
  export type FeatureToggleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * The data used to update FeatureToggles.
     */
    data: XOR<FeatureToggleUpdateManyMutationInput, FeatureToggleUncheckedUpdateManyInput>
    /**
     * Filter which FeatureToggles to update
     */
    where?: FeatureToggleWhereInput
    /**
     * Limit how many FeatureToggles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureToggle upsert
   */
  export type FeatureToggleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureToggle to update in case it exists.
     */
    where: FeatureToggleWhereUniqueInput
    /**
     * In case the FeatureToggle found by the `where` argument doesn't exist, create a new FeatureToggle with this data.
     */
    create: XOR<FeatureToggleCreateInput, FeatureToggleUncheckedCreateInput>
    /**
     * In case the FeatureToggle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureToggleUpdateInput, FeatureToggleUncheckedUpdateInput>
  }

  /**
   * FeatureToggle delete
   */
  export type FeatureToggleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
    /**
     * Filter which FeatureToggle to delete.
     */
    where: FeatureToggleWhereUniqueInput
  }

  /**
   * FeatureToggle deleteMany
   */
  export type FeatureToggleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureToggles to delete
     */
    where?: FeatureToggleWhereInput
    /**
     * Limit how many FeatureToggles to delete.
     */
    limit?: number
  }

  /**
   * FeatureToggle without action
   */
  export type FeatureToggleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureToggle
     */
    select?: FeatureToggleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureToggle
     */
    omit?: FeatureToggleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureToggleInclude<ExtArgs> | null
  }


  /**
   * Model MemberAccessOverride
   */

  export type AggregateMemberAccessOverride = {
    _count: MemberAccessOverrideCountAggregateOutputType | null
    _min: MemberAccessOverrideMinAggregateOutputType | null
    _max: MemberAccessOverrideMaxAggregateOutputType | null
  }

  export type MemberAccessOverrideMinAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    enabled: boolean | null
    reason: string | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type MemberAccessOverrideMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    enabled: boolean | null
    reason: string | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type MemberAccessOverrideCountAggregateOutputType = {
    id: number
    userId: number
    feature: number
    enabled: number
    permissions: number
    reason: number
    grantedById: number
    grantedAt: number
    _all: number
  }


  export type MemberAccessOverrideMinAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    reason?: true
    grantedById?: true
    grantedAt?: true
  }

  export type MemberAccessOverrideMaxAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    reason?: true
    grantedById?: true
    grantedAt?: true
  }

  export type MemberAccessOverrideCountAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    enabled?: true
    permissions?: true
    reason?: true
    grantedById?: true
    grantedAt?: true
    _all?: true
  }

  export type MemberAccessOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAccessOverride to aggregate.
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccessOverrides to fetch.
     */
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberAccessOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccessOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccessOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberAccessOverrides
    **/
    _count?: true | MemberAccessOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberAccessOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberAccessOverrideMaxAggregateInputType
  }

  export type GetMemberAccessOverrideAggregateType<T extends MemberAccessOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberAccessOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberAccessOverride[P]>
      : GetScalarType<T[P], AggregateMemberAccessOverride[P]>
  }




  export type MemberAccessOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAccessOverrideWhereInput
    orderBy?: MemberAccessOverrideOrderByWithAggregationInput | MemberAccessOverrideOrderByWithAggregationInput[]
    by: MemberAccessOverrideScalarFieldEnum[] | MemberAccessOverrideScalarFieldEnum
    having?: MemberAccessOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberAccessOverrideCountAggregateInputType | true
    _min?: MemberAccessOverrideMinAggregateInputType
    _max?: MemberAccessOverrideMaxAggregateInputType
  }

  export type MemberAccessOverrideGroupByOutputType = {
    id: string
    userId: string
    feature: string
    enabled: boolean
    permissions: string[]
    reason: string
    grantedById: string
    grantedAt: Date
    _count: MemberAccessOverrideCountAggregateOutputType | null
    _min: MemberAccessOverrideMinAggregateOutputType | null
    _max: MemberAccessOverrideMaxAggregateOutputType | null
  }

  type GetMemberAccessOverrideGroupByPayload<T extends MemberAccessOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberAccessOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberAccessOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberAccessOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], MemberAccessOverrideGroupByOutputType[P]>
        }
      >
    >


  export type MemberAccessOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    reason?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccessOverride"]>

  export type MemberAccessOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    reason?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccessOverride"]>

  export type MemberAccessOverrideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    reason?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAccessOverride"]>

  export type MemberAccessOverrideSelectScalar = {
    id?: boolean
    userId?: boolean
    feature?: boolean
    enabled?: boolean
    permissions?: boolean
    reason?: boolean
    grantedById?: boolean
    grantedAt?: boolean
  }

  export type MemberAccessOverrideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "feature" | "enabled" | "permissions" | "reason" | "grantedById" | "grantedAt", ExtArgs["result"]["memberAccessOverride"]>
  export type MemberAccessOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberAccessOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberAccessOverrideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberAccessOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberAccessOverride"
    objects: {
      grantedBy: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      feature: string
      enabled: boolean
      permissions: string[]
      reason: string
      grantedById: string
      grantedAt: Date
    }, ExtArgs["result"]["memberAccessOverride"]>
    composites: {}
  }

  type MemberAccessOverrideGetPayload<S extends boolean | null | undefined | MemberAccessOverrideDefaultArgs> = $Result.GetResult<Prisma.$MemberAccessOverridePayload, S>

  type MemberAccessOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberAccessOverrideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberAccessOverrideCountAggregateInputType | true
    }

  export interface MemberAccessOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberAccessOverride'], meta: { name: 'MemberAccessOverride' } }
    /**
     * Find zero or one MemberAccessOverride that matches the filter.
     * @param {MemberAccessOverrideFindUniqueArgs} args - Arguments to find a MemberAccessOverride
     * @example
     * // Get one MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberAccessOverrideFindUniqueArgs>(args: SelectSubset<T, MemberAccessOverrideFindUniqueArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberAccessOverride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberAccessOverrideFindUniqueOrThrowArgs} args - Arguments to find a MemberAccessOverride
     * @example
     * // Get one MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberAccessOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberAccessOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAccessOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideFindFirstArgs} args - Arguments to find a MemberAccessOverride
     * @example
     * // Get one MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberAccessOverrideFindFirstArgs>(args?: SelectSubset<T, MemberAccessOverrideFindFirstArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAccessOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideFindFirstOrThrowArgs} args - Arguments to find a MemberAccessOverride
     * @example
     * // Get one MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberAccessOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberAccessOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberAccessOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberAccessOverrides
     * const memberAccessOverrides = await prisma.memberAccessOverride.findMany()
     * 
     * // Get first 10 MemberAccessOverrides
     * const memberAccessOverrides = await prisma.memberAccessOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberAccessOverrideWithIdOnly = await prisma.memberAccessOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberAccessOverrideFindManyArgs>(args?: SelectSubset<T, MemberAccessOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberAccessOverride.
     * @param {MemberAccessOverrideCreateArgs} args - Arguments to create a MemberAccessOverride.
     * @example
     * // Create one MemberAccessOverride
     * const MemberAccessOverride = await prisma.memberAccessOverride.create({
     *   data: {
     *     // ... data to create a MemberAccessOverride
     *   }
     * })
     * 
     */
    create<T extends MemberAccessOverrideCreateArgs>(args: SelectSubset<T, MemberAccessOverrideCreateArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberAccessOverrides.
     * @param {MemberAccessOverrideCreateManyArgs} args - Arguments to create many MemberAccessOverrides.
     * @example
     * // Create many MemberAccessOverrides
     * const memberAccessOverride = await prisma.memberAccessOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberAccessOverrideCreateManyArgs>(args?: SelectSubset<T, MemberAccessOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberAccessOverrides and returns the data saved in the database.
     * @param {MemberAccessOverrideCreateManyAndReturnArgs} args - Arguments to create many MemberAccessOverrides.
     * @example
     * // Create many MemberAccessOverrides
     * const memberAccessOverride = await prisma.memberAccessOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberAccessOverrides and only return the `id`
     * const memberAccessOverrideWithIdOnly = await prisma.memberAccessOverride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberAccessOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberAccessOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberAccessOverride.
     * @param {MemberAccessOverrideDeleteArgs} args - Arguments to delete one MemberAccessOverride.
     * @example
     * // Delete one MemberAccessOverride
     * const MemberAccessOverride = await prisma.memberAccessOverride.delete({
     *   where: {
     *     // ... filter to delete one MemberAccessOverride
     *   }
     * })
     * 
     */
    delete<T extends MemberAccessOverrideDeleteArgs>(args: SelectSubset<T, MemberAccessOverrideDeleteArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberAccessOverride.
     * @param {MemberAccessOverrideUpdateArgs} args - Arguments to update one MemberAccessOverride.
     * @example
     * // Update one MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberAccessOverrideUpdateArgs>(args: SelectSubset<T, MemberAccessOverrideUpdateArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberAccessOverrides.
     * @param {MemberAccessOverrideDeleteManyArgs} args - Arguments to filter MemberAccessOverrides to delete.
     * @example
     * // Delete a few MemberAccessOverrides
     * const { count } = await prisma.memberAccessOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberAccessOverrideDeleteManyArgs>(args?: SelectSubset<T, MemberAccessOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAccessOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberAccessOverrides
     * const memberAccessOverride = await prisma.memberAccessOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberAccessOverrideUpdateManyArgs>(args: SelectSubset<T, MemberAccessOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAccessOverrides and returns the data updated in the database.
     * @param {MemberAccessOverrideUpdateManyAndReturnArgs} args - Arguments to update many MemberAccessOverrides.
     * @example
     * // Update many MemberAccessOverrides
     * const memberAccessOverride = await prisma.memberAccessOverride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberAccessOverrides and only return the `id`
     * const memberAccessOverrideWithIdOnly = await prisma.memberAccessOverride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberAccessOverrideUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberAccessOverrideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberAccessOverride.
     * @param {MemberAccessOverrideUpsertArgs} args - Arguments to update or create a MemberAccessOverride.
     * @example
     * // Update or create a MemberAccessOverride
     * const memberAccessOverride = await prisma.memberAccessOverride.upsert({
     *   create: {
     *     // ... data to create a MemberAccessOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberAccessOverride we want to update
     *   }
     * })
     */
    upsert<T extends MemberAccessOverrideUpsertArgs>(args: SelectSubset<T, MemberAccessOverrideUpsertArgs<ExtArgs>>): Prisma__MemberAccessOverrideClient<$Result.GetResult<Prisma.$MemberAccessOverridePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberAccessOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideCountArgs} args - Arguments to filter MemberAccessOverrides to count.
     * @example
     * // Count the number of MemberAccessOverrides
     * const count = await prisma.memberAccessOverride.count({
     *   where: {
     *     // ... the filter for the MemberAccessOverrides we want to count
     *   }
     * })
    **/
    count<T extends MemberAccessOverrideCountArgs>(
      args?: Subset<T, MemberAccessOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberAccessOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberAccessOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAccessOverrideAggregateArgs>(args: Subset<T, MemberAccessOverrideAggregateArgs>): Prisma.PrismaPromise<GetMemberAccessOverrideAggregateType<T>>

    /**
     * Group by MemberAccessOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAccessOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberAccessOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberAccessOverrideGroupByArgs['orderBy'] }
        : { orderBy?: MemberAccessOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberAccessOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberAccessOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberAccessOverride model
   */
  readonly fields: MemberAccessOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberAccessOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberAccessOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grantedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberAccessOverride model
   */
  interface MemberAccessOverrideFieldRefs {
    readonly id: FieldRef<"MemberAccessOverride", 'String'>
    readonly userId: FieldRef<"MemberAccessOverride", 'String'>
    readonly feature: FieldRef<"MemberAccessOverride", 'String'>
    readonly enabled: FieldRef<"MemberAccessOverride", 'Boolean'>
    readonly permissions: FieldRef<"MemberAccessOverride", 'String[]'>
    readonly reason: FieldRef<"MemberAccessOverride", 'String'>
    readonly grantedById: FieldRef<"MemberAccessOverride", 'String'>
    readonly grantedAt: FieldRef<"MemberAccessOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberAccessOverride findUnique
   */
  export type MemberAccessOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccessOverride to fetch.
     */
    where: MemberAccessOverrideWhereUniqueInput
  }

  /**
   * MemberAccessOverride findUniqueOrThrow
   */
  export type MemberAccessOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccessOverride to fetch.
     */
    where: MemberAccessOverrideWhereUniqueInput
  }

  /**
   * MemberAccessOverride findFirst
   */
  export type MemberAccessOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccessOverride to fetch.
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccessOverrides to fetch.
     */
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAccessOverrides.
     */
    cursor?: MemberAccessOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccessOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccessOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAccessOverrides.
     */
    distinct?: MemberAccessOverrideScalarFieldEnum | MemberAccessOverrideScalarFieldEnum[]
  }

  /**
   * MemberAccessOverride findFirstOrThrow
   */
  export type MemberAccessOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccessOverride to fetch.
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccessOverrides to fetch.
     */
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAccessOverrides.
     */
    cursor?: MemberAccessOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccessOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccessOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAccessOverrides.
     */
    distinct?: MemberAccessOverrideScalarFieldEnum | MemberAccessOverrideScalarFieldEnum[]
  }

  /**
   * MemberAccessOverride findMany
   */
  export type MemberAccessOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MemberAccessOverrides to fetch.
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAccessOverrides to fetch.
     */
    orderBy?: MemberAccessOverrideOrderByWithRelationInput | MemberAccessOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberAccessOverrides.
     */
    cursor?: MemberAccessOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAccessOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAccessOverrides.
     */
    skip?: number
    distinct?: MemberAccessOverrideScalarFieldEnum | MemberAccessOverrideScalarFieldEnum[]
  }

  /**
   * MemberAccessOverride create
   */
  export type MemberAccessOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberAccessOverride.
     */
    data: XOR<MemberAccessOverrideCreateInput, MemberAccessOverrideUncheckedCreateInput>
  }

  /**
   * MemberAccessOverride createMany
   */
  export type MemberAccessOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberAccessOverrides.
     */
    data: MemberAccessOverrideCreateManyInput | MemberAccessOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberAccessOverride createManyAndReturn
   */
  export type MemberAccessOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * The data used to create many MemberAccessOverrides.
     */
    data: MemberAccessOverrideCreateManyInput | MemberAccessOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAccessOverride update
   */
  export type MemberAccessOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberAccessOverride.
     */
    data: XOR<MemberAccessOverrideUpdateInput, MemberAccessOverrideUncheckedUpdateInput>
    /**
     * Choose, which MemberAccessOverride to update.
     */
    where: MemberAccessOverrideWhereUniqueInput
  }

  /**
   * MemberAccessOverride updateMany
   */
  export type MemberAccessOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberAccessOverrides.
     */
    data: XOR<MemberAccessOverrideUpdateManyMutationInput, MemberAccessOverrideUncheckedUpdateManyInput>
    /**
     * Filter which MemberAccessOverrides to update
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * Limit how many MemberAccessOverrides to update.
     */
    limit?: number
  }

  /**
   * MemberAccessOverride updateManyAndReturn
   */
  export type MemberAccessOverrideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * The data used to update MemberAccessOverrides.
     */
    data: XOR<MemberAccessOverrideUpdateManyMutationInput, MemberAccessOverrideUncheckedUpdateManyInput>
    /**
     * Filter which MemberAccessOverrides to update
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * Limit how many MemberAccessOverrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAccessOverride upsert
   */
  export type MemberAccessOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberAccessOverride to update in case it exists.
     */
    where: MemberAccessOverrideWhereUniqueInput
    /**
     * In case the MemberAccessOverride found by the `where` argument doesn't exist, create a new MemberAccessOverride with this data.
     */
    create: XOR<MemberAccessOverrideCreateInput, MemberAccessOverrideUncheckedCreateInput>
    /**
     * In case the MemberAccessOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberAccessOverrideUpdateInput, MemberAccessOverrideUncheckedUpdateInput>
  }

  /**
   * MemberAccessOverride delete
   */
  export type MemberAccessOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
    /**
     * Filter which MemberAccessOverride to delete.
     */
    where: MemberAccessOverrideWhereUniqueInput
  }

  /**
   * MemberAccessOverride deleteMany
   */
  export type MemberAccessOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAccessOverrides to delete
     */
    where?: MemberAccessOverrideWhereInput
    /**
     * Limit how many MemberAccessOverrides to delete.
     */
    limit?: number
  }

  /**
   * MemberAccessOverride without action
   */
  export type MemberAccessOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAccessOverride
     */
    select?: MemberAccessOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAccessOverride
     */
    omit?: MemberAccessOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAccessOverrideInclude<ExtArgs> | null
  }


  /**
   * Model InvitationTemplate
   */

  export type AggregateInvitationTemplate = {
    _count: InvitationTemplateCountAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  export type InvitationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    bodyMarkdown: string | null
    visibility: $Enums.Visibility | null
    createdAt: Date | null
  }

  export type InvitationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    bodyMarkdown: string | null
    visibility: $Enums.Visibility | null
    createdAt: Date | null
  }

  export type InvitationTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    bodyMarkdown: number
    visibility: number
    createdAt: number
    _all: number
  }


  export type InvitationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    bodyMarkdown?: true
    visibility?: true
    createdAt?: true
  }

  export type InvitationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    bodyMarkdown?: true
    visibility?: true
    createdAt?: true
  }

  export type InvitationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    bodyMarkdown?: true
    visibility?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplate to aggregate.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationTemplates
    **/
    _count?: true | InvitationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type GetInvitationTemplateAggregateType<T extends InvitationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationTemplate[P]>
      : GetScalarType<T[P], AggregateInvitationTemplate[P]>
  }




  export type InvitationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationTemplateWhereInput
    orderBy?: InvitationTemplateOrderByWithAggregationInput | InvitationTemplateOrderByWithAggregationInput[]
    by: InvitationTemplateScalarFieldEnum[] | InvitationTemplateScalarFieldEnum
    having?: InvitationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationTemplateCountAggregateInputType | true
    _min?: InvitationTemplateMinAggregateInputType
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type InvitationTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    bodyMarkdown: string
    visibility: $Enums.Visibility
    createdAt: Date
    _count: InvitationTemplateCountAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  type GetInvitationTemplateGroupByPayload<T extends InvitationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type InvitationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    bodyMarkdown?: boolean
    visibility?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    bodyMarkdown?: boolean
    visibility?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    bodyMarkdown?: boolean
    visibility?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    bodyMarkdown?: boolean
    visibility?: boolean
    createdAt?: boolean
  }

  export type InvitationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "bodyMarkdown" | "visibility" | "createdAt", ExtArgs["result"]["invitationTemplate"]>

  export type $InvitationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      bodyMarkdown: string
      visibility: $Enums.Visibility
      createdAt: Date
    }, ExtArgs["result"]["invitationTemplate"]>
    composites: {}
  }

  type InvitationTemplateGetPayload<S extends boolean | null | undefined | InvitationTemplateDefaultArgs> = $Result.GetResult<Prisma.$InvitationTemplatePayload, S>

  type InvitationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationTemplateCountAggregateInputType | true
    }

  export interface InvitationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationTemplate'], meta: { name: 'InvitationTemplate' } }
    /**
     * Find zero or one InvitationTemplate that matches the filter.
     * @param {InvitationTemplateFindUniqueArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationTemplateFindUniqueArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvitationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationTemplateFindUniqueOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationTemplateFindFirstArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvitationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany()
     * 
     * // Get first 10 InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationTemplateFindManyArgs>(args?: SelectSubset<T, InvitationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvitationTemplate.
     * @param {InvitationTemplateCreateArgs} args - Arguments to create a InvitationTemplate.
     * @example
     * // Create one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.create({
     *   data: {
     *     // ... data to create a InvitationTemplate
     *   }
     * })
     * 
     */
    create<T extends InvitationTemplateCreateArgs>(args: SelectSubset<T, InvitationTemplateCreateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvitationTemplates.
     * @param {InvitationTemplateCreateManyArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationTemplateCreateManyArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvitationTemplates and returns the data saved in the database.
     * @param {InvitationTemplateCreateManyAndReturnArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvitationTemplates and only return the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvitationTemplate.
     * @param {InvitationTemplateDeleteArgs} args - Arguments to delete one InvitationTemplate.
     * @example
     * // Delete one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.delete({
     *   where: {
     *     // ... filter to delete one InvitationTemplate
     *   }
     * })
     * 
     */
    delete<T extends InvitationTemplateDeleteArgs>(args: SelectSubset<T, InvitationTemplateDeleteArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvitationTemplate.
     * @param {InvitationTemplateUpdateArgs} args - Arguments to update one InvitationTemplate.
     * @example
     * // Update one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationTemplateUpdateArgs>(args: SelectSubset<T, InvitationTemplateUpdateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvitationTemplates.
     * @param {InvitationTemplateDeleteManyArgs} args - Arguments to filter InvitationTemplates to delete.
     * @example
     * // Delete a few InvitationTemplates
     * const { count } = await prisma.invitationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationTemplateDeleteManyArgs>(args?: SelectSubset<T, InvitationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationTemplateUpdateManyArgs>(args: SelectSubset<T, InvitationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationTemplates and returns the data updated in the database.
     * @param {InvitationTemplateUpdateManyAndReturnArgs} args - Arguments to update many InvitationTemplates.
     * @example
     * // Update many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvitationTemplates and only return the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvitationTemplate.
     * @param {InvitationTemplateUpsertArgs} args - Arguments to update or create a InvitationTemplate.
     * @example
     * // Update or create a InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.upsert({
     *   create: {
     *     // ... data to create a InvitationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends InvitationTemplateUpsertArgs>(args: SelectSubset<T, InvitationTemplateUpsertArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateCountArgs} args - Arguments to filter InvitationTemplates to count.
     * @example
     * // Count the number of InvitationTemplates
     * const count = await prisma.invitationTemplate.count({
     *   where: {
     *     // ... the filter for the InvitationTemplates we want to count
     *   }
     * })
    **/
    count<T extends InvitationTemplateCountArgs>(
      args?: Subset<T, InvitationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationTemplateAggregateArgs>(args: Subset<T, InvitationTemplateAggregateArgs>): Prisma.PrismaPromise<GetInvitationTemplateAggregateType<T>>

    /**
     * Group by InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: InvitationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationTemplate model
   */
  readonly fields: InvitationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationTemplate model
   */
  interface InvitationTemplateFieldRefs {
    readonly id: FieldRef<"InvitationTemplate", 'String'>
    readonly name: FieldRef<"InvitationTemplate", 'String'>
    readonly subject: FieldRef<"InvitationTemplate", 'String'>
    readonly bodyMarkdown: FieldRef<"InvitationTemplate", 'String'>
    readonly visibility: FieldRef<"InvitationTemplate", 'Visibility'>
    readonly createdAt: FieldRef<"InvitationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationTemplate findUnique
   */
  export type InvitationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findUniqueOrThrow
   */
  export type InvitationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findFirst
   */
  export type InvitationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findFirstOrThrow
   */
  export type InvitationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findMany
   */
  export type InvitationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which InvitationTemplates to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate create
   */
  export type InvitationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a InvitationTemplate.
     */
    data: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
  }

  /**
   * InvitationTemplate createMany
   */
  export type InvitationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationTemplate createManyAndReturn
   */
  export type InvitationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationTemplate update
   */
  export type InvitationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a InvitationTemplate.
     */
    data: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
    /**
     * Choose, which InvitationTemplate to update.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate updateMany
   */
  export type InvitationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationTemplates.
     */
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which InvitationTemplates to update
     */
    where?: InvitationTemplateWhereInput
    /**
     * Limit how many InvitationTemplates to update.
     */
    limit?: number
  }

  /**
   * InvitationTemplate updateManyAndReturn
   */
  export type InvitationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update InvitationTemplates.
     */
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which InvitationTemplates to update
     */
    where?: InvitationTemplateWhereInput
    /**
     * Limit how many InvitationTemplates to update.
     */
    limit?: number
  }

  /**
   * InvitationTemplate upsert
   */
  export type InvitationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the InvitationTemplate to update in case it exists.
     */
    where: InvitationTemplateWhereUniqueInput
    /**
     * In case the InvitationTemplate found by the `where` argument doesn't exist, create a new InvitationTemplate with this data.
     */
    create: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
    /**
     * In case the InvitationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
  }

  /**
   * InvitationTemplate delete
   */
  export type InvitationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Filter which InvitationTemplate to delete.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate deleteMany
   */
  export type InvitationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplates to delete
     */
    where?: InvitationTemplateWhereInput
    /**
     * Limit how many InvitationTemplates to delete.
     */
    limit?: number
  }

  /**
   * InvitationTemplate without action
   */
  export type InvitationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    role: $Enums.UserRole | null
    status: $Enums.InvitationStatus | null
    invitedById: string | null
    expiresAt: Date | null
    acceptedById: string | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    role: $Enums.UserRole | null
    status: $Enums.InvitationStatus | null
    invitedById: string | null
    expiresAt: Date | null
    acceptedById: string | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    code: number
    email: number
    role: number
    status: number
    invitedById: number
    grantedAccess: number
    expiresAt: number
    acceptedById: number
    acceptedAt: number
    createdAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    status?: true
    invitedById?: true
    expiresAt?: true
    acceptedById?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    status?: true
    invitedById?: true
    expiresAt?: true
    acceptedById?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    status?: true
    invitedById?: true
    grantedAccess?: true
    expiresAt?: true
    acceptedById?: true
    acceptedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    code: string
    email: string
    role: $Enums.UserRole
    status: $Enums.InvitationStatus
    invitedById: string
    grantedAccess: $Enums.FeatureAccessKey[]
    expiresAt: Date
    acceptedById: string | null
    acceptedAt: Date | null
    createdAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    invitedById?: boolean
    grantedAccess?: boolean
    expiresAt?: boolean
    acceptedById?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    invitedById?: boolean
    grantedAccess?: boolean
    expiresAt?: boolean
    acceptedById?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    invitedById?: boolean
    grantedAccess?: boolean
    expiresAt?: boolean
    acceptedById?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    invitedById?: boolean
    grantedAccess?: boolean
    expiresAt?: boolean
    acceptedById?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "email" | "role" | "status" | "invitedById" | "grantedAccess" | "expiresAt" | "acceptedById" | "acceptedAt" | "createdAt", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acceptedBy?: boolean | Invitation$acceptedByArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      acceptedBy: Prisma.$UserPayload<ExtArgs> | null
      invitedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      email: string
      role: $Enums.UserRole
      status: $Enums.InvitationStatus
      invitedById: string
      grantedAccess: $Enums.FeatureAccessKey[]
      expiresAt: Date
      acceptedById: string | null
      acceptedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acceptedBy<T extends Invitation$acceptedByArgs<ExtArgs> = {}>(args?: Subset<T, Invitation$acceptedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invitedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly code: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly role: FieldRef<"Invitation", 'UserRole'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly invitedById: FieldRef<"Invitation", 'String'>
    readonly grantedAccess: FieldRef<"Invitation", 'FeatureAccessKey[]'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly acceptedById: FieldRef<"Invitation", 'String'>
    readonly acceptedAt: FieldRef<"Invitation", 'DateTime'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation.acceptedBy
   */
  export type Invitation$acceptedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    estimatedDurationMinutes: number | null
    totalLessons: number | null
    recommendationScore: number | null
  }

  export type CourseSumAggregateOutputType = {
    estimatedDurationMinutes: number | null
    totalLessons: number | null
    recommendationScore: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    coverImage: string | null
    level: $Enums.CourseLevel | null
    status: $Enums.CourseStatus | null
    visibility: $Enums.Visibility | null
    estimatedDurationMinutes: number | null
    totalLessons: number | null
    releaseDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isFeatured: boolean | null
    recommendationScore: number | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    coverImage: string | null
    level: $Enums.CourseLevel | null
    status: $Enums.CourseStatus | null
    visibility: $Enums.Visibility | null
    estimatedDurationMinutes: number | null
    totalLessons: number | null
    releaseDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isFeatured: boolean | null
    recommendationScore: number | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    subtitle: number
    description: number
    coverImage: number
    level: number
    status: number
    visibility: number
    estimatedDurationMinutes: number
    totalLessons: number
    tags: number
    releaseDate: number
    createdById: number
    createdAt: number
    updatedAt: number
    isFeatured: number
    recommendationScore: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    estimatedDurationMinutes?: true
    totalLessons?: true
    recommendationScore?: true
  }

  export type CourseSumAggregateInputType = {
    estimatedDurationMinutes?: true
    totalLessons?: true
    recommendationScore?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    coverImage?: true
    level?: true
    status?: true
    visibility?: true
    estimatedDurationMinutes?: true
    totalLessons?: true
    releaseDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    isFeatured?: true
    recommendationScore?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    coverImage?: true
    level?: true
    status?: true
    visibility?: true
    estimatedDurationMinutes?: true
    totalLessons?: true
    releaseDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    isFeatured?: true
    recommendationScore?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    coverImage?: true
    level?: true
    status?: true
    visibility?: true
    estimatedDurationMinutes?: true
    totalLessons?: true
    tags?: true
    releaseDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    isFeatured?: true
    recommendationScore?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes: number
    totalLessons: number
    tags: string[]
    releaseDate: Date | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    isFeatured: boolean
    recommendationScore: number
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    coverImage?: boolean
    level?: boolean
    status?: boolean
    visibility?: boolean
    estimatedDurationMinutes?: boolean
    totalLessons?: boolean
    tags?: boolean
    releaseDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFeatured?: boolean
    recommendationScore?: boolean
    modules?: boolean | Course$modulesArgs<ExtArgs>
    progresses?: boolean | Course$progressesArgs<ExtArgs>
    recommendations?: boolean | Course$recommendationsArgs<ExtArgs>
    author?: boolean | Course$authorArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    coverImage?: boolean
    level?: boolean
    status?: boolean
    visibility?: boolean
    estimatedDurationMinutes?: boolean
    totalLessons?: boolean
    tags?: boolean
    releaseDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFeatured?: boolean
    recommendationScore?: boolean
    author?: boolean | Course$authorArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    coverImage?: boolean
    level?: boolean
    status?: boolean
    visibility?: boolean
    estimatedDurationMinutes?: boolean
    totalLessons?: boolean
    tags?: boolean
    releaseDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFeatured?: boolean
    recommendationScore?: boolean
    author?: boolean | Course$authorArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    coverImage?: boolean
    level?: boolean
    status?: boolean
    visibility?: boolean
    estimatedDurationMinutes?: boolean
    totalLessons?: boolean
    tags?: boolean
    releaseDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFeatured?: boolean
    recommendationScore?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "subtitle" | "description" | "coverImage" | "level" | "status" | "visibility" | "estimatedDurationMinutes" | "totalLessons" | "tags" | "releaseDate" | "createdById" | "createdAt" | "updatedAt" | "isFeatured" | "recommendationScore", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | Course$modulesArgs<ExtArgs>
    progresses?: boolean | Course$progressesArgs<ExtArgs>
    recommendations?: boolean | Course$recommendationsArgs<ExtArgs>
    author?: boolean | Course$authorArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Course$authorArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Course$authorArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      modules: Prisma.$CourseModulePayload<ExtArgs>[]
      progresses: Prisma.$CourseProgressPayload<ExtArgs>[]
      recommendations: Prisma.$CourseRecommendationPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      subtitle: string
      description: string
      coverImage: string | null
      level: $Enums.CourseLevel
      status: $Enums.CourseStatus
      visibility: $Enums.Visibility
      estimatedDurationMinutes: number
      totalLessons: number
      tags: string[]
      releaseDate: Date | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
      isFeatured: boolean
      recommendationScore: number
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progresses<T extends Course$progressesArgs<ExtArgs> = {}>(args?: Subset<T, Course$progressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recommendations<T extends Course$recommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Course$recommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends Course$authorArgs<ExtArgs> = {}>(args?: Subset<T, Course$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly subtitle: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly coverImage: FieldRef<"Course", 'String'>
    readonly level: FieldRef<"Course", 'CourseLevel'>
    readonly status: FieldRef<"Course", 'CourseStatus'>
    readonly visibility: FieldRef<"Course", 'Visibility'>
    readonly estimatedDurationMinutes: FieldRef<"Course", 'Int'>
    readonly totalLessons: FieldRef<"Course", 'Int'>
    readonly tags: FieldRef<"Course", 'String[]'>
    readonly releaseDate: FieldRef<"Course", 'DateTime'>
    readonly createdById: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly isFeatured: FieldRef<"Course", 'Boolean'>
    readonly recommendationScore: FieldRef<"Course", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * Course.progresses
   */
  export type Course$progressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    cursor?: CourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * Course.recommendations
   */
  export type Course$recommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    where?: CourseRecommendationWhereInput
    orderBy?: CourseRecommendationOrderByWithRelationInput | CourseRecommendationOrderByWithRelationInput[]
    cursor?: CourseRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseRecommendationScalarFieldEnum | CourseRecommendationScalarFieldEnum[]
  }

  /**
   * Course.author
   */
  export type Course$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseModule
   */

  export type AggregateCourseModule = {
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  export type CourseModuleAvgAggregateOutputType = {
    order: number | null
    durationMinutes: number | null
    dripDaysAfter: number | null
  }

  export type CourseModuleSumAggregateOutputType = {
    order: number | null
    durationMinutes: number | null
    dripDaysAfter: number | null
  }

  export type CourseModuleMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    order: number | null
    title: string | null
    description: string | null
    durationMinutes: number | null
    dripDaysAfter: number | null
    dripReleaseAt: Date | null
    dripAfterModuleId: string | null
  }

  export type CourseModuleMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    order: number | null
    title: string | null
    description: string | null
    durationMinutes: number | null
    dripDaysAfter: number | null
    dripReleaseAt: Date | null
    dripAfterModuleId: string | null
  }

  export type CourseModuleCountAggregateOutputType = {
    id: number
    courseId: number
    order: number
    title: number
    description: number
    durationMinutes: number
    dripDaysAfter: number
    dripReleaseAt: number
    dripAfterModuleId: number
    _all: number
  }


  export type CourseModuleAvgAggregateInputType = {
    order?: true
    durationMinutes?: true
    dripDaysAfter?: true
  }

  export type CourseModuleSumAggregateInputType = {
    order?: true
    durationMinutes?: true
    dripDaysAfter?: true
  }

  export type CourseModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    durationMinutes?: true
    dripDaysAfter?: true
    dripReleaseAt?: true
    dripAfterModuleId?: true
  }

  export type CourseModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    durationMinutes?: true
    dripDaysAfter?: true
    dripReleaseAt?: true
    dripAfterModuleId?: true
  }

  export type CourseModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    durationMinutes?: true
    dripDaysAfter?: true
    dripReleaseAt?: true
    dripAfterModuleId?: true
    _all?: true
  }

  export type CourseModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModule to aggregate.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseModules
    **/
    _count?: true | CourseModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseModuleMaxAggregateInputType
  }

  export type GetCourseModuleAggregateType<T extends CourseModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseModule[P]>
      : GetScalarType<T[P], AggregateCourseModule[P]>
  }




  export type CourseModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithAggregationInput | CourseModuleOrderByWithAggregationInput[]
    by: CourseModuleScalarFieldEnum[] | CourseModuleScalarFieldEnum
    having?: CourseModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseModuleCountAggregateInputType | true
    _avg?: CourseModuleAvgAggregateInputType
    _sum?: CourseModuleSumAggregateInputType
    _min?: CourseModuleMinAggregateInputType
    _max?: CourseModuleMaxAggregateInputType
  }

  export type CourseModuleGroupByOutputType = {
    id: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter: number | null
    dripReleaseAt: Date | null
    dripAfterModuleId: string | null
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  type GetCourseModuleGroupByPayload<T extends CourseModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
        }
      >
    >


  export type CourseModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    dripDaysAfter?: boolean
    dripReleaseAt?: boolean
    dripAfterModuleId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
    dependentModules?: boolean | CourseModule$dependentModulesArgs<ExtArgs>
    lessons?: boolean | CourseModule$lessonsArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    dripDaysAfter?: boolean
    dripReleaseAt?: boolean
    dripAfterModuleId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    dripDaysAfter?: boolean
    dripReleaseAt?: boolean
    dripAfterModuleId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    dripDaysAfter?: boolean
    dripReleaseAt?: boolean
    dripAfterModuleId?: boolean
  }

  export type CourseModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "order" | "title" | "description" | "durationMinutes" | "dripDaysAfter" | "dripReleaseAt" | "dripAfterModuleId", ExtArgs["result"]["courseModule"]>
  export type CourseModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
    dependentModules?: boolean | CourseModule$dependentModulesArgs<ExtArgs>
    lessons?: boolean | CourseModule$lessonsArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
  }
  export type CourseModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    dripAfterModule?: boolean | CourseModule$dripAfterModuleArgs<ExtArgs>
  }

  export type $CourseModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseModule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      dripAfterModule: Prisma.$CourseModulePayload<ExtArgs> | null
      dependentModules: Prisma.$CourseModulePayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      order: number
      title: string
      description: string
      durationMinutes: number
      dripDaysAfter: number | null
      dripReleaseAt: Date | null
      dripAfterModuleId: string | null
    }, ExtArgs["result"]["courseModule"]>
    composites: {}
  }

  type CourseModuleGetPayload<S extends boolean | null | undefined | CourseModuleDefaultArgs> = $Result.GetResult<Prisma.$CourseModulePayload, S>

  type CourseModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseModuleCountAggregateInputType | true
    }

  export interface CourseModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseModule'], meta: { name: 'CourseModule' } }
    /**
     * Find zero or one CourseModule that matches the filter.
     * @param {CourseModuleFindUniqueArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseModuleFindUniqueArgs>(args: SelectSubset<T, CourseModuleFindUniqueArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseModuleFindUniqueOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseModuleFindFirstArgs>(args?: SelectSubset<T, CourseModuleFindFirstArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseModules
     * const courseModules = await prisma.courseModule.findMany()
     * 
     * // Get first 10 CourseModules
     * const courseModules = await prisma.courseModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseModuleFindManyArgs>(args?: SelectSubset<T, CourseModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseModule.
     * @param {CourseModuleCreateArgs} args - Arguments to create a CourseModule.
     * @example
     * // Create one CourseModule
     * const CourseModule = await prisma.courseModule.create({
     *   data: {
     *     // ... data to create a CourseModule
     *   }
     * })
     * 
     */
    create<T extends CourseModuleCreateArgs>(args: SelectSubset<T, CourseModuleCreateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseModules.
     * @param {CourseModuleCreateManyArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseModuleCreateManyArgs>(args?: SelectSubset<T, CourseModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseModules and returns the data saved in the database.
     * @param {CourseModuleCreateManyAndReturnArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseModule.
     * @param {CourseModuleDeleteArgs} args - Arguments to delete one CourseModule.
     * @example
     * // Delete one CourseModule
     * const CourseModule = await prisma.courseModule.delete({
     *   where: {
     *     // ... filter to delete one CourseModule
     *   }
     * })
     * 
     */
    delete<T extends CourseModuleDeleteArgs>(args: SelectSubset<T, CourseModuleDeleteArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseModule.
     * @param {CourseModuleUpdateArgs} args - Arguments to update one CourseModule.
     * @example
     * // Update one CourseModule
     * const courseModule = await prisma.courseModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseModuleUpdateArgs>(args: SelectSubset<T, CourseModuleUpdateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseModules.
     * @param {CourseModuleDeleteManyArgs} args - Arguments to filter CourseModules to delete.
     * @example
     * // Delete a few CourseModules
     * const { count } = await prisma.courseModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseModuleDeleteManyArgs>(args?: SelectSubset<T, CourseModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseModuleUpdateManyArgs>(args: SelectSubset<T, CourseModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules and returns the data updated in the database.
     * @param {CourseModuleUpdateManyAndReturnArgs} args - Arguments to update many CourseModules.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseModule.
     * @param {CourseModuleUpsertArgs} args - Arguments to update or create a CourseModule.
     * @example
     * // Update or create a CourseModule
     * const courseModule = await prisma.courseModule.upsert({
     *   create: {
     *     // ... data to create a CourseModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseModule we want to update
     *   }
     * })
     */
    upsert<T extends CourseModuleUpsertArgs>(args: SelectSubset<T, CourseModuleUpsertArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleCountArgs} args - Arguments to filter CourseModules to count.
     * @example
     * // Count the number of CourseModules
     * const count = await prisma.courseModule.count({
     *   where: {
     *     // ... the filter for the CourseModules we want to count
     *   }
     * })
    **/
    count<T extends CourseModuleCountArgs>(
      args?: Subset<T, CourseModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseModuleAggregateArgs>(args: Subset<T, CourseModuleAggregateArgs>): Prisma.PrismaPromise<GetCourseModuleAggregateType<T>>

    /**
     * Group by CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseModuleGroupByArgs['orderBy'] }
        : { orderBy?: CourseModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseModule model
   */
  readonly fields: CourseModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dripAfterModule<T extends CourseModule$dripAfterModuleArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$dripAfterModuleArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dependentModules<T extends CourseModule$dependentModulesArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$dependentModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends CourseModule$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseModule model
   */
  interface CourseModuleFieldRefs {
    readonly id: FieldRef<"CourseModule", 'String'>
    readonly courseId: FieldRef<"CourseModule", 'String'>
    readonly order: FieldRef<"CourseModule", 'Int'>
    readonly title: FieldRef<"CourseModule", 'String'>
    readonly description: FieldRef<"CourseModule", 'String'>
    readonly durationMinutes: FieldRef<"CourseModule", 'Int'>
    readonly dripDaysAfter: FieldRef<"CourseModule", 'Int'>
    readonly dripReleaseAt: FieldRef<"CourseModule", 'DateTime'>
    readonly dripAfterModuleId: FieldRef<"CourseModule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseModule findUnique
   */
  export type CourseModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findUniqueOrThrow
   */
  export type CourseModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findFirst
   */
  export type CourseModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findFirstOrThrow
   */
  export type CourseModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findMany
   */
  export type CourseModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModules to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule create
   */
  export type CourseModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseModule.
     */
    data: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
  }

  /**
   * CourseModule createMany
   */
  export type CourseModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseModule createManyAndReturn
   */
  export type CourseModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule update
   */
  export type CourseModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseModule.
     */
    data: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
    /**
     * Choose, which CourseModule to update.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule updateMany
   */
  export type CourseModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
  }

  /**
   * CourseModule updateManyAndReturn
   */
  export type CourseModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule upsert
   */
  export type CourseModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseModule to update in case it exists.
     */
    where: CourseModuleWhereUniqueInput
    /**
     * In case the CourseModule found by the `where` argument doesn't exist, create a new CourseModule with this data.
     */
    create: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
    /**
     * In case the CourseModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
  }

  /**
   * CourseModule delete
   */
  export type CourseModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter which CourseModule to delete.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule deleteMany
   */
  export type CourseModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModules to delete
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to delete.
     */
    limit?: number
  }

  /**
   * CourseModule.dripAfterModule
   */
  export type CourseModule$dripAfterModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
  }

  /**
   * CourseModule.dependentModules
   */
  export type CourseModule$dependentModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule.lessons
   */
  export type CourseModule$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * CourseModule without action
   */
  export type CourseModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    order: number | null
    durationMinutes: number | null
  }

  export type LessonSumAggregateOutputType = {
    order: number | null
    durationMinutes: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    order: number | null
    title: string | null
    summary: string | null
    type: $Enums.LessonType | null
    durationMinutes: number | null
    isPreview: boolean | null
    releaseAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    order: number | null
    title: string | null
    summary: string | null
    type: $Enums.LessonType | null
    durationMinutes: number | null
    isPreview: boolean | null
    releaseAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    moduleId: number
    order: number
    title: number
    summary: number
    type: number
    content: number
    durationMinutes: number
    isPreview: number
    releaseAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    order?: true
    durationMinutes?: true
  }

  export type LessonSumAggregateInputType = {
    order?: true
    durationMinutes?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    moduleId?: true
    order?: true
    title?: true
    summary?: true
    type?: true
    durationMinutes?: true
    isPreview?: true
    releaseAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    moduleId?: true
    order?: true
    title?: true
    summary?: true
    type?: true
    durationMinutes?: true
    isPreview?: true
    releaseAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    moduleId?: true
    order?: true
    title?: true
    summary?: true
    type?: true
    content?: true
    durationMinutes?: true
    isPreview?: true
    releaseAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonValue
    durationMinutes: number
    isPreview: boolean
    releaseAt: Date | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    order?: boolean
    title?: boolean
    summary?: boolean
    type?: boolean
    content?: boolean
    durationMinutes?: boolean
    isPreview?: boolean
    releaseAt?: boolean
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    progressAggregates?: boolean | Lesson$progressAggregatesArgs<ExtArgs>
    progressEvents?: boolean | Lesson$progressEventsArgs<ExtArgs>
    ratings?: boolean | Lesson$ratingsArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    order?: boolean
    title?: boolean
    summary?: boolean
    type?: boolean
    content?: boolean
    durationMinutes?: boolean
    isPreview?: boolean
    releaseAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    order?: boolean
    title?: boolean
    summary?: boolean
    type?: boolean
    content?: boolean
    durationMinutes?: boolean
    isPreview?: boolean
    releaseAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    moduleId?: boolean
    order?: boolean
    title?: boolean
    summary?: boolean
    type?: boolean
    content?: boolean
    durationMinutes?: boolean
    isPreview?: boolean
    releaseAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "order" | "title" | "summary" | "type" | "content" | "durationMinutes" | "isPreview" | "releaseAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    progressAggregates?: boolean | Lesson$progressAggregatesArgs<ExtArgs>
    progressEvents?: boolean | Lesson$progressEventsArgs<ExtArgs>
    ratings?: boolean | Lesson$ratingsArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      comments: Prisma.$LessonCommentPayload<ExtArgs>[]
      progressAggregates: Prisma.$LessonProgressAggregatePayload<ExtArgs>[]
      progressEvents: Prisma.$LessonProgressEventPayload<ExtArgs>[]
      ratings: Prisma.$LessonRatingPayload<ExtArgs>[]
      module: Prisma.$CourseModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      order: number
      title: string
      summary: string
      type: $Enums.LessonType
      content: Prisma.JsonValue
      durationMinutes: number
      isPreview: boolean
      releaseAt: Date | null
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Lesson$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressAggregates<T extends Lesson$progressAggregatesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressAggregatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressEvents<T extends Lesson$progressEventsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Lesson$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly moduleId: FieldRef<"Lesson", 'String'>
    readonly order: FieldRef<"Lesson", 'Int'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly summary: FieldRef<"Lesson", 'String'>
    readonly type: FieldRef<"Lesson", 'LessonType'>
    readonly content: FieldRef<"Lesson", 'Json'>
    readonly durationMinutes: FieldRef<"Lesson", 'Int'>
    readonly isPreview: FieldRef<"Lesson", 'Boolean'>
    readonly releaseAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.comments
   */
  export type Lesson$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * Lesson.progressAggregates
   */
  export type Lesson$progressAggregatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    where?: LessonProgressAggregateWhereInput
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    cursor?: LessonProgressAggregateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressAggregateScalarFieldEnum | LessonProgressAggregateScalarFieldEnum[]
  }

  /**
   * Lesson.progressEvents
   */
  export type Lesson$progressEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    where?: LessonProgressEventWhereInput
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    cursor?: LessonProgressEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressEventScalarFieldEnum | LessonProgressEventScalarFieldEnum[]
  }

  /**
   * Lesson.ratings
   */
  export type Lesson$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    where?: LessonRatingWhereInput
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    cursor?: LessonRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonRatingScalarFieldEnum | LessonRatingScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model CourseProgress
   */

  export type AggregateCourseProgress = {
    _count: CourseProgressCountAggregateOutputType | null
    _avg: CourseProgressAvgAggregateOutputType | null
    _sum: CourseProgressSumAggregateOutputType | null
    _min: CourseProgressMinAggregateOutputType | null
    _max: CourseProgressMaxAggregateOutputType | null
  }

  export type CourseProgressAvgAggregateOutputType = {
    percentage: number | null
  }

  export type CourseProgressSumAggregateOutputType = {
    percentage: number | null
  }

  export type CourseProgressMinAggregateOutputType = {
    courseId: string | null
    userId: string | null
    percentage: number | null
    lastLessonId: string | null
    updatedAt: Date | null
  }

  export type CourseProgressMaxAggregateOutputType = {
    courseId: string | null
    userId: string | null
    percentage: number | null
    lastLessonId: string | null
    updatedAt: Date | null
  }

  export type CourseProgressCountAggregateOutputType = {
    courseId: number
    userId: number
    completedLessonIds: number
    percentage: number
    lastLessonId: number
    updatedAt: number
    _all: number
  }


  export type CourseProgressAvgAggregateInputType = {
    percentage?: true
  }

  export type CourseProgressSumAggregateInputType = {
    percentage?: true
  }

  export type CourseProgressMinAggregateInputType = {
    courseId?: true
    userId?: true
    percentage?: true
    lastLessonId?: true
    updatedAt?: true
  }

  export type CourseProgressMaxAggregateInputType = {
    courseId?: true
    userId?: true
    percentage?: true
    lastLessonId?: true
    updatedAt?: true
  }

  export type CourseProgressCountAggregateInputType = {
    courseId?: true
    userId?: true
    completedLessonIds?: true
    percentage?: true
    lastLessonId?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProgress to aggregate.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseProgresses
    **/
    _count?: true | CourseProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseProgressMaxAggregateInputType
  }

  export type GetCourseProgressAggregateType<T extends CourseProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseProgress[P]>
      : GetScalarType<T[P], AggregateCourseProgress[P]>
  }




  export type CourseProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithAggregationInput | CourseProgressOrderByWithAggregationInput[]
    by: CourseProgressScalarFieldEnum[] | CourseProgressScalarFieldEnum
    having?: CourseProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseProgressCountAggregateInputType | true
    _avg?: CourseProgressAvgAggregateInputType
    _sum?: CourseProgressSumAggregateInputType
    _min?: CourseProgressMinAggregateInputType
    _max?: CourseProgressMaxAggregateInputType
  }

  export type CourseProgressGroupByOutputType = {
    courseId: string
    userId: string
    completedLessonIds: string[]
    percentage: number
    lastLessonId: string | null
    updatedAt: Date
    _count: CourseProgressCountAggregateOutputType | null
    _avg: CourseProgressAvgAggregateOutputType | null
    _sum: CourseProgressSumAggregateOutputType | null
    _min: CourseProgressMinAggregateOutputType | null
    _max: CourseProgressMaxAggregateOutputType | null
  }

  type GetCourseProgressGroupByPayload<T extends CourseProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseProgressGroupByOutputType[P]>
            : GetScalarType<T[P], CourseProgressGroupByOutputType[P]>
        }
      >
    >


  export type CourseProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    userId?: boolean
    completedLessonIds?: boolean
    percentage?: boolean
    lastLessonId?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProgress"]>

  export type CourseProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    userId?: boolean
    completedLessonIds?: boolean
    percentage?: boolean
    lastLessonId?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProgress"]>

  export type CourseProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    userId?: boolean
    completedLessonIds?: boolean
    percentage?: boolean
    lastLessonId?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProgress"]>

  export type CourseProgressSelectScalar = {
    courseId?: boolean
    userId?: boolean
    completedLessonIds?: boolean
    percentage?: boolean
    lastLessonId?: boolean
    updatedAt?: boolean
  }

  export type CourseProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "userId" | "completedLessonIds" | "percentage" | "lastLessonId" | "updatedAt", ExtArgs["result"]["courseProgress"]>
  export type CourseProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CourseProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseProgress"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      userId: string
      completedLessonIds: string[]
      percentage: number
      lastLessonId: string | null
      updatedAt: Date
    }, ExtArgs["result"]["courseProgress"]>
    composites: {}
  }

  type CourseProgressGetPayload<S extends boolean | null | undefined | CourseProgressDefaultArgs> = $Result.GetResult<Prisma.$CourseProgressPayload, S>

  type CourseProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseProgressCountAggregateInputType | true
    }

  export interface CourseProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseProgress'], meta: { name: 'CourseProgress' } }
    /**
     * Find zero or one CourseProgress that matches the filter.
     * @param {CourseProgressFindUniqueArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseProgressFindUniqueArgs>(args: SelectSubset<T, CourseProgressFindUniqueArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseProgressFindUniqueOrThrowArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindFirstArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseProgressFindFirstArgs>(args?: SelectSubset<T, CourseProgressFindFirstArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindFirstOrThrowArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseProgresses
     * const courseProgresses = await prisma.courseProgress.findMany()
     * 
     * // Get first 10 CourseProgresses
     * const courseProgresses = await prisma.courseProgress.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseProgressWithCourseIdOnly = await prisma.courseProgress.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseProgressFindManyArgs>(args?: SelectSubset<T, CourseProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseProgress.
     * @param {CourseProgressCreateArgs} args - Arguments to create a CourseProgress.
     * @example
     * // Create one CourseProgress
     * const CourseProgress = await prisma.courseProgress.create({
     *   data: {
     *     // ... data to create a CourseProgress
     *   }
     * })
     * 
     */
    create<T extends CourseProgressCreateArgs>(args: SelectSubset<T, CourseProgressCreateArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseProgresses.
     * @param {CourseProgressCreateManyArgs} args - Arguments to create many CourseProgresses.
     * @example
     * // Create many CourseProgresses
     * const courseProgress = await prisma.courseProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseProgressCreateManyArgs>(args?: SelectSubset<T, CourseProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseProgresses and returns the data saved in the database.
     * @param {CourseProgressCreateManyAndReturnArgs} args - Arguments to create many CourseProgresses.
     * @example
     * // Create many CourseProgresses
     * const courseProgress = await prisma.courseProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseProgresses and only return the `courseId`
     * const courseProgressWithCourseIdOnly = await prisma.courseProgress.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseProgress.
     * @param {CourseProgressDeleteArgs} args - Arguments to delete one CourseProgress.
     * @example
     * // Delete one CourseProgress
     * const CourseProgress = await prisma.courseProgress.delete({
     *   where: {
     *     // ... filter to delete one CourseProgress
     *   }
     * })
     * 
     */
    delete<T extends CourseProgressDeleteArgs>(args: SelectSubset<T, CourseProgressDeleteArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseProgress.
     * @param {CourseProgressUpdateArgs} args - Arguments to update one CourseProgress.
     * @example
     * // Update one CourseProgress
     * const courseProgress = await prisma.courseProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseProgressUpdateArgs>(args: SelectSubset<T, CourseProgressUpdateArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseProgresses.
     * @param {CourseProgressDeleteManyArgs} args - Arguments to filter CourseProgresses to delete.
     * @example
     * // Delete a few CourseProgresses
     * const { count } = await prisma.courseProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseProgressDeleteManyArgs>(args?: SelectSubset<T, CourseProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseProgresses
     * const courseProgress = await prisma.courseProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseProgressUpdateManyArgs>(args: SelectSubset<T, CourseProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseProgresses and returns the data updated in the database.
     * @param {CourseProgressUpdateManyAndReturnArgs} args - Arguments to update many CourseProgresses.
     * @example
     * // Update many CourseProgresses
     * const courseProgress = await prisma.courseProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseProgresses and only return the `courseId`
     * const courseProgressWithCourseIdOnly = await prisma.courseProgress.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseProgress.
     * @param {CourseProgressUpsertArgs} args - Arguments to update or create a CourseProgress.
     * @example
     * // Update or create a CourseProgress
     * const courseProgress = await prisma.courseProgress.upsert({
     *   create: {
     *     // ... data to create a CourseProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseProgress we want to update
     *   }
     * })
     */
    upsert<T extends CourseProgressUpsertArgs>(args: SelectSubset<T, CourseProgressUpsertArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressCountArgs} args - Arguments to filter CourseProgresses to count.
     * @example
     * // Count the number of CourseProgresses
     * const count = await prisma.courseProgress.count({
     *   where: {
     *     // ... the filter for the CourseProgresses we want to count
     *   }
     * })
    **/
    count<T extends CourseProgressCountArgs>(
      args?: Subset<T, CourseProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseProgressAggregateArgs>(args: Subset<T, CourseProgressAggregateArgs>): Prisma.PrismaPromise<GetCourseProgressAggregateType<T>>

    /**
     * Group by CourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseProgressGroupByArgs['orderBy'] }
        : { orderBy?: CourseProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseProgress model
   */
  readonly fields: CourseProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseProgress model
   */
  interface CourseProgressFieldRefs {
    readonly courseId: FieldRef<"CourseProgress", 'String'>
    readonly userId: FieldRef<"CourseProgress", 'String'>
    readonly completedLessonIds: FieldRef<"CourseProgress", 'String[]'>
    readonly percentage: FieldRef<"CourseProgress", 'Float'>
    readonly lastLessonId: FieldRef<"CourseProgress", 'String'>
    readonly updatedAt: FieldRef<"CourseProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseProgress findUnique
   */
  export type CourseProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress findUniqueOrThrow
   */
  export type CourseProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress findFirst
   */
  export type CourseProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProgresses.
     */
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress findFirstOrThrow
   */
  export type CourseProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProgresses.
     */
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress findMany
   */
  export type CourseProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgresses to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress create
   */
  export type CourseProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseProgress.
     */
    data: XOR<CourseProgressCreateInput, CourseProgressUncheckedCreateInput>
  }

  /**
   * CourseProgress createMany
   */
  export type CourseProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseProgresses.
     */
    data: CourseProgressCreateManyInput | CourseProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseProgress createManyAndReturn
   */
  export type CourseProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * The data used to create many CourseProgresses.
     */
    data: CourseProgressCreateManyInput | CourseProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseProgress update
   */
  export type CourseProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseProgress.
     */
    data: XOR<CourseProgressUpdateInput, CourseProgressUncheckedUpdateInput>
    /**
     * Choose, which CourseProgress to update.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress updateMany
   */
  export type CourseProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseProgresses.
     */
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which CourseProgresses to update
     */
    where?: CourseProgressWhereInput
    /**
     * Limit how many CourseProgresses to update.
     */
    limit?: number
  }

  /**
   * CourseProgress updateManyAndReturn
   */
  export type CourseProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * The data used to update CourseProgresses.
     */
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which CourseProgresses to update
     */
    where?: CourseProgressWhereInput
    /**
     * Limit how many CourseProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseProgress upsert
   */
  export type CourseProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseProgress to update in case it exists.
     */
    where: CourseProgressWhereUniqueInput
    /**
     * In case the CourseProgress found by the `where` argument doesn't exist, create a new CourseProgress with this data.
     */
    create: XOR<CourseProgressCreateInput, CourseProgressUncheckedCreateInput>
    /**
     * In case the CourseProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseProgressUpdateInput, CourseProgressUncheckedUpdateInput>
  }

  /**
   * CourseProgress delete
   */
  export type CourseProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter which CourseProgress to delete.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress deleteMany
   */
  export type CourseProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProgresses to delete
     */
    where?: CourseProgressWhereInput
    /**
     * Limit how many CourseProgresses to delete.
     */
    limit?: number
  }

  /**
   * CourseProgress without action
   */
  export type CourseProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseProgress
     */
    omit?: CourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
  }


  /**
   * Model LessonComment
   */

  export type AggregateLessonComment = {
    _count: LessonCommentCountAggregateOutputType | null
    _min: LessonCommentMinAggregateOutputType | null
    _max: LessonCommentMaxAggregateOutputType | null
  }

  export type LessonCommentMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pendingModeration: boolean | null
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus | null
  }

  export type LessonCommentMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pendingModeration: boolean | null
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus | null
  }

  export type LessonCommentCountAggregateOutputType = {
    id: number
    lessonId: number
    userId: number
    body: number
    createdAt: number
    updatedAt: number
    pendingModeration: number
    moderatedAt: number
    moderatedById: number
    moderationStatus: number
    _all: number
  }


  export type LessonCommentMinAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    pendingModeration?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
  }

  export type LessonCommentMaxAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    pendingModeration?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
  }

  export type LessonCommentCountAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    pendingModeration?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
    _all?: true
  }

  export type LessonCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonComment to aggregate.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonComments
    **/
    _count?: true | LessonCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonCommentMaxAggregateInputType
  }

  export type GetLessonCommentAggregateType<T extends LessonCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonComment[P]>
      : GetScalarType<T[P], AggregateLessonComment[P]>
  }




  export type LessonCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithAggregationInput | LessonCommentOrderByWithAggregationInput[]
    by: LessonCommentScalarFieldEnum[] | LessonCommentScalarFieldEnum
    having?: LessonCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCommentCountAggregateInputType | true
    _min?: LessonCommentMinAggregateInputType
    _max?: LessonCommentMaxAggregateInputType
  }

  export type LessonCommentGroupByOutputType = {
    id: string
    lessonId: string
    userId: string
    body: string
    createdAt: Date
    updatedAt: Date
    pendingModeration: boolean
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus
    _count: LessonCommentCountAggregateOutputType | null
    _min: LessonCommentMinAggregateOutputType | null
    _max: LessonCommentMaxAggregateOutputType | null
  }

  type GetLessonCommentGroupByPayload<T extends LessonCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonCommentGroupByOutputType[P]>
            : GetScalarType<T[P], LessonCommentGroupByOutputType[P]>
        }
      >
    >


  export type LessonCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingModeration?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    replies?: boolean | LessonComment$repliesArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | LessonCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingModeration?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingModeration?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectScalar = {
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingModeration?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
  }

  export type LessonCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "userId" | "body" | "createdAt" | "updatedAt" | "pendingModeration" | "moderatedAt" | "moderatedById" | "moderationStatus", ExtArgs["result"]["lessonComment"]>
  export type LessonCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | LessonComment$repliesArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | LessonCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonComment$moderatedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LessonCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonComment"
    objects: {
      replies: Prisma.$LessonCommentReplyPayload<ExtArgs>[]
      lesson: Prisma.$LessonPayload<ExtArgs>
      moderatedBy: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      userId: string
      body: string
      createdAt: Date
      updatedAt: Date
      pendingModeration: boolean
      moderatedAt: Date | null
      moderatedById: string | null
      moderationStatus: $Enums.LessonCommentModerationStatus
    }, ExtArgs["result"]["lessonComment"]>
    composites: {}
  }

  type LessonCommentGetPayload<S extends boolean | null | undefined | LessonCommentDefaultArgs> = $Result.GetResult<Prisma.$LessonCommentPayload, S>

  type LessonCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCommentCountAggregateInputType | true
    }

  export interface LessonCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonComment'], meta: { name: 'LessonComment' } }
    /**
     * Find zero or one LessonComment that matches the filter.
     * @param {LessonCommentFindUniqueArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonCommentFindUniqueArgs>(args: SelectSubset<T, LessonCommentFindUniqueArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonCommentFindUniqueOrThrowArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindFirstArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonCommentFindFirstArgs>(args?: SelectSubset<T, LessonCommentFindFirstArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindFirstOrThrowArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonComments
     * const lessonComments = await prisma.lessonComment.findMany()
     * 
     * // Get first 10 LessonComments
     * const lessonComments = await prisma.lessonComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonCommentFindManyArgs>(args?: SelectSubset<T, LessonCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonComment.
     * @param {LessonCommentCreateArgs} args - Arguments to create a LessonComment.
     * @example
     * // Create one LessonComment
     * const LessonComment = await prisma.lessonComment.create({
     *   data: {
     *     // ... data to create a LessonComment
     *   }
     * })
     * 
     */
    create<T extends LessonCommentCreateArgs>(args: SelectSubset<T, LessonCommentCreateArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonComments.
     * @param {LessonCommentCreateManyArgs} args - Arguments to create many LessonComments.
     * @example
     * // Create many LessonComments
     * const lessonComment = await prisma.lessonComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCommentCreateManyArgs>(args?: SelectSubset<T, LessonCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonComments and returns the data saved in the database.
     * @param {LessonCommentCreateManyAndReturnArgs} args - Arguments to create many LessonComments.
     * @example
     * // Create many LessonComments
     * const lessonComment = await prisma.lessonComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonComments and only return the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonComment.
     * @param {LessonCommentDeleteArgs} args - Arguments to delete one LessonComment.
     * @example
     * // Delete one LessonComment
     * const LessonComment = await prisma.lessonComment.delete({
     *   where: {
     *     // ... filter to delete one LessonComment
     *   }
     * })
     * 
     */
    delete<T extends LessonCommentDeleteArgs>(args: SelectSubset<T, LessonCommentDeleteArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonComment.
     * @param {LessonCommentUpdateArgs} args - Arguments to update one LessonComment.
     * @example
     * // Update one LessonComment
     * const lessonComment = await prisma.lessonComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonCommentUpdateArgs>(args: SelectSubset<T, LessonCommentUpdateArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonComments.
     * @param {LessonCommentDeleteManyArgs} args - Arguments to filter LessonComments to delete.
     * @example
     * // Delete a few LessonComments
     * const { count } = await prisma.lessonComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonCommentDeleteManyArgs>(args?: SelectSubset<T, LessonCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonComments
     * const lessonComment = await prisma.lessonComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonCommentUpdateManyArgs>(args: SelectSubset<T, LessonCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonComments and returns the data updated in the database.
     * @param {LessonCommentUpdateManyAndReturnArgs} args - Arguments to update many LessonComments.
     * @example
     * // Update many LessonComments
     * const lessonComment = await prisma.lessonComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonComments and only return the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonComment.
     * @param {LessonCommentUpsertArgs} args - Arguments to update or create a LessonComment.
     * @example
     * // Update or create a LessonComment
     * const lessonComment = await prisma.lessonComment.upsert({
     *   create: {
     *     // ... data to create a LessonComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonComment we want to update
     *   }
     * })
     */
    upsert<T extends LessonCommentUpsertArgs>(args: SelectSubset<T, LessonCommentUpsertArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentCountArgs} args - Arguments to filter LessonComments to count.
     * @example
     * // Count the number of LessonComments
     * const count = await prisma.lessonComment.count({
     *   where: {
     *     // ... the filter for the LessonComments we want to count
     *   }
     * })
    **/
    count<T extends LessonCommentCountArgs>(
      args?: Subset<T, LessonCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonCommentAggregateArgs>(args: Subset<T, LessonCommentAggregateArgs>): Prisma.PrismaPromise<GetLessonCommentAggregateType<T>>

    /**
     * Group by LessonComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonCommentGroupByArgs['orderBy'] }
        : { orderBy?: LessonCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonComment model
   */
  readonly fields: LessonCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    replies<T extends LessonComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, LessonComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moderatedBy<T extends LessonComment$moderatedByArgs<ExtArgs> = {}>(args?: Subset<T, LessonComment$moderatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonComment model
   */
  interface LessonCommentFieldRefs {
    readonly id: FieldRef<"LessonComment", 'String'>
    readonly lessonId: FieldRef<"LessonComment", 'String'>
    readonly userId: FieldRef<"LessonComment", 'String'>
    readonly body: FieldRef<"LessonComment", 'String'>
    readonly createdAt: FieldRef<"LessonComment", 'DateTime'>
    readonly updatedAt: FieldRef<"LessonComment", 'DateTime'>
    readonly pendingModeration: FieldRef<"LessonComment", 'Boolean'>
    readonly moderatedAt: FieldRef<"LessonComment", 'DateTime'>
    readonly moderatedById: FieldRef<"LessonComment", 'String'>
    readonly moderationStatus: FieldRef<"LessonComment", 'LessonCommentModerationStatus'>
  }
    

  // Custom InputTypes
  /**
   * LessonComment findUnique
   */
  export type LessonCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment findUniqueOrThrow
   */
  export type LessonCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment findFirst
   */
  export type LessonCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonComments.
     */
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment findFirstOrThrow
   */
  export type LessonCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonComments.
     */
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment findMany
   */
  export type LessonCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComments to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment create
   */
  export type LessonCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonComment.
     */
    data: XOR<LessonCommentCreateInput, LessonCommentUncheckedCreateInput>
  }

  /**
   * LessonComment createMany
   */
  export type LessonCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonComments.
     */
    data: LessonCommentCreateManyInput | LessonCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonComment createManyAndReturn
   */
  export type LessonCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * The data used to create many LessonComments.
     */
    data: LessonCommentCreateManyInput | LessonCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonComment update
   */
  export type LessonCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonComment.
     */
    data: XOR<LessonCommentUpdateInput, LessonCommentUncheckedUpdateInput>
    /**
     * Choose, which LessonComment to update.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment updateMany
   */
  export type LessonCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonComments.
     */
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyInput>
    /**
     * Filter which LessonComments to update
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to update.
     */
    limit?: number
  }

  /**
   * LessonComment updateManyAndReturn
   */
  export type LessonCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * The data used to update LessonComments.
     */
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyInput>
    /**
     * Filter which LessonComments to update
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonComment upsert
   */
  export type LessonCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonComment to update in case it exists.
     */
    where: LessonCommentWhereUniqueInput
    /**
     * In case the LessonComment found by the `where` argument doesn't exist, create a new LessonComment with this data.
     */
    create: XOR<LessonCommentCreateInput, LessonCommentUncheckedCreateInput>
    /**
     * In case the LessonComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonCommentUpdateInput, LessonCommentUncheckedUpdateInput>
  }

  /**
   * LessonComment delete
   */
  export type LessonCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter which LessonComment to delete.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment deleteMany
   */
  export type LessonCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonComments to delete
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to delete.
     */
    limit?: number
  }

  /**
   * LessonComment.replies
   */
  export type LessonComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    where?: LessonCommentReplyWhereInput
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    cursor?: LessonCommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * LessonComment.moderatedBy
   */
  export type LessonComment$moderatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LessonComment without action
   */
  export type LessonCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
  }


  /**
   * Model LessonCommentReply
   */

  export type AggregateLessonCommentReply = {
    _count: LessonCommentReplyCountAggregateOutputType | null
    _min: LessonCommentReplyMinAggregateOutputType | null
    _max: LessonCommentReplyMaxAggregateOutputType | null
  }

  export type LessonCommentReplyMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus | null
    parentReplyId: string | null
    pendingModeration: boolean | null
    updatedAt: Date | null
  }

  export type LessonCommentReplyMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus | null
    parentReplyId: string | null
    pendingModeration: boolean | null
    updatedAt: Date | null
  }

  export type LessonCommentReplyCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    body: number
    createdAt: number
    moderatedAt: number
    moderatedById: number
    moderationStatus: number
    parentReplyId: number
    pendingModeration: number
    updatedAt: number
    _all: number
  }


  export type LessonCommentReplyMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    body?: true
    createdAt?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
    parentReplyId?: true
    pendingModeration?: true
    updatedAt?: true
  }

  export type LessonCommentReplyMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    body?: true
    createdAt?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
    parentReplyId?: true
    pendingModeration?: true
    updatedAt?: true
  }

  export type LessonCommentReplyCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    body?: true
    createdAt?: true
    moderatedAt?: true
    moderatedById?: true
    moderationStatus?: true
    parentReplyId?: true
    pendingModeration?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonCommentReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonCommentReply to aggregate.
     */
    where?: LessonCommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCommentReplies to fetch.
     */
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonCommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonCommentReplies
    **/
    _count?: true | LessonCommentReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonCommentReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonCommentReplyMaxAggregateInputType
  }

  export type GetLessonCommentReplyAggregateType<T extends LessonCommentReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonCommentReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonCommentReply[P]>
      : GetScalarType<T[P], AggregateLessonCommentReply[P]>
  }




  export type LessonCommentReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentReplyWhereInput
    orderBy?: LessonCommentReplyOrderByWithAggregationInput | LessonCommentReplyOrderByWithAggregationInput[]
    by: LessonCommentReplyScalarFieldEnum[] | LessonCommentReplyScalarFieldEnum
    having?: LessonCommentReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCommentReplyCountAggregateInputType | true
    _min?: LessonCommentReplyMinAggregateInputType
    _max?: LessonCommentReplyMaxAggregateInputType
  }

  export type LessonCommentReplyGroupByOutputType = {
    id: string
    commentId: string
    userId: string
    body: string
    createdAt: Date
    moderatedAt: Date | null
    moderatedById: string | null
    moderationStatus: $Enums.LessonCommentModerationStatus
    parentReplyId: string | null
    pendingModeration: boolean
    updatedAt: Date
    _count: LessonCommentReplyCountAggregateOutputType | null
    _min: LessonCommentReplyMinAggregateOutputType | null
    _max: LessonCommentReplyMaxAggregateOutputType | null
  }

  type GetLessonCommentReplyGroupByPayload<T extends LessonCommentReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonCommentReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonCommentReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonCommentReplyGroupByOutputType[P]>
            : GetScalarType<T[P], LessonCommentReplyGroupByOutputType[P]>
        }
      >
    >


  export type LessonCommentReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    parentReplyId?: boolean
    pendingModeration?: boolean
    updatedAt?: boolean
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    replies?: boolean | LessonCommentReply$repliesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | LessonCommentReplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonCommentReply"]>

  export type LessonCommentReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    parentReplyId?: boolean
    pendingModeration?: boolean
    updatedAt?: boolean
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonCommentReply"]>

  export type LessonCommentReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    parentReplyId?: boolean
    pendingModeration?: boolean
    updatedAt?: boolean
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonCommentReply"]>

  export type LessonCommentReplySelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    moderatedAt?: boolean
    moderatedById?: boolean
    moderationStatus?: boolean
    parentReplyId?: boolean
    pendingModeration?: boolean
    updatedAt?: boolean
  }

  export type LessonCommentReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "userId" | "body" | "createdAt" | "moderatedAt" | "moderatedById" | "moderationStatus" | "parentReplyId" | "pendingModeration" | "updatedAt", ExtArgs["result"]["lessonCommentReply"]>
  export type LessonCommentReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    replies?: boolean | LessonCommentReply$repliesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | LessonCommentReplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonCommentReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonCommentReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | LessonCommentDefaultArgs<ExtArgs>
    moderatedBy?: boolean | LessonCommentReply$moderatedByArgs<ExtArgs>
    parentReply?: boolean | LessonCommentReply$parentReplyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LessonCommentReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonCommentReply"
    objects: {
      comment: Prisma.$LessonCommentPayload<ExtArgs>
      moderatedBy: Prisma.$UserPayload<ExtArgs> | null
      parentReply: Prisma.$LessonCommentReplyPayload<ExtArgs> | null
      replies: Prisma.$LessonCommentReplyPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      userId: string
      body: string
      createdAt: Date
      moderatedAt: Date | null
      moderatedById: string | null
      moderationStatus: $Enums.LessonCommentModerationStatus
      parentReplyId: string | null
      pendingModeration: boolean
      updatedAt: Date
    }, ExtArgs["result"]["lessonCommentReply"]>
    composites: {}
  }

  type LessonCommentReplyGetPayload<S extends boolean | null | undefined | LessonCommentReplyDefaultArgs> = $Result.GetResult<Prisma.$LessonCommentReplyPayload, S>

  type LessonCommentReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonCommentReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCommentReplyCountAggregateInputType | true
    }

  export interface LessonCommentReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonCommentReply'], meta: { name: 'LessonCommentReply' } }
    /**
     * Find zero or one LessonCommentReply that matches the filter.
     * @param {LessonCommentReplyFindUniqueArgs} args - Arguments to find a LessonCommentReply
     * @example
     * // Get one LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonCommentReplyFindUniqueArgs>(args: SelectSubset<T, LessonCommentReplyFindUniqueArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonCommentReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonCommentReplyFindUniqueOrThrowArgs} args - Arguments to find a LessonCommentReply
     * @example
     * // Get one LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonCommentReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonCommentReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonCommentReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyFindFirstArgs} args - Arguments to find a LessonCommentReply
     * @example
     * // Get one LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonCommentReplyFindFirstArgs>(args?: SelectSubset<T, LessonCommentReplyFindFirstArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonCommentReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyFindFirstOrThrowArgs} args - Arguments to find a LessonCommentReply
     * @example
     * // Get one LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonCommentReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonCommentReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonCommentReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonCommentReplies
     * const lessonCommentReplies = await prisma.lessonCommentReply.findMany()
     * 
     * // Get first 10 LessonCommentReplies
     * const lessonCommentReplies = await prisma.lessonCommentReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonCommentReplyWithIdOnly = await prisma.lessonCommentReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonCommentReplyFindManyArgs>(args?: SelectSubset<T, LessonCommentReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonCommentReply.
     * @param {LessonCommentReplyCreateArgs} args - Arguments to create a LessonCommentReply.
     * @example
     * // Create one LessonCommentReply
     * const LessonCommentReply = await prisma.lessonCommentReply.create({
     *   data: {
     *     // ... data to create a LessonCommentReply
     *   }
     * })
     * 
     */
    create<T extends LessonCommentReplyCreateArgs>(args: SelectSubset<T, LessonCommentReplyCreateArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonCommentReplies.
     * @param {LessonCommentReplyCreateManyArgs} args - Arguments to create many LessonCommentReplies.
     * @example
     * // Create many LessonCommentReplies
     * const lessonCommentReply = await prisma.lessonCommentReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCommentReplyCreateManyArgs>(args?: SelectSubset<T, LessonCommentReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonCommentReplies and returns the data saved in the database.
     * @param {LessonCommentReplyCreateManyAndReturnArgs} args - Arguments to create many LessonCommentReplies.
     * @example
     * // Create many LessonCommentReplies
     * const lessonCommentReply = await prisma.lessonCommentReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonCommentReplies and only return the `id`
     * const lessonCommentReplyWithIdOnly = await prisma.lessonCommentReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCommentReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCommentReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonCommentReply.
     * @param {LessonCommentReplyDeleteArgs} args - Arguments to delete one LessonCommentReply.
     * @example
     * // Delete one LessonCommentReply
     * const LessonCommentReply = await prisma.lessonCommentReply.delete({
     *   where: {
     *     // ... filter to delete one LessonCommentReply
     *   }
     * })
     * 
     */
    delete<T extends LessonCommentReplyDeleteArgs>(args: SelectSubset<T, LessonCommentReplyDeleteArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonCommentReply.
     * @param {LessonCommentReplyUpdateArgs} args - Arguments to update one LessonCommentReply.
     * @example
     * // Update one LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonCommentReplyUpdateArgs>(args: SelectSubset<T, LessonCommentReplyUpdateArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonCommentReplies.
     * @param {LessonCommentReplyDeleteManyArgs} args - Arguments to filter LessonCommentReplies to delete.
     * @example
     * // Delete a few LessonCommentReplies
     * const { count } = await prisma.lessonCommentReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonCommentReplyDeleteManyArgs>(args?: SelectSubset<T, LessonCommentReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonCommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonCommentReplies
     * const lessonCommentReply = await prisma.lessonCommentReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonCommentReplyUpdateManyArgs>(args: SelectSubset<T, LessonCommentReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonCommentReplies and returns the data updated in the database.
     * @param {LessonCommentReplyUpdateManyAndReturnArgs} args - Arguments to update many LessonCommentReplies.
     * @example
     * // Update many LessonCommentReplies
     * const lessonCommentReply = await prisma.lessonCommentReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonCommentReplies and only return the `id`
     * const lessonCommentReplyWithIdOnly = await prisma.lessonCommentReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonCommentReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonCommentReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonCommentReply.
     * @param {LessonCommentReplyUpsertArgs} args - Arguments to update or create a LessonCommentReply.
     * @example
     * // Update or create a LessonCommentReply
     * const lessonCommentReply = await prisma.lessonCommentReply.upsert({
     *   create: {
     *     // ... data to create a LessonCommentReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonCommentReply we want to update
     *   }
     * })
     */
    upsert<T extends LessonCommentReplyUpsertArgs>(args: SelectSubset<T, LessonCommentReplyUpsertArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonCommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyCountArgs} args - Arguments to filter LessonCommentReplies to count.
     * @example
     * // Count the number of LessonCommentReplies
     * const count = await prisma.lessonCommentReply.count({
     *   where: {
     *     // ... the filter for the LessonCommentReplies we want to count
     *   }
     * })
    **/
    count<T extends LessonCommentReplyCountArgs>(
      args?: Subset<T, LessonCommentReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCommentReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonCommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonCommentReplyAggregateArgs>(args: Subset<T, LessonCommentReplyAggregateArgs>): Prisma.PrismaPromise<GetLessonCommentReplyAggregateType<T>>

    /**
     * Group by LessonCommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonCommentReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonCommentReplyGroupByArgs['orderBy'] }
        : { orderBy?: LessonCommentReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonCommentReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonCommentReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonCommentReply model
   */
  readonly fields: LessonCommentReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonCommentReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonCommentReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends LessonCommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonCommentDefaultArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moderatedBy<T extends LessonCommentReply$moderatedByArgs<ExtArgs> = {}>(args?: Subset<T, LessonCommentReply$moderatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentReply<T extends LessonCommentReply$parentReplyArgs<ExtArgs> = {}>(args?: Subset<T, LessonCommentReply$parentReplyArgs<ExtArgs>>): Prisma__LessonCommentReplyClient<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends LessonCommentReply$repliesArgs<ExtArgs> = {}>(args?: Subset<T, LessonCommentReply$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonCommentReply model
   */
  interface LessonCommentReplyFieldRefs {
    readonly id: FieldRef<"LessonCommentReply", 'String'>
    readonly commentId: FieldRef<"LessonCommentReply", 'String'>
    readonly userId: FieldRef<"LessonCommentReply", 'String'>
    readonly body: FieldRef<"LessonCommentReply", 'String'>
    readonly createdAt: FieldRef<"LessonCommentReply", 'DateTime'>
    readonly moderatedAt: FieldRef<"LessonCommentReply", 'DateTime'>
    readonly moderatedById: FieldRef<"LessonCommentReply", 'String'>
    readonly moderationStatus: FieldRef<"LessonCommentReply", 'LessonCommentModerationStatus'>
    readonly parentReplyId: FieldRef<"LessonCommentReply", 'String'>
    readonly pendingModeration: FieldRef<"LessonCommentReply", 'Boolean'>
    readonly updatedAt: FieldRef<"LessonCommentReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonCommentReply findUnique
   */
  export type LessonCommentReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which LessonCommentReply to fetch.
     */
    where: LessonCommentReplyWhereUniqueInput
  }

  /**
   * LessonCommentReply findUniqueOrThrow
   */
  export type LessonCommentReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which LessonCommentReply to fetch.
     */
    where: LessonCommentReplyWhereUniqueInput
  }

  /**
   * LessonCommentReply findFirst
   */
  export type LessonCommentReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which LessonCommentReply to fetch.
     */
    where?: LessonCommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCommentReplies to fetch.
     */
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonCommentReplies.
     */
    cursor?: LessonCommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonCommentReplies.
     */
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * LessonCommentReply findFirstOrThrow
   */
  export type LessonCommentReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which LessonCommentReply to fetch.
     */
    where?: LessonCommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCommentReplies to fetch.
     */
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonCommentReplies.
     */
    cursor?: LessonCommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonCommentReplies.
     */
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * LessonCommentReply findMany
   */
  export type LessonCommentReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which LessonCommentReplies to fetch.
     */
    where?: LessonCommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCommentReplies to fetch.
     */
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonCommentReplies.
     */
    cursor?: LessonCommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCommentReplies.
     */
    skip?: number
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * LessonCommentReply create
   */
  export type LessonCommentReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonCommentReply.
     */
    data: XOR<LessonCommentReplyCreateInput, LessonCommentReplyUncheckedCreateInput>
  }

  /**
   * LessonCommentReply createMany
   */
  export type LessonCommentReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonCommentReplies.
     */
    data: LessonCommentReplyCreateManyInput | LessonCommentReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonCommentReply createManyAndReturn
   */
  export type LessonCommentReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * The data used to create many LessonCommentReplies.
     */
    data: LessonCommentReplyCreateManyInput | LessonCommentReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonCommentReply update
   */
  export type LessonCommentReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonCommentReply.
     */
    data: XOR<LessonCommentReplyUpdateInput, LessonCommentReplyUncheckedUpdateInput>
    /**
     * Choose, which LessonCommentReply to update.
     */
    where: LessonCommentReplyWhereUniqueInput
  }

  /**
   * LessonCommentReply updateMany
   */
  export type LessonCommentReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonCommentReplies.
     */
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which LessonCommentReplies to update
     */
    where?: LessonCommentReplyWhereInput
    /**
     * Limit how many LessonCommentReplies to update.
     */
    limit?: number
  }

  /**
   * LessonCommentReply updateManyAndReturn
   */
  export type LessonCommentReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * The data used to update LessonCommentReplies.
     */
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which LessonCommentReplies to update
     */
    where?: LessonCommentReplyWhereInput
    /**
     * Limit how many LessonCommentReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonCommentReply upsert
   */
  export type LessonCommentReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonCommentReply to update in case it exists.
     */
    where: LessonCommentReplyWhereUniqueInput
    /**
     * In case the LessonCommentReply found by the `where` argument doesn't exist, create a new LessonCommentReply with this data.
     */
    create: XOR<LessonCommentReplyCreateInput, LessonCommentReplyUncheckedCreateInput>
    /**
     * In case the LessonCommentReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonCommentReplyUpdateInput, LessonCommentReplyUncheckedUpdateInput>
  }

  /**
   * LessonCommentReply delete
   */
  export type LessonCommentReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    /**
     * Filter which LessonCommentReply to delete.
     */
    where: LessonCommentReplyWhereUniqueInput
  }

  /**
   * LessonCommentReply deleteMany
   */
  export type LessonCommentReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonCommentReplies to delete
     */
    where?: LessonCommentReplyWhereInput
    /**
     * Limit how many LessonCommentReplies to delete.
     */
    limit?: number
  }

  /**
   * LessonCommentReply.moderatedBy
   */
  export type LessonCommentReply$moderatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LessonCommentReply.parentReply
   */
  export type LessonCommentReply$parentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    where?: LessonCommentReplyWhereInput
  }

  /**
   * LessonCommentReply.replies
   */
  export type LessonCommentReply$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
    where?: LessonCommentReplyWhereInput
    orderBy?: LessonCommentReplyOrderByWithRelationInput | LessonCommentReplyOrderByWithRelationInput[]
    cursor?: LessonCommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentReplyScalarFieldEnum | LessonCommentReplyScalarFieldEnum[]
  }

  /**
   * LessonCommentReply without action
   */
  export type LessonCommentReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentReply
     */
    select?: LessonCommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonCommentReply
     */
    omit?: LessonCommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentReplyInclude<ExtArgs> | null
  }


  /**
   * Model CourseRecommendation
   */

  export type AggregateCourseRecommendation = {
    _count: CourseRecommendationCountAggregateOutputType | null
    _min: CourseRecommendationMinAggregateOutputType | null
    _max: CourseRecommendationMaxAggregateOutputType | null
  }

  export type CourseRecommendationMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    reason: string | null
    badge: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    reason: string | null
    badge: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationCountAggregateOutputType = {
    id: number
    courseId: number
    reason: number
    badge: number
    _all: number
  }


  export type CourseRecommendationMinAggregateInputType = {
    id?: true
    courseId?: true
    reason?: true
    badge?: true
  }

  export type CourseRecommendationMaxAggregateInputType = {
    id?: true
    courseId?: true
    reason?: true
    badge?: true
  }

  export type CourseRecommendationCountAggregateInputType = {
    id?: true
    courseId?: true
    reason?: true
    badge?: true
    _all?: true
  }

  export type CourseRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRecommendation to aggregate.
     */
    where?: CourseRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRecommendations to fetch.
     */
    orderBy?: CourseRecommendationOrderByWithRelationInput | CourseRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseRecommendations
    **/
    _count?: true | CourseRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseRecommendationMaxAggregateInputType
  }

  export type GetCourseRecommendationAggregateType<T extends CourseRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseRecommendation[P]>
      : GetScalarType<T[P], AggregateCourseRecommendation[P]>
  }




  export type CourseRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRecommendationWhereInput
    orderBy?: CourseRecommendationOrderByWithAggregationInput | CourseRecommendationOrderByWithAggregationInput[]
    by: CourseRecommendationScalarFieldEnum[] | CourseRecommendationScalarFieldEnum
    having?: CourseRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseRecommendationCountAggregateInputType | true
    _min?: CourseRecommendationMinAggregateInputType
    _max?: CourseRecommendationMaxAggregateInputType
  }

  export type CourseRecommendationGroupByOutputType = {
    id: string
    courseId: string
    reason: string
    badge: $Enums.RecommendationBadge | null
    _count: CourseRecommendationCountAggregateOutputType | null
    _min: CourseRecommendationMinAggregateOutputType | null
    _max: CourseRecommendationMaxAggregateOutputType | null
  }

  type GetCourseRecommendationGroupByPayload<T extends CourseRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], CourseRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type CourseRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    reason?: boolean
    badge?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRecommendation"]>

  export type CourseRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    reason?: boolean
    badge?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRecommendation"]>

  export type CourseRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    reason?: boolean
    badge?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRecommendation"]>

  export type CourseRecommendationSelectScalar = {
    id?: boolean
    courseId?: boolean
    reason?: boolean
    badge?: boolean
  }

  export type CourseRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "reason" | "badge", ExtArgs["result"]["courseRecommendation"]>
  export type CourseRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseRecommendation"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      reason: string
      badge: $Enums.RecommendationBadge | null
    }, ExtArgs["result"]["courseRecommendation"]>
    composites: {}
  }

  type CourseRecommendationGetPayload<S extends boolean | null | undefined | CourseRecommendationDefaultArgs> = $Result.GetResult<Prisma.$CourseRecommendationPayload, S>

  type CourseRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseRecommendationCountAggregateInputType | true
    }

  export interface CourseRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseRecommendation'], meta: { name: 'CourseRecommendation' } }
    /**
     * Find zero or one CourseRecommendation that matches the filter.
     * @param {CourseRecommendationFindUniqueArgs} args - Arguments to find a CourseRecommendation
     * @example
     * // Get one CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseRecommendationFindUniqueArgs>(args: SelectSubset<T, CourseRecommendationFindUniqueArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseRecommendationFindUniqueOrThrowArgs} args - Arguments to find a CourseRecommendation
     * @example
     * // Get one CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationFindFirstArgs} args - Arguments to find a CourseRecommendation
     * @example
     * // Get one CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseRecommendationFindFirstArgs>(args?: SelectSubset<T, CourseRecommendationFindFirstArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationFindFirstOrThrowArgs} args - Arguments to find a CourseRecommendation
     * @example
     * // Get one CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseRecommendations
     * const courseRecommendations = await prisma.courseRecommendation.findMany()
     * 
     * // Get first 10 CourseRecommendations
     * const courseRecommendations = await prisma.courseRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseRecommendationWithIdOnly = await prisma.courseRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseRecommendationFindManyArgs>(args?: SelectSubset<T, CourseRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseRecommendation.
     * @param {CourseRecommendationCreateArgs} args - Arguments to create a CourseRecommendation.
     * @example
     * // Create one CourseRecommendation
     * const CourseRecommendation = await prisma.courseRecommendation.create({
     *   data: {
     *     // ... data to create a CourseRecommendation
     *   }
     * })
     * 
     */
    create<T extends CourseRecommendationCreateArgs>(args: SelectSubset<T, CourseRecommendationCreateArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseRecommendations.
     * @param {CourseRecommendationCreateManyArgs} args - Arguments to create many CourseRecommendations.
     * @example
     * // Create many CourseRecommendations
     * const courseRecommendation = await prisma.courseRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseRecommendationCreateManyArgs>(args?: SelectSubset<T, CourseRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseRecommendations and returns the data saved in the database.
     * @param {CourseRecommendationCreateManyAndReturnArgs} args - Arguments to create many CourseRecommendations.
     * @example
     * // Create many CourseRecommendations
     * const courseRecommendation = await prisma.courseRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseRecommendations and only return the `id`
     * const courseRecommendationWithIdOnly = await prisma.courseRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseRecommendation.
     * @param {CourseRecommendationDeleteArgs} args - Arguments to delete one CourseRecommendation.
     * @example
     * // Delete one CourseRecommendation
     * const CourseRecommendation = await prisma.courseRecommendation.delete({
     *   where: {
     *     // ... filter to delete one CourseRecommendation
     *   }
     * })
     * 
     */
    delete<T extends CourseRecommendationDeleteArgs>(args: SelectSubset<T, CourseRecommendationDeleteArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseRecommendation.
     * @param {CourseRecommendationUpdateArgs} args - Arguments to update one CourseRecommendation.
     * @example
     * // Update one CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseRecommendationUpdateArgs>(args: SelectSubset<T, CourseRecommendationUpdateArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseRecommendations.
     * @param {CourseRecommendationDeleteManyArgs} args - Arguments to filter CourseRecommendations to delete.
     * @example
     * // Delete a few CourseRecommendations
     * const { count } = await prisma.courseRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseRecommendationDeleteManyArgs>(args?: SelectSubset<T, CourseRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseRecommendations
     * const courseRecommendation = await prisma.courseRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseRecommendationUpdateManyArgs>(args: SelectSubset<T, CourseRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRecommendations and returns the data updated in the database.
     * @param {CourseRecommendationUpdateManyAndReturnArgs} args - Arguments to update many CourseRecommendations.
     * @example
     * // Update many CourseRecommendations
     * const courseRecommendation = await prisma.courseRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseRecommendations and only return the `id`
     * const courseRecommendationWithIdOnly = await prisma.courseRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseRecommendation.
     * @param {CourseRecommendationUpsertArgs} args - Arguments to update or create a CourseRecommendation.
     * @example
     * // Update or create a CourseRecommendation
     * const courseRecommendation = await prisma.courseRecommendation.upsert({
     *   create: {
     *     // ... data to create a CourseRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends CourseRecommendationUpsertArgs>(args: SelectSubset<T, CourseRecommendationUpsertArgs<ExtArgs>>): Prisma__CourseRecommendationClient<$Result.GetResult<Prisma.$CourseRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationCountArgs} args - Arguments to filter CourseRecommendations to count.
     * @example
     * // Count the number of CourseRecommendations
     * const count = await prisma.courseRecommendation.count({
     *   where: {
     *     // ... the filter for the CourseRecommendations we want to count
     *   }
     * })
    **/
    count<T extends CourseRecommendationCountArgs>(
      args?: Subset<T, CourseRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseRecommendationAggregateArgs>(args: Subset<T, CourseRecommendationAggregateArgs>): Prisma.PrismaPromise<GetCourseRecommendationAggregateType<T>>

    /**
     * Group by CourseRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: CourseRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseRecommendation model
   */
  readonly fields: CourseRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseRecommendation model
   */
  interface CourseRecommendationFieldRefs {
    readonly id: FieldRef<"CourseRecommendation", 'String'>
    readonly courseId: FieldRef<"CourseRecommendation", 'String'>
    readonly reason: FieldRef<"CourseRecommendation", 'String'>
    readonly badge: FieldRef<"CourseRecommendation", 'RecommendationBadge'>
  }
    

  // Custom InputTypes
  /**
   * CourseRecommendation findUnique
   */
  export type CourseRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which CourseRecommendation to fetch.
     */
    where: CourseRecommendationWhereUniqueInput
  }

  /**
   * CourseRecommendation findUniqueOrThrow
   */
  export type CourseRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which CourseRecommendation to fetch.
     */
    where: CourseRecommendationWhereUniqueInput
  }

  /**
   * CourseRecommendation findFirst
   */
  export type CourseRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which CourseRecommendation to fetch.
     */
    where?: CourseRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRecommendations to fetch.
     */
    orderBy?: CourseRecommendationOrderByWithRelationInput | CourseRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRecommendations.
     */
    cursor?: CourseRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRecommendations.
     */
    distinct?: CourseRecommendationScalarFieldEnum | CourseRecommendationScalarFieldEnum[]
  }

  /**
   * CourseRecommendation findFirstOrThrow
   */
  export type CourseRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which CourseRecommendation to fetch.
     */
    where?: CourseRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRecommendations to fetch.
     */
    orderBy?: CourseRecommendationOrderByWithRelationInput | CourseRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRecommendations.
     */
    cursor?: CourseRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRecommendations.
     */
    distinct?: CourseRecommendationScalarFieldEnum | CourseRecommendationScalarFieldEnum[]
  }

  /**
   * CourseRecommendation findMany
   */
  export type CourseRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which CourseRecommendations to fetch.
     */
    where?: CourseRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRecommendations to fetch.
     */
    orderBy?: CourseRecommendationOrderByWithRelationInput | CourseRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseRecommendations.
     */
    cursor?: CourseRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRecommendations.
     */
    skip?: number
    distinct?: CourseRecommendationScalarFieldEnum | CourseRecommendationScalarFieldEnum[]
  }

  /**
   * CourseRecommendation create
   */
  export type CourseRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseRecommendation.
     */
    data: XOR<CourseRecommendationCreateInput, CourseRecommendationUncheckedCreateInput>
  }

  /**
   * CourseRecommendation createMany
   */
  export type CourseRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseRecommendations.
     */
    data: CourseRecommendationCreateManyInput | CourseRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseRecommendation createManyAndReturn
   */
  export type CourseRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many CourseRecommendations.
     */
    data: CourseRecommendationCreateManyInput | CourseRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRecommendation update
   */
  export type CourseRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseRecommendation.
     */
    data: XOR<CourseRecommendationUpdateInput, CourseRecommendationUncheckedUpdateInput>
    /**
     * Choose, which CourseRecommendation to update.
     */
    where: CourseRecommendationWhereUniqueInput
  }

  /**
   * CourseRecommendation updateMany
   */
  export type CourseRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseRecommendations.
     */
    data: XOR<CourseRecommendationUpdateManyMutationInput, CourseRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which CourseRecommendations to update
     */
    where?: CourseRecommendationWhereInput
    /**
     * Limit how many CourseRecommendations to update.
     */
    limit?: number
  }

  /**
   * CourseRecommendation updateManyAndReturn
   */
  export type CourseRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update CourseRecommendations.
     */
    data: XOR<CourseRecommendationUpdateManyMutationInput, CourseRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which CourseRecommendations to update
     */
    where?: CourseRecommendationWhereInput
    /**
     * Limit how many CourseRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRecommendation upsert
   */
  export type CourseRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseRecommendation to update in case it exists.
     */
    where: CourseRecommendationWhereUniqueInput
    /**
     * In case the CourseRecommendation found by the `where` argument doesn't exist, create a new CourseRecommendation with this data.
     */
    create: XOR<CourseRecommendationCreateInput, CourseRecommendationUncheckedCreateInput>
    /**
     * In case the CourseRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseRecommendationUpdateInput, CourseRecommendationUncheckedUpdateInput>
  }

  /**
   * CourseRecommendation delete
   */
  export type CourseRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
    /**
     * Filter which CourseRecommendation to delete.
     */
    where: CourseRecommendationWhereUniqueInput
  }

  /**
   * CourseRecommendation deleteMany
   */
  export type CourseRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRecommendations to delete
     */
    where?: CourseRecommendationWhereInput
    /**
     * Limit how many CourseRecommendations to delete.
     */
    limit?: number
  }

  /**
   * CourseRecommendation without action
   */
  export type CourseRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRecommendation
     */
    select?: CourseRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRecommendation
     */
    omit?: CourseRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model LessonRating
   */

  export type AggregateLessonRating = {
    _count: LessonRatingCountAggregateOutputType | null
    _avg: LessonRatingAvgAggregateOutputType | null
    _sum: LessonRatingSumAggregateOutputType | null
    _min: LessonRatingMinAggregateOutputType | null
    _max: LessonRatingMaxAggregateOutputType | null
  }

  export type LessonRatingAvgAggregateOutputType = {
    value: number | null
  }

  export type LessonRatingSumAggregateOutputType = {
    value: number | null
  }

  export type LessonRatingMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    value: number | null
    createdAt: Date | null
  }

  export type LessonRatingMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    value: number | null
    createdAt: Date | null
  }

  export type LessonRatingCountAggregateOutputType = {
    id: number
    lessonId: number
    userId: number
    value: number
    createdAt: number
    _all: number
  }


  export type LessonRatingAvgAggregateInputType = {
    value?: true
  }

  export type LessonRatingSumAggregateInputType = {
    value?: true
  }

  export type LessonRatingMinAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    value?: true
    createdAt?: true
  }

  export type LessonRatingMaxAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    value?: true
    createdAt?: true
  }

  export type LessonRatingCountAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type LessonRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonRating to aggregate.
     */
    where?: LessonRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonRatings to fetch.
     */
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonRatings
    **/
    _count?: true | LessonRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonRatingMaxAggregateInputType
  }

  export type GetLessonRatingAggregateType<T extends LessonRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonRating[P]>
      : GetScalarType<T[P], AggregateLessonRating[P]>
  }




  export type LessonRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonRatingWhereInput
    orderBy?: LessonRatingOrderByWithAggregationInput | LessonRatingOrderByWithAggregationInput[]
    by: LessonRatingScalarFieldEnum[] | LessonRatingScalarFieldEnum
    having?: LessonRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonRatingCountAggregateInputType | true
    _avg?: LessonRatingAvgAggregateInputType
    _sum?: LessonRatingSumAggregateInputType
    _min?: LessonRatingMinAggregateInputType
    _max?: LessonRatingMaxAggregateInputType
  }

  export type LessonRatingGroupByOutputType = {
    id: string
    lessonId: string
    userId: string
    value: number
    createdAt: Date
    _count: LessonRatingCountAggregateOutputType | null
    _avg: LessonRatingAvgAggregateOutputType | null
    _sum: LessonRatingSumAggregateOutputType | null
    _min: LessonRatingMinAggregateOutputType | null
    _max: LessonRatingMaxAggregateOutputType | null
  }

  type GetLessonRatingGroupByPayload<T extends LessonRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonRatingGroupByOutputType[P]>
            : GetScalarType<T[P], LessonRatingGroupByOutputType[P]>
        }
      >
    >


  export type LessonRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    value?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonRating"]>

  export type LessonRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    value?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonRating"]>

  export type LessonRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    value?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonRating"]>

  export type LessonRatingSelectScalar = {
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type LessonRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "userId" | "value" | "createdAt", ExtArgs["result"]["lessonRating"]>
  export type LessonRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LessonRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonRating"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      userId: string
      value: number
      createdAt: Date
    }, ExtArgs["result"]["lessonRating"]>
    composites: {}
  }

  type LessonRatingGetPayload<S extends boolean | null | undefined | LessonRatingDefaultArgs> = $Result.GetResult<Prisma.$LessonRatingPayload, S>

  type LessonRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonRatingCountAggregateInputType | true
    }

  export interface LessonRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonRating'], meta: { name: 'LessonRating' } }
    /**
     * Find zero or one LessonRating that matches the filter.
     * @param {LessonRatingFindUniqueArgs} args - Arguments to find a LessonRating
     * @example
     * // Get one LessonRating
     * const lessonRating = await prisma.lessonRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonRatingFindUniqueArgs>(args: SelectSubset<T, LessonRatingFindUniqueArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonRatingFindUniqueOrThrowArgs} args - Arguments to find a LessonRating
     * @example
     * // Get one LessonRating
     * const lessonRating = await prisma.lessonRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingFindFirstArgs} args - Arguments to find a LessonRating
     * @example
     * // Get one LessonRating
     * const lessonRating = await prisma.lessonRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonRatingFindFirstArgs>(args?: SelectSubset<T, LessonRatingFindFirstArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingFindFirstOrThrowArgs} args - Arguments to find a LessonRating
     * @example
     * // Get one LessonRating
     * const lessonRating = await prisma.lessonRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonRatings
     * const lessonRatings = await prisma.lessonRating.findMany()
     * 
     * // Get first 10 LessonRatings
     * const lessonRatings = await prisma.lessonRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonRatingWithIdOnly = await prisma.lessonRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonRatingFindManyArgs>(args?: SelectSubset<T, LessonRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonRating.
     * @param {LessonRatingCreateArgs} args - Arguments to create a LessonRating.
     * @example
     * // Create one LessonRating
     * const LessonRating = await prisma.lessonRating.create({
     *   data: {
     *     // ... data to create a LessonRating
     *   }
     * })
     * 
     */
    create<T extends LessonRatingCreateArgs>(args: SelectSubset<T, LessonRatingCreateArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonRatings.
     * @param {LessonRatingCreateManyArgs} args - Arguments to create many LessonRatings.
     * @example
     * // Create many LessonRatings
     * const lessonRating = await prisma.lessonRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonRatingCreateManyArgs>(args?: SelectSubset<T, LessonRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonRatings and returns the data saved in the database.
     * @param {LessonRatingCreateManyAndReturnArgs} args - Arguments to create many LessonRatings.
     * @example
     * // Create many LessonRatings
     * const lessonRating = await prisma.lessonRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonRatings and only return the `id`
     * const lessonRatingWithIdOnly = await prisma.lessonRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonRating.
     * @param {LessonRatingDeleteArgs} args - Arguments to delete one LessonRating.
     * @example
     * // Delete one LessonRating
     * const LessonRating = await prisma.lessonRating.delete({
     *   where: {
     *     // ... filter to delete one LessonRating
     *   }
     * })
     * 
     */
    delete<T extends LessonRatingDeleteArgs>(args: SelectSubset<T, LessonRatingDeleteArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonRating.
     * @param {LessonRatingUpdateArgs} args - Arguments to update one LessonRating.
     * @example
     * // Update one LessonRating
     * const lessonRating = await prisma.lessonRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonRatingUpdateArgs>(args: SelectSubset<T, LessonRatingUpdateArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonRatings.
     * @param {LessonRatingDeleteManyArgs} args - Arguments to filter LessonRatings to delete.
     * @example
     * // Delete a few LessonRatings
     * const { count } = await prisma.lessonRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonRatingDeleteManyArgs>(args?: SelectSubset<T, LessonRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonRatings
     * const lessonRating = await prisma.lessonRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonRatingUpdateManyArgs>(args: SelectSubset<T, LessonRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonRatings and returns the data updated in the database.
     * @param {LessonRatingUpdateManyAndReturnArgs} args - Arguments to update many LessonRatings.
     * @example
     * // Update many LessonRatings
     * const lessonRating = await prisma.lessonRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonRatings and only return the `id`
     * const lessonRatingWithIdOnly = await prisma.lessonRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonRating.
     * @param {LessonRatingUpsertArgs} args - Arguments to update or create a LessonRating.
     * @example
     * // Update or create a LessonRating
     * const lessonRating = await prisma.lessonRating.upsert({
     *   create: {
     *     // ... data to create a LessonRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonRating we want to update
     *   }
     * })
     */
    upsert<T extends LessonRatingUpsertArgs>(args: SelectSubset<T, LessonRatingUpsertArgs<ExtArgs>>): Prisma__LessonRatingClient<$Result.GetResult<Prisma.$LessonRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingCountArgs} args - Arguments to filter LessonRatings to count.
     * @example
     * // Count the number of LessonRatings
     * const count = await prisma.lessonRating.count({
     *   where: {
     *     // ... the filter for the LessonRatings we want to count
     *   }
     * })
    **/
    count<T extends LessonRatingCountArgs>(
      args?: Subset<T, LessonRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonRatingAggregateArgs>(args: Subset<T, LessonRatingAggregateArgs>): Prisma.PrismaPromise<GetLessonRatingAggregateType<T>>

    /**
     * Group by LessonRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonRatingGroupByArgs['orderBy'] }
        : { orderBy?: LessonRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonRating model
   */
  readonly fields: LessonRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonRating model
   */
  interface LessonRatingFieldRefs {
    readonly id: FieldRef<"LessonRating", 'String'>
    readonly lessonId: FieldRef<"LessonRating", 'String'>
    readonly userId: FieldRef<"LessonRating", 'String'>
    readonly value: FieldRef<"LessonRating", 'Int'>
    readonly createdAt: FieldRef<"LessonRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonRating findUnique
   */
  export type LessonRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter, which LessonRating to fetch.
     */
    where: LessonRatingWhereUniqueInput
  }

  /**
   * LessonRating findUniqueOrThrow
   */
  export type LessonRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter, which LessonRating to fetch.
     */
    where: LessonRatingWhereUniqueInput
  }

  /**
   * LessonRating findFirst
   */
  export type LessonRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter, which LessonRating to fetch.
     */
    where?: LessonRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonRatings to fetch.
     */
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonRatings.
     */
    cursor?: LessonRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonRatings.
     */
    distinct?: LessonRatingScalarFieldEnum | LessonRatingScalarFieldEnum[]
  }

  /**
   * LessonRating findFirstOrThrow
   */
  export type LessonRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter, which LessonRating to fetch.
     */
    where?: LessonRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonRatings to fetch.
     */
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonRatings.
     */
    cursor?: LessonRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonRatings.
     */
    distinct?: LessonRatingScalarFieldEnum | LessonRatingScalarFieldEnum[]
  }

  /**
   * LessonRating findMany
   */
  export type LessonRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter, which LessonRatings to fetch.
     */
    where?: LessonRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonRatings to fetch.
     */
    orderBy?: LessonRatingOrderByWithRelationInput | LessonRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonRatings.
     */
    cursor?: LessonRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonRatings.
     */
    skip?: number
    distinct?: LessonRatingScalarFieldEnum | LessonRatingScalarFieldEnum[]
  }

  /**
   * LessonRating create
   */
  export type LessonRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonRating.
     */
    data: XOR<LessonRatingCreateInput, LessonRatingUncheckedCreateInput>
  }

  /**
   * LessonRating createMany
   */
  export type LessonRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonRatings.
     */
    data: LessonRatingCreateManyInput | LessonRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonRating createManyAndReturn
   */
  export type LessonRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * The data used to create many LessonRatings.
     */
    data: LessonRatingCreateManyInput | LessonRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonRating update
   */
  export type LessonRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonRating.
     */
    data: XOR<LessonRatingUpdateInput, LessonRatingUncheckedUpdateInput>
    /**
     * Choose, which LessonRating to update.
     */
    where: LessonRatingWhereUniqueInput
  }

  /**
   * LessonRating updateMany
   */
  export type LessonRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonRatings.
     */
    data: XOR<LessonRatingUpdateManyMutationInput, LessonRatingUncheckedUpdateManyInput>
    /**
     * Filter which LessonRatings to update
     */
    where?: LessonRatingWhereInput
    /**
     * Limit how many LessonRatings to update.
     */
    limit?: number
  }

  /**
   * LessonRating updateManyAndReturn
   */
  export type LessonRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * The data used to update LessonRatings.
     */
    data: XOR<LessonRatingUpdateManyMutationInput, LessonRatingUncheckedUpdateManyInput>
    /**
     * Filter which LessonRatings to update
     */
    where?: LessonRatingWhereInput
    /**
     * Limit how many LessonRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonRating upsert
   */
  export type LessonRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonRating to update in case it exists.
     */
    where: LessonRatingWhereUniqueInput
    /**
     * In case the LessonRating found by the `where` argument doesn't exist, create a new LessonRating with this data.
     */
    create: XOR<LessonRatingCreateInput, LessonRatingUncheckedCreateInput>
    /**
     * In case the LessonRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonRatingUpdateInput, LessonRatingUncheckedUpdateInput>
  }

  /**
   * LessonRating delete
   */
  export type LessonRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
    /**
     * Filter which LessonRating to delete.
     */
    where: LessonRatingWhereUniqueInput
  }

  /**
   * LessonRating deleteMany
   */
  export type LessonRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonRatings to delete
     */
    where?: LessonRatingWhereInput
    /**
     * Limit how many LessonRatings to delete.
     */
    limit?: number
  }

  /**
   * LessonRating without action
   */
  export type LessonRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonRating
     */
    select?: LessonRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonRating
     */
    omit?: LessonRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonRatingInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgressEvent
   */

  export type AggregateLessonProgressEvent = {
    _count: LessonProgressEventCountAggregateOutputType | null
    _avg: LessonProgressEventAvgAggregateOutputType | null
    _sum: LessonProgressEventSumAggregateOutputType | null
    _min: LessonProgressEventMinAggregateOutputType | null
    _max: LessonProgressEventMaxAggregateOutputType | null
  }

  export type LessonProgressEventAvgAggregateOutputType = {
    positionSec: number | null
  }

  export type LessonProgressEventSumAggregateOutputType = {
    positionSec: number | null
  }

  export type LessonProgressEventMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    occurredAt: Date | null
    positionSec: number | null
  }

  export type LessonProgressEventMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    occurredAt: Date | null
    positionSec: number | null
  }

  export type LessonProgressEventCountAggregateOutputType = {
    id: number
    lessonId: number
    userId: number
    occurredAt: number
    positionSec: number
    _all: number
  }


  export type LessonProgressEventAvgAggregateInputType = {
    positionSec?: true
  }

  export type LessonProgressEventSumAggregateInputType = {
    positionSec?: true
  }

  export type LessonProgressEventMinAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    occurredAt?: true
    positionSec?: true
  }

  export type LessonProgressEventMaxAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    occurredAt?: true
    positionSec?: true
  }

  export type LessonProgressEventCountAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    occurredAt?: true
    positionSec?: true
    _all?: true
  }

  export type LessonProgressEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgressEvent to aggregate.
     */
    where?: LessonProgressEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressEvents to fetch.
     */
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgressEvents
    **/
    _count?: true | LessonProgressEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressEventMaxAggregateInputType
  }

  export type GetLessonProgressEventAggregateType<T extends LessonProgressEventAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgressEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgressEvent[P]>
      : GetScalarType<T[P], AggregateLessonProgressEvent[P]>
  }




  export type LessonProgressEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressEventWhereInput
    orderBy?: LessonProgressEventOrderByWithAggregationInput | LessonProgressEventOrderByWithAggregationInput[]
    by: LessonProgressEventScalarFieldEnum[] | LessonProgressEventScalarFieldEnum
    having?: LessonProgressEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressEventCountAggregateInputType | true
    _avg?: LessonProgressEventAvgAggregateInputType
    _sum?: LessonProgressEventSumAggregateInputType
    _min?: LessonProgressEventMinAggregateInputType
    _max?: LessonProgressEventMaxAggregateInputType
  }

  export type LessonProgressEventGroupByOutputType = {
    id: string
    lessonId: string
    userId: string
    occurredAt: Date
    positionSec: number
    _count: LessonProgressEventCountAggregateOutputType | null
    _avg: LessonProgressEventAvgAggregateOutputType | null
    _sum: LessonProgressEventSumAggregateOutputType | null
    _min: LessonProgressEventMinAggregateOutputType | null
    _max: LessonProgressEventMaxAggregateOutputType | null
  }

  type GetLessonProgressEventGroupByPayload<T extends LessonProgressEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressEventGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressEventGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    occurredAt?: boolean
    positionSec?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressEvent"]>

  export type LessonProgressEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    occurredAt?: boolean
    positionSec?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressEvent"]>

  export type LessonProgressEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    occurredAt?: boolean
    positionSec?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressEvent"]>

  export type LessonProgressEventSelectScalar = {
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    occurredAt?: boolean
    positionSec?: boolean
  }

  export type LessonProgressEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "userId" | "occurredAt" | "positionSec", ExtArgs["result"]["lessonProgressEvent"]>
  export type LessonProgressEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonProgressEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonProgressEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LessonProgressEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgressEvent"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      userId: string
      occurredAt: Date
      positionSec: number
    }, ExtArgs["result"]["lessonProgressEvent"]>
    composites: {}
  }

  type LessonProgressEventGetPayload<S extends boolean | null | undefined | LessonProgressEventDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressEventPayload, S>

  type LessonProgressEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonProgressEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonProgressEventCountAggregateInputType | true
    }

  export interface LessonProgressEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgressEvent'], meta: { name: 'LessonProgressEvent' } }
    /**
     * Find zero or one LessonProgressEvent that matches the filter.
     * @param {LessonProgressEventFindUniqueArgs} args - Arguments to find a LessonProgressEvent
     * @example
     * // Get one LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonProgressEventFindUniqueArgs>(args: SelectSubset<T, LessonProgressEventFindUniqueArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonProgressEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonProgressEventFindUniqueOrThrowArgs} args - Arguments to find a LessonProgressEvent
     * @example
     * // Get one LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonProgressEventFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonProgressEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgressEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventFindFirstArgs} args - Arguments to find a LessonProgressEvent
     * @example
     * // Get one LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonProgressEventFindFirstArgs>(args?: SelectSubset<T, LessonProgressEventFindFirstArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgressEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventFindFirstOrThrowArgs} args - Arguments to find a LessonProgressEvent
     * @example
     * // Get one LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonProgressEventFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonProgressEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonProgressEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgressEvents
     * const lessonProgressEvents = await prisma.lessonProgressEvent.findMany()
     * 
     * // Get first 10 LessonProgressEvents
     * const lessonProgressEvents = await prisma.lessonProgressEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonProgressEventWithIdOnly = await prisma.lessonProgressEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonProgressEventFindManyArgs>(args?: SelectSubset<T, LessonProgressEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonProgressEvent.
     * @param {LessonProgressEventCreateArgs} args - Arguments to create a LessonProgressEvent.
     * @example
     * // Create one LessonProgressEvent
     * const LessonProgressEvent = await prisma.lessonProgressEvent.create({
     *   data: {
     *     // ... data to create a LessonProgressEvent
     *   }
     * })
     * 
     */
    create<T extends LessonProgressEventCreateArgs>(args: SelectSubset<T, LessonProgressEventCreateArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonProgressEvents.
     * @param {LessonProgressEventCreateManyArgs} args - Arguments to create many LessonProgressEvents.
     * @example
     * // Create many LessonProgressEvents
     * const lessonProgressEvent = await prisma.lessonProgressEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonProgressEventCreateManyArgs>(args?: SelectSubset<T, LessonProgressEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonProgressEvents and returns the data saved in the database.
     * @param {LessonProgressEventCreateManyAndReturnArgs} args - Arguments to create many LessonProgressEvents.
     * @example
     * // Create many LessonProgressEvents
     * const lessonProgressEvent = await prisma.lessonProgressEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonProgressEvents and only return the `id`
     * const lessonProgressEventWithIdOnly = await prisma.lessonProgressEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonProgressEventCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonProgressEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonProgressEvent.
     * @param {LessonProgressEventDeleteArgs} args - Arguments to delete one LessonProgressEvent.
     * @example
     * // Delete one LessonProgressEvent
     * const LessonProgressEvent = await prisma.lessonProgressEvent.delete({
     *   where: {
     *     // ... filter to delete one LessonProgressEvent
     *   }
     * })
     * 
     */
    delete<T extends LessonProgressEventDeleteArgs>(args: SelectSubset<T, LessonProgressEventDeleteArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonProgressEvent.
     * @param {LessonProgressEventUpdateArgs} args - Arguments to update one LessonProgressEvent.
     * @example
     * // Update one LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonProgressEventUpdateArgs>(args: SelectSubset<T, LessonProgressEventUpdateArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonProgressEvents.
     * @param {LessonProgressEventDeleteManyArgs} args - Arguments to filter LessonProgressEvents to delete.
     * @example
     * // Delete a few LessonProgressEvents
     * const { count } = await prisma.lessonProgressEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonProgressEventDeleteManyArgs>(args?: SelectSubset<T, LessonProgressEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgressEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgressEvents
     * const lessonProgressEvent = await prisma.lessonProgressEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonProgressEventUpdateManyArgs>(args: SelectSubset<T, LessonProgressEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgressEvents and returns the data updated in the database.
     * @param {LessonProgressEventUpdateManyAndReturnArgs} args - Arguments to update many LessonProgressEvents.
     * @example
     * // Update many LessonProgressEvents
     * const lessonProgressEvent = await prisma.lessonProgressEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonProgressEvents and only return the `id`
     * const lessonProgressEventWithIdOnly = await prisma.lessonProgressEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonProgressEventUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonProgressEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonProgressEvent.
     * @param {LessonProgressEventUpsertArgs} args - Arguments to update or create a LessonProgressEvent.
     * @example
     * // Update or create a LessonProgressEvent
     * const lessonProgressEvent = await prisma.lessonProgressEvent.upsert({
     *   create: {
     *     // ... data to create a LessonProgressEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgressEvent we want to update
     *   }
     * })
     */
    upsert<T extends LessonProgressEventUpsertArgs>(args: SelectSubset<T, LessonProgressEventUpsertArgs<ExtArgs>>): Prisma__LessonProgressEventClient<$Result.GetResult<Prisma.$LessonProgressEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonProgressEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventCountArgs} args - Arguments to filter LessonProgressEvents to count.
     * @example
     * // Count the number of LessonProgressEvents
     * const count = await prisma.lessonProgressEvent.count({
     *   where: {
     *     // ... the filter for the LessonProgressEvents we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressEventCountArgs>(
      args?: Subset<T, LessonProgressEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgressEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressEventAggregateArgs>(args: Subset<T, LessonProgressEventAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressEventAggregateType<T>>

    /**
     * Group by LessonProgressEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressEventGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgressEvent model
   */
  readonly fields: LessonProgressEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgressEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonProgressEvent model
   */
  interface LessonProgressEventFieldRefs {
    readonly id: FieldRef<"LessonProgressEvent", 'String'>
    readonly lessonId: FieldRef<"LessonProgressEvent", 'String'>
    readonly userId: FieldRef<"LessonProgressEvent", 'String'>
    readonly occurredAt: FieldRef<"LessonProgressEvent", 'DateTime'>
    readonly positionSec: FieldRef<"LessonProgressEvent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgressEvent findUnique
   */
  export type LessonProgressEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressEvent to fetch.
     */
    where: LessonProgressEventWhereUniqueInput
  }

  /**
   * LessonProgressEvent findUniqueOrThrow
   */
  export type LessonProgressEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressEvent to fetch.
     */
    where: LessonProgressEventWhereUniqueInput
  }

  /**
   * LessonProgressEvent findFirst
   */
  export type LessonProgressEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressEvent to fetch.
     */
    where?: LessonProgressEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressEvents to fetch.
     */
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgressEvents.
     */
    cursor?: LessonProgressEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgressEvents.
     */
    distinct?: LessonProgressEventScalarFieldEnum | LessonProgressEventScalarFieldEnum[]
  }

  /**
   * LessonProgressEvent findFirstOrThrow
   */
  export type LessonProgressEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressEvent to fetch.
     */
    where?: LessonProgressEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressEvents to fetch.
     */
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgressEvents.
     */
    cursor?: LessonProgressEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgressEvents.
     */
    distinct?: LessonProgressEventScalarFieldEnum | LessonProgressEventScalarFieldEnum[]
  }

  /**
   * LessonProgressEvent findMany
   */
  export type LessonProgressEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressEvents to fetch.
     */
    where?: LessonProgressEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressEvents to fetch.
     */
    orderBy?: LessonProgressEventOrderByWithRelationInput | LessonProgressEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgressEvents.
     */
    cursor?: LessonProgressEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressEvents.
     */
    skip?: number
    distinct?: LessonProgressEventScalarFieldEnum | LessonProgressEventScalarFieldEnum[]
  }

  /**
   * LessonProgressEvent create
   */
  export type LessonProgressEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgressEvent.
     */
    data: XOR<LessonProgressEventCreateInput, LessonProgressEventUncheckedCreateInput>
  }

  /**
   * LessonProgressEvent createMany
   */
  export type LessonProgressEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgressEvents.
     */
    data: LessonProgressEventCreateManyInput | LessonProgressEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgressEvent createManyAndReturn
   */
  export type LessonProgressEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * The data used to create many LessonProgressEvents.
     */
    data: LessonProgressEventCreateManyInput | LessonProgressEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgressEvent update
   */
  export type LessonProgressEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgressEvent.
     */
    data: XOR<LessonProgressEventUpdateInput, LessonProgressEventUncheckedUpdateInput>
    /**
     * Choose, which LessonProgressEvent to update.
     */
    where: LessonProgressEventWhereUniqueInput
  }

  /**
   * LessonProgressEvent updateMany
   */
  export type LessonProgressEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgressEvents.
     */
    data: XOR<LessonProgressEventUpdateManyMutationInput, LessonProgressEventUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgressEvents to update
     */
    where?: LessonProgressEventWhereInput
    /**
     * Limit how many LessonProgressEvents to update.
     */
    limit?: number
  }

  /**
   * LessonProgressEvent updateManyAndReturn
   */
  export type LessonProgressEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * The data used to update LessonProgressEvents.
     */
    data: XOR<LessonProgressEventUpdateManyMutationInput, LessonProgressEventUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgressEvents to update
     */
    where?: LessonProgressEventWhereInput
    /**
     * Limit how many LessonProgressEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgressEvent upsert
   */
  export type LessonProgressEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgressEvent to update in case it exists.
     */
    where: LessonProgressEventWhereUniqueInput
    /**
     * In case the LessonProgressEvent found by the `where` argument doesn't exist, create a new LessonProgressEvent with this data.
     */
    create: XOR<LessonProgressEventCreateInput, LessonProgressEventUncheckedCreateInput>
    /**
     * In case the LessonProgressEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressEventUpdateInput, LessonProgressEventUncheckedUpdateInput>
  }

  /**
   * LessonProgressEvent delete
   */
  export type LessonProgressEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
    /**
     * Filter which LessonProgressEvent to delete.
     */
    where: LessonProgressEventWhereUniqueInput
  }

  /**
   * LessonProgressEvent deleteMany
   */
  export type LessonProgressEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgressEvents to delete
     */
    where?: LessonProgressEventWhereInput
    /**
     * Limit how many LessonProgressEvents to delete.
     */
    limit?: number
  }

  /**
   * LessonProgressEvent without action
   */
  export type LessonProgressEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressEvent
     */
    select?: LessonProgressEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressEvent
     */
    omit?: LessonProgressEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressEventInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgressAggregate
   */

  export type AggregateLessonProgressAggregate = {
    _count: LessonProgressAggregateCountAggregateOutputType | null
    _avg: LessonProgressAggregateAvgAggregateOutputType | null
    _sum: LessonProgressAggregateSumAggregateOutputType | null
    _min: LessonProgressAggregateMinAggregateOutputType | null
    _max: LessonProgressAggregateMaxAggregateOutputType | null
  }

  export type LessonProgressAggregateAvgAggregateOutputType = {
    lastPositionSec: number | null
    percentage: number | null
  }

  export type LessonProgressAggregateSumAggregateOutputType = {
    lastPositionSec: number | null
    percentage: number | null
  }

  export type LessonProgressAggregateMinAggregateOutputType = {
    lessonId: string | null
    userId: string | null
    lastPositionSec: number | null
    percentage: number | null
    updatedAt: Date | null
  }

  export type LessonProgressAggregateMaxAggregateOutputType = {
    lessonId: string | null
    userId: string | null
    lastPositionSec: number | null
    percentage: number | null
    updatedAt: Date | null
  }

  export type LessonProgressAggregateCountAggregateOutputType = {
    lessonId: number
    userId: number
    lastPositionSec: number
    percentage: number
    updatedAt: number
    _all: number
  }


  export type LessonProgressAggregateAvgAggregateInputType = {
    lastPositionSec?: true
    percentage?: true
  }

  export type LessonProgressAggregateSumAggregateInputType = {
    lastPositionSec?: true
    percentage?: true
  }

  export type LessonProgressAggregateMinAggregateInputType = {
    lessonId?: true
    userId?: true
    lastPositionSec?: true
    percentage?: true
    updatedAt?: true
  }

  export type LessonProgressAggregateMaxAggregateInputType = {
    lessonId?: true
    userId?: true
    lastPositionSec?: true
    percentage?: true
    updatedAt?: true
  }

  export type LessonProgressAggregateCountAggregateInputType = {
    lessonId?: true
    userId?: true
    lastPositionSec?: true
    percentage?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonProgressAggregateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgressAggregate to aggregate.
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressAggregates to fetch.
     */
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgressAggregates
    **/
    _count?: true | LessonProgressAggregateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressAggregateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressAggregateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressAggregateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressAggregateMaxAggregateInputType
  }

  export type GetLessonProgressAggregateAggregateType<T extends LessonProgressAggregateAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgressAggregate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgressAggregate[P]>
      : GetScalarType<T[P], AggregateLessonProgressAggregate[P]>
  }




  export type LessonProgressAggregateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressAggregateWhereInput
    orderBy?: LessonProgressAggregateOrderByWithAggregationInput | LessonProgressAggregateOrderByWithAggregationInput[]
    by: LessonProgressAggregateScalarFieldEnum[] | LessonProgressAggregateScalarFieldEnum
    having?: LessonProgressAggregateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressAggregateCountAggregateInputType | true
    _avg?: LessonProgressAggregateAvgAggregateInputType
    _sum?: LessonProgressAggregateSumAggregateInputType
    _min?: LessonProgressAggregateMinAggregateInputType
    _max?: LessonProgressAggregateMaxAggregateInputType
  }

  export type LessonProgressAggregateGroupByOutputType = {
    lessonId: string
    userId: string
    lastPositionSec: number
    percentage: number
    updatedAt: Date
    _count: LessonProgressAggregateCountAggregateOutputType | null
    _avg: LessonProgressAggregateAvgAggregateOutputType | null
    _sum: LessonProgressAggregateSumAggregateOutputType | null
    _min: LessonProgressAggregateMinAggregateOutputType | null
    _max: LessonProgressAggregateMaxAggregateOutputType | null
  }

  type GetLessonProgressAggregateGroupByPayload<T extends LessonProgressAggregateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressAggregateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressAggregateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressAggregateGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressAggregateGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressAggregateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    userId?: boolean
    lastPositionSec?: boolean
    percentage?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressAggregate"]>

  export type LessonProgressAggregateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    userId?: boolean
    lastPositionSec?: boolean
    percentage?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressAggregate"]>

  export type LessonProgressAggregateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lessonId?: boolean
    userId?: boolean
    lastPositionSec?: boolean
    percentage?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgressAggregate"]>

  export type LessonProgressAggregateSelectScalar = {
    lessonId?: boolean
    userId?: boolean
    lastPositionSec?: boolean
    percentage?: boolean
    updatedAt?: boolean
  }

  export type LessonProgressAggregateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lessonId" | "userId" | "lastPositionSec" | "percentage" | "updatedAt", ExtArgs["result"]["lessonProgressAggregate"]>
  export type LessonProgressAggregateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonProgressAggregateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LessonProgressAggregateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LessonProgressAggregatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgressAggregate"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lessonId: string
      userId: string
      lastPositionSec: number
      percentage: number
      updatedAt: Date
    }, ExtArgs["result"]["lessonProgressAggregate"]>
    composites: {}
  }

  type LessonProgressAggregateGetPayload<S extends boolean | null | undefined | LessonProgressAggregateDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressAggregatePayload, S>

  type LessonProgressAggregateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonProgressAggregateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonProgressAggregateCountAggregateInputType | true
    }

  export interface LessonProgressAggregateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgressAggregate'], meta: { name: 'LessonProgressAggregate' } }
    /**
     * Find zero or one LessonProgressAggregate that matches the filter.
     * @param {LessonProgressAggregateFindUniqueArgs} args - Arguments to find a LessonProgressAggregate
     * @example
     * // Get one LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonProgressAggregateFindUniqueArgs>(args: SelectSubset<T, LessonProgressAggregateFindUniqueArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonProgressAggregate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonProgressAggregateFindUniqueOrThrowArgs} args - Arguments to find a LessonProgressAggregate
     * @example
     * // Get one LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonProgressAggregateFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonProgressAggregateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgressAggregate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateFindFirstArgs} args - Arguments to find a LessonProgressAggregate
     * @example
     * // Get one LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonProgressAggregateFindFirstArgs>(args?: SelectSubset<T, LessonProgressAggregateFindFirstArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgressAggregate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateFindFirstOrThrowArgs} args - Arguments to find a LessonProgressAggregate
     * @example
     * // Get one LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonProgressAggregateFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonProgressAggregateFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonProgressAggregates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgressAggregates
     * const lessonProgressAggregates = await prisma.lessonProgressAggregate.findMany()
     * 
     * // Get first 10 LessonProgressAggregates
     * const lessonProgressAggregates = await prisma.lessonProgressAggregate.findMany({ take: 10 })
     * 
     * // Only select the `lessonId`
     * const lessonProgressAggregateWithLessonIdOnly = await prisma.lessonProgressAggregate.findMany({ select: { lessonId: true } })
     * 
     */
    findMany<T extends LessonProgressAggregateFindManyArgs>(args?: SelectSubset<T, LessonProgressAggregateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonProgressAggregate.
     * @param {LessonProgressAggregateCreateArgs} args - Arguments to create a LessonProgressAggregate.
     * @example
     * // Create one LessonProgressAggregate
     * const LessonProgressAggregate = await prisma.lessonProgressAggregate.create({
     *   data: {
     *     // ... data to create a LessonProgressAggregate
     *   }
     * })
     * 
     */
    create<T extends LessonProgressAggregateCreateArgs>(args: SelectSubset<T, LessonProgressAggregateCreateArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonProgressAggregates.
     * @param {LessonProgressAggregateCreateManyArgs} args - Arguments to create many LessonProgressAggregates.
     * @example
     * // Create many LessonProgressAggregates
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonProgressAggregateCreateManyArgs>(args?: SelectSubset<T, LessonProgressAggregateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonProgressAggregates and returns the data saved in the database.
     * @param {LessonProgressAggregateCreateManyAndReturnArgs} args - Arguments to create many LessonProgressAggregates.
     * @example
     * // Create many LessonProgressAggregates
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonProgressAggregates and only return the `lessonId`
     * const lessonProgressAggregateWithLessonIdOnly = await prisma.lessonProgressAggregate.createManyAndReturn({
     *   select: { lessonId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonProgressAggregateCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonProgressAggregateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonProgressAggregate.
     * @param {LessonProgressAggregateDeleteArgs} args - Arguments to delete one LessonProgressAggregate.
     * @example
     * // Delete one LessonProgressAggregate
     * const LessonProgressAggregate = await prisma.lessonProgressAggregate.delete({
     *   where: {
     *     // ... filter to delete one LessonProgressAggregate
     *   }
     * })
     * 
     */
    delete<T extends LessonProgressAggregateDeleteArgs>(args: SelectSubset<T, LessonProgressAggregateDeleteArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonProgressAggregate.
     * @param {LessonProgressAggregateUpdateArgs} args - Arguments to update one LessonProgressAggregate.
     * @example
     * // Update one LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonProgressAggregateUpdateArgs>(args: SelectSubset<T, LessonProgressAggregateUpdateArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonProgressAggregates.
     * @param {LessonProgressAggregateDeleteManyArgs} args - Arguments to filter LessonProgressAggregates to delete.
     * @example
     * // Delete a few LessonProgressAggregates
     * const { count } = await prisma.lessonProgressAggregate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonProgressAggregateDeleteManyArgs>(args?: SelectSubset<T, LessonProgressAggregateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgressAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgressAggregates
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonProgressAggregateUpdateManyArgs>(args: SelectSubset<T, LessonProgressAggregateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgressAggregates and returns the data updated in the database.
     * @param {LessonProgressAggregateUpdateManyAndReturnArgs} args - Arguments to update many LessonProgressAggregates.
     * @example
     * // Update many LessonProgressAggregates
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonProgressAggregates and only return the `lessonId`
     * const lessonProgressAggregateWithLessonIdOnly = await prisma.lessonProgressAggregate.updateManyAndReturn({
     *   select: { lessonId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonProgressAggregateUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonProgressAggregateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonProgressAggregate.
     * @param {LessonProgressAggregateUpsertArgs} args - Arguments to update or create a LessonProgressAggregate.
     * @example
     * // Update or create a LessonProgressAggregate
     * const lessonProgressAggregate = await prisma.lessonProgressAggregate.upsert({
     *   create: {
     *     // ... data to create a LessonProgressAggregate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgressAggregate we want to update
     *   }
     * })
     */
    upsert<T extends LessonProgressAggregateUpsertArgs>(args: SelectSubset<T, LessonProgressAggregateUpsertArgs<ExtArgs>>): Prisma__LessonProgressAggregateClient<$Result.GetResult<Prisma.$LessonProgressAggregatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonProgressAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateCountArgs} args - Arguments to filter LessonProgressAggregates to count.
     * @example
     * // Count the number of LessonProgressAggregates
     * const count = await prisma.lessonProgressAggregate.count({
     *   where: {
     *     // ... the filter for the LessonProgressAggregates we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressAggregateCountArgs>(
      args?: Subset<T, LessonProgressAggregateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressAggregateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgressAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressAggregateAggregateArgs>(args: Subset<T, LessonProgressAggregateAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressAggregateAggregateType<T>>

    /**
     * Group by LessonProgressAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressAggregateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressAggregateGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressAggregateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressAggregateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressAggregateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgressAggregate model
   */
  readonly fields: LessonProgressAggregateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgressAggregate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressAggregateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonProgressAggregate model
   */
  interface LessonProgressAggregateFieldRefs {
    readonly lessonId: FieldRef<"LessonProgressAggregate", 'String'>
    readonly userId: FieldRef<"LessonProgressAggregate", 'String'>
    readonly lastPositionSec: FieldRef<"LessonProgressAggregate", 'Int'>
    readonly percentage: FieldRef<"LessonProgressAggregate", 'Float'>
    readonly updatedAt: FieldRef<"LessonProgressAggregate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgressAggregate findUnique
   */
  export type LessonProgressAggregateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressAggregate to fetch.
     */
    where: LessonProgressAggregateWhereUniqueInput
  }

  /**
   * LessonProgressAggregate findUniqueOrThrow
   */
  export type LessonProgressAggregateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressAggregate to fetch.
     */
    where: LessonProgressAggregateWhereUniqueInput
  }

  /**
   * LessonProgressAggregate findFirst
   */
  export type LessonProgressAggregateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressAggregate to fetch.
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressAggregates to fetch.
     */
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgressAggregates.
     */
    cursor?: LessonProgressAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgressAggregates.
     */
    distinct?: LessonProgressAggregateScalarFieldEnum | LessonProgressAggregateScalarFieldEnum[]
  }

  /**
   * LessonProgressAggregate findFirstOrThrow
   */
  export type LessonProgressAggregateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressAggregate to fetch.
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressAggregates to fetch.
     */
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgressAggregates.
     */
    cursor?: LessonProgressAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgressAggregates.
     */
    distinct?: LessonProgressAggregateScalarFieldEnum | LessonProgressAggregateScalarFieldEnum[]
  }

  /**
   * LessonProgressAggregate findMany
   */
  export type LessonProgressAggregateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgressAggregates to fetch.
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgressAggregates to fetch.
     */
    orderBy?: LessonProgressAggregateOrderByWithRelationInput | LessonProgressAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgressAggregates.
     */
    cursor?: LessonProgressAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgressAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgressAggregates.
     */
    skip?: number
    distinct?: LessonProgressAggregateScalarFieldEnum | LessonProgressAggregateScalarFieldEnum[]
  }

  /**
   * LessonProgressAggregate create
   */
  export type LessonProgressAggregateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgressAggregate.
     */
    data: XOR<LessonProgressAggregateCreateInput, LessonProgressAggregateUncheckedCreateInput>
  }

  /**
   * LessonProgressAggregate createMany
   */
  export type LessonProgressAggregateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgressAggregates.
     */
    data: LessonProgressAggregateCreateManyInput | LessonProgressAggregateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgressAggregate createManyAndReturn
   */
  export type LessonProgressAggregateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * The data used to create many LessonProgressAggregates.
     */
    data: LessonProgressAggregateCreateManyInput | LessonProgressAggregateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgressAggregate update
   */
  export type LessonProgressAggregateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgressAggregate.
     */
    data: XOR<LessonProgressAggregateUpdateInput, LessonProgressAggregateUncheckedUpdateInput>
    /**
     * Choose, which LessonProgressAggregate to update.
     */
    where: LessonProgressAggregateWhereUniqueInput
  }

  /**
   * LessonProgressAggregate updateMany
   */
  export type LessonProgressAggregateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgressAggregates.
     */
    data: XOR<LessonProgressAggregateUpdateManyMutationInput, LessonProgressAggregateUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgressAggregates to update
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * Limit how many LessonProgressAggregates to update.
     */
    limit?: number
  }

  /**
   * LessonProgressAggregate updateManyAndReturn
   */
  export type LessonProgressAggregateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * The data used to update LessonProgressAggregates.
     */
    data: XOR<LessonProgressAggregateUpdateManyMutationInput, LessonProgressAggregateUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgressAggregates to update
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * Limit how many LessonProgressAggregates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgressAggregate upsert
   */
  export type LessonProgressAggregateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgressAggregate to update in case it exists.
     */
    where: LessonProgressAggregateWhereUniqueInput
    /**
     * In case the LessonProgressAggregate found by the `where` argument doesn't exist, create a new LessonProgressAggregate with this data.
     */
    create: XOR<LessonProgressAggregateCreateInput, LessonProgressAggregateUncheckedCreateInput>
    /**
     * In case the LessonProgressAggregate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressAggregateUpdateInput, LessonProgressAggregateUncheckedUpdateInput>
  }

  /**
   * LessonProgressAggregate delete
   */
  export type LessonProgressAggregateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
    /**
     * Filter which LessonProgressAggregate to delete.
     */
    where: LessonProgressAggregateWhereUniqueInput
  }

  /**
   * LessonProgressAggregate deleteMany
   */
  export type LessonProgressAggregateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgressAggregates to delete
     */
    where?: LessonProgressAggregateWhereInput
    /**
     * Limit how many LessonProgressAggregates to delete.
     */
    limit?: number
  }

  /**
   * LessonProgressAggregate without action
   */
  export type LessonProgressAggregateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgressAggregate
     */
    select?: LessonProgressAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgressAggregate
     */
    omit?: LessonProgressAggregateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressAggregateInclude<ExtArgs> | null
  }


  /**
   * Model EvolutionApiConfig
   */

  export type AggregateEvolutionApiConfig = {
    _count: EvolutionApiConfigCountAggregateOutputType | null
    _min: EvolutionApiConfigMinAggregateOutputType | null
    _max: EvolutionApiConfigMaxAggregateOutputType | null
  }

  export type EvolutionApiConfigMinAggregateOutputType = {
    id: string | null
    userId: string | null
    baseUrl: string | null
    apiKeyEncrypted: Bytes | null
    connectedAt: Date | null
    lastHealthCheckAt: Date | null
    status: $Enums.EvolutionConnectionStatus | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvolutionApiConfigMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    baseUrl: string | null
    apiKeyEncrypted: Bytes | null
    connectedAt: Date | null
    lastHealthCheckAt: Date | null
    status: $Enums.EvolutionConnectionStatus | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvolutionApiConfigCountAggregateOutputType = {
    id: number
    userId: number
    baseUrl: number
    apiKeyEncrypted: number
    connectedAt: number
    lastHealthCheckAt: number
    status: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvolutionApiConfigMinAggregateInputType = {
    id?: true
    userId?: true
    baseUrl?: true
    apiKeyEncrypted?: true
    connectedAt?: true
    lastHealthCheckAt?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvolutionApiConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    baseUrl?: true
    apiKeyEncrypted?: true
    connectedAt?: true
    lastHealthCheckAt?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvolutionApiConfigCountAggregateInputType = {
    id?: true
    userId?: true
    baseUrl?: true
    apiKeyEncrypted?: true
    connectedAt?: true
    lastHealthCheckAt?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvolutionApiConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionApiConfig to aggregate.
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionApiConfigs to fetch.
     */
    orderBy?: EvolutionApiConfigOrderByWithRelationInput | EvolutionApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolutionApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvolutionApiConfigs
    **/
    _count?: true | EvolutionApiConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolutionApiConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolutionApiConfigMaxAggregateInputType
  }

  export type GetEvolutionApiConfigAggregateType<T extends EvolutionApiConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolutionApiConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolutionApiConfig[P]>
      : GetScalarType<T[P], AggregateEvolutionApiConfig[P]>
  }




  export type EvolutionApiConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolutionApiConfigWhereInput
    orderBy?: EvolutionApiConfigOrderByWithAggregationInput | EvolutionApiConfigOrderByWithAggregationInput[]
    by: EvolutionApiConfigScalarFieldEnum[] | EvolutionApiConfigScalarFieldEnum
    having?: EvolutionApiConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolutionApiConfigCountAggregateInputType | true
    _min?: EvolutionApiConfigMinAggregateInputType
    _max?: EvolutionApiConfigMaxAggregateInputType
  }

  export type EvolutionApiConfigGroupByOutputType = {
    id: string
    userId: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt: Date | null
    lastHealthCheckAt: Date | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: EvolutionApiConfigCountAggregateOutputType | null
    _min: EvolutionApiConfigMinAggregateOutputType | null
    _max: EvolutionApiConfigMaxAggregateOutputType | null
  }

  type GetEvolutionApiConfigGroupByPayload<T extends EvolutionApiConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolutionApiConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolutionApiConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolutionApiConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EvolutionApiConfigGroupByOutputType[P]>
        }
      >
    >


  export type EvolutionApiConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    baseUrl?: boolean
    apiKeyEncrypted?: boolean
    connectedAt?: boolean
    lastHealthCheckAt?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | EvolutionApiConfig$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EvolutionApiConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolutionApiConfig"]>

  export type EvolutionApiConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    baseUrl?: boolean
    apiKeyEncrypted?: boolean
    connectedAt?: boolean
    lastHealthCheckAt?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolutionApiConfig"]>

  export type EvolutionApiConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    baseUrl?: boolean
    apiKeyEncrypted?: boolean
    connectedAt?: boolean
    lastHealthCheckAt?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolutionApiConfig"]>

  export type EvolutionApiConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    baseUrl?: boolean
    apiKeyEncrypted?: boolean
    connectedAt?: boolean
    lastHealthCheckAt?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvolutionApiConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "baseUrl" | "apiKeyEncrypted" | "connectedAt" | "lastHealthCheckAt" | "status" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["evolutionApiConfig"]>
  export type EvolutionApiConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | EvolutionApiConfig$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EvolutionApiConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvolutionApiConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EvolutionApiConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EvolutionApiConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvolutionApiConfig"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      baseUrl: string
      apiKeyEncrypted: Prisma.Bytes
      connectedAt: Date | null
      lastHealthCheckAt: Date | null
      status: $Enums.EvolutionConnectionStatus
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evolutionApiConfig"]>
    composites: {}
  }

  type EvolutionApiConfigGetPayload<S extends boolean | null | undefined | EvolutionApiConfigDefaultArgs> = $Result.GetResult<Prisma.$EvolutionApiConfigPayload, S>

  type EvolutionApiConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolutionApiConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolutionApiConfigCountAggregateInputType | true
    }

  export interface EvolutionApiConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvolutionApiConfig'], meta: { name: 'EvolutionApiConfig' } }
    /**
     * Find zero or one EvolutionApiConfig that matches the filter.
     * @param {EvolutionApiConfigFindUniqueArgs} args - Arguments to find a EvolutionApiConfig
     * @example
     * // Get one EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolutionApiConfigFindUniqueArgs>(args: SelectSubset<T, EvolutionApiConfigFindUniqueArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvolutionApiConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolutionApiConfigFindUniqueOrThrowArgs} args - Arguments to find a EvolutionApiConfig
     * @example
     * // Get one EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolutionApiConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolutionApiConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolutionApiConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigFindFirstArgs} args - Arguments to find a EvolutionApiConfig
     * @example
     * // Get one EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolutionApiConfigFindFirstArgs>(args?: SelectSubset<T, EvolutionApiConfigFindFirstArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolutionApiConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigFindFirstOrThrowArgs} args - Arguments to find a EvolutionApiConfig
     * @example
     * // Get one EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolutionApiConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolutionApiConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvolutionApiConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvolutionApiConfigs
     * const evolutionApiConfigs = await prisma.evolutionApiConfig.findMany()
     * 
     * // Get first 10 EvolutionApiConfigs
     * const evolutionApiConfigs = await prisma.evolutionApiConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolutionApiConfigWithIdOnly = await prisma.evolutionApiConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolutionApiConfigFindManyArgs>(args?: SelectSubset<T, EvolutionApiConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvolutionApiConfig.
     * @param {EvolutionApiConfigCreateArgs} args - Arguments to create a EvolutionApiConfig.
     * @example
     * // Create one EvolutionApiConfig
     * const EvolutionApiConfig = await prisma.evolutionApiConfig.create({
     *   data: {
     *     // ... data to create a EvolutionApiConfig
     *   }
     * })
     * 
     */
    create<T extends EvolutionApiConfigCreateArgs>(args: SelectSubset<T, EvolutionApiConfigCreateArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvolutionApiConfigs.
     * @param {EvolutionApiConfigCreateManyArgs} args - Arguments to create many EvolutionApiConfigs.
     * @example
     * // Create many EvolutionApiConfigs
     * const evolutionApiConfig = await prisma.evolutionApiConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolutionApiConfigCreateManyArgs>(args?: SelectSubset<T, EvolutionApiConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvolutionApiConfigs and returns the data saved in the database.
     * @param {EvolutionApiConfigCreateManyAndReturnArgs} args - Arguments to create many EvolutionApiConfigs.
     * @example
     * // Create many EvolutionApiConfigs
     * const evolutionApiConfig = await prisma.evolutionApiConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvolutionApiConfigs and only return the `id`
     * const evolutionApiConfigWithIdOnly = await prisma.evolutionApiConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvolutionApiConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, EvolutionApiConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvolutionApiConfig.
     * @param {EvolutionApiConfigDeleteArgs} args - Arguments to delete one EvolutionApiConfig.
     * @example
     * // Delete one EvolutionApiConfig
     * const EvolutionApiConfig = await prisma.evolutionApiConfig.delete({
     *   where: {
     *     // ... filter to delete one EvolutionApiConfig
     *   }
     * })
     * 
     */
    delete<T extends EvolutionApiConfigDeleteArgs>(args: SelectSubset<T, EvolutionApiConfigDeleteArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvolutionApiConfig.
     * @param {EvolutionApiConfigUpdateArgs} args - Arguments to update one EvolutionApiConfig.
     * @example
     * // Update one EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolutionApiConfigUpdateArgs>(args: SelectSubset<T, EvolutionApiConfigUpdateArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvolutionApiConfigs.
     * @param {EvolutionApiConfigDeleteManyArgs} args - Arguments to filter EvolutionApiConfigs to delete.
     * @example
     * // Delete a few EvolutionApiConfigs
     * const { count } = await prisma.evolutionApiConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolutionApiConfigDeleteManyArgs>(args?: SelectSubset<T, EvolutionApiConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolutionApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvolutionApiConfigs
     * const evolutionApiConfig = await prisma.evolutionApiConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolutionApiConfigUpdateManyArgs>(args: SelectSubset<T, EvolutionApiConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolutionApiConfigs and returns the data updated in the database.
     * @param {EvolutionApiConfigUpdateManyAndReturnArgs} args - Arguments to update many EvolutionApiConfigs.
     * @example
     * // Update many EvolutionApiConfigs
     * const evolutionApiConfig = await prisma.evolutionApiConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvolutionApiConfigs and only return the `id`
     * const evolutionApiConfigWithIdOnly = await prisma.evolutionApiConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvolutionApiConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, EvolutionApiConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvolutionApiConfig.
     * @param {EvolutionApiConfigUpsertArgs} args - Arguments to update or create a EvolutionApiConfig.
     * @example
     * // Update or create a EvolutionApiConfig
     * const evolutionApiConfig = await prisma.evolutionApiConfig.upsert({
     *   create: {
     *     // ... data to create a EvolutionApiConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvolutionApiConfig we want to update
     *   }
     * })
     */
    upsert<T extends EvolutionApiConfigUpsertArgs>(args: SelectSubset<T, EvolutionApiConfigUpsertArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvolutionApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigCountArgs} args - Arguments to filter EvolutionApiConfigs to count.
     * @example
     * // Count the number of EvolutionApiConfigs
     * const count = await prisma.evolutionApiConfig.count({
     *   where: {
     *     // ... the filter for the EvolutionApiConfigs we want to count
     *   }
     * })
    **/
    count<T extends EvolutionApiConfigCountArgs>(
      args?: Subset<T, EvolutionApiConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolutionApiConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvolutionApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolutionApiConfigAggregateArgs>(args: Subset<T, EvolutionApiConfigAggregateArgs>): Prisma.PrismaPromise<GetEvolutionApiConfigAggregateType<T>>

    /**
     * Group by EvolutionApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionApiConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolutionApiConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolutionApiConfigGroupByArgs['orderBy'] }
        : { orderBy?: EvolutionApiConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolutionApiConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolutionApiConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvolutionApiConfig model
   */
  readonly fields: EvolutionApiConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvolutionApiConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolutionApiConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends EvolutionApiConfig$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, EvolutionApiConfig$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvolutionApiConfig model
   */
  interface EvolutionApiConfigFieldRefs {
    readonly id: FieldRef<"EvolutionApiConfig", 'String'>
    readonly userId: FieldRef<"EvolutionApiConfig", 'String'>
    readonly baseUrl: FieldRef<"EvolutionApiConfig", 'String'>
    readonly apiKeyEncrypted: FieldRef<"EvolutionApiConfig", 'Bytes'>
    readonly connectedAt: FieldRef<"EvolutionApiConfig", 'DateTime'>
    readonly lastHealthCheckAt: FieldRef<"EvolutionApiConfig", 'DateTime'>
    readonly status: FieldRef<"EvolutionApiConfig", 'EvolutionConnectionStatus'>
    readonly errorMessage: FieldRef<"EvolutionApiConfig", 'String'>
    readonly createdAt: FieldRef<"EvolutionApiConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"EvolutionApiConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvolutionApiConfig findUnique
   */
  export type EvolutionApiConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionApiConfig to fetch.
     */
    where: EvolutionApiConfigWhereUniqueInput
  }

  /**
   * EvolutionApiConfig findUniqueOrThrow
   */
  export type EvolutionApiConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionApiConfig to fetch.
     */
    where: EvolutionApiConfigWhereUniqueInput
  }

  /**
   * EvolutionApiConfig findFirst
   */
  export type EvolutionApiConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionApiConfig to fetch.
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionApiConfigs to fetch.
     */
    orderBy?: EvolutionApiConfigOrderByWithRelationInput | EvolutionApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionApiConfigs.
     */
    cursor?: EvolutionApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionApiConfigs.
     */
    distinct?: EvolutionApiConfigScalarFieldEnum | EvolutionApiConfigScalarFieldEnum[]
  }

  /**
   * EvolutionApiConfig findFirstOrThrow
   */
  export type EvolutionApiConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionApiConfig to fetch.
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionApiConfigs to fetch.
     */
    orderBy?: EvolutionApiConfigOrderByWithRelationInput | EvolutionApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionApiConfigs.
     */
    cursor?: EvolutionApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionApiConfigs.
     */
    distinct?: EvolutionApiConfigScalarFieldEnum | EvolutionApiConfigScalarFieldEnum[]
  }

  /**
   * EvolutionApiConfig findMany
   */
  export type EvolutionApiConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionApiConfigs to fetch.
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionApiConfigs to fetch.
     */
    orderBy?: EvolutionApiConfigOrderByWithRelationInput | EvolutionApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvolutionApiConfigs.
     */
    cursor?: EvolutionApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionApiConfigs.
     */
    skip?: number
    distinct?: EvolutionApiConfigScalarFieldEnum | EvolutionApiConfigScalarFieldEnum[]
  }

  /**
   * EvolutionApiConfig create
   */
  export type EvolutionApiConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a EvolutionApiConfig.
     */
    data: XOR<EvolutionApiConfigCreateInput, EvolutionApiConfigUncheckedCreateInput>
  }

  /**
   * EvolutionApiConfig createMany
   */
  export type EvolutionApiConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvolutionApiConfigs.
     */
    data: EvolutionApiConfigCreateManyInput | EvolutionApiConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvolutionApiConfig createManyAndReturn
   */
  export type EvolutionApiConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * The data used to create many EvolutionApiConfigs.
     */
    data: EvolutionApiConfigCreateManyInput | EvolutionApiConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolutionApiConfig update
   */
  export type EvolutionApiConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a EvolutionApiConfig.
     */
    data: XOR<EvolutionApiConfigUpdateInput, EvolutionApiConfigUncheckedUpdateInput>
    /**
     * Choose, which EvolutionApiConfig to update.
     */
    where: EvolutionApiConfigWhereUniqueInput
  }

  /**
   * EvolutionApiConfig updateMany
   */
  export type EvolutionApiConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvolutionApiConfigs.
     */
    data: XOR<EvolutionApiConfigUpdateManyMutationInput, EvolutionApiConfigUncheckedUpdateManyInput>
    /**
     * Filter which EvolutionApiConfigs to update
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * Limit how many EvolutionApiConfigs to update.
     */
    limit?: number
  }

  /**
   * EvolutionApiConfig updateManyAndReturn
   */
  export type EvolutionApiConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * The data used to update EvolutionApiConfigs.
     */
    data: XOR<EvolutionApiConfigUpdateManyMutationInput, EvolutionApiConfigUncheckedUpdateManyInput>
    /**
     * Filter which EvolutionApiConfigs to update
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * Limit how many EvolutionApiConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolutionApiConfig upsert
   */
  export type EvolutionApiConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the EvolutionApiConfig to update in case it exists.
     */
    where: EvolutionApiConfigWhereUniqueInput
    /**
     * In case the EvolutionApiConfig found by the `where` argument doesn't exist, create a new EvolutionApiConfig with this data.
     */
    create: XOR<EvolutionApiConfigCreateInput, EvolutionApiConfigUncheckedCreateInput>
    /**
     * In case the EvolutionApiConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolutionApiConfigUpdateInput, EvolutionApiConfigUncheckedUpdateInput>
  }

  /**
   * EvolutionApiConfig delete
   */
  export type EvolutionApiConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    /**
     * Filter which EvolutionApiConfig to delete.
     */
    where: EvolutionApiConfigWhereUniqueInput
  }

  /**
   * EvolutionApiConfig deleteMany
   */
  export type EvolutionApiConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionApiConfigs to delete
     */
    where?: EvolutionApiConfigWhereInput
    /**
     * Limit how many EvolutionApiConfigs to delete.
     */
    limit?: number
  }

  /**
   * EvolutionApiConfig.campaigns
   */
  export type EvolutionApiConfig$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * EvolutionApiConfig without action
   */
  export type EvolutionApiConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
  }


  /**
   * Model ContactSegment
   */

  export type AggregateContactSegment = {
    _count: ContactSegmentCountAggregateOutputType | null
    _avg: ContactSegmentAvgAggregateOutputType | null
    _sum: ContactSegmentSumAggregateOutputType | null
    _min: ContactSegmentMinAggregateOutputType | null
    _max: ContactSegmentMaxAggregateOutputType | null
  }

  export type ContactSegmentAvgAggregateOutputType = {
    totalContacts: number | null
  }

  export type ContactSegmentSumAggregateOutputType = {
    totalContacts: number | null
  }

  export type ContactSegmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    importSource: $Enums.ContactImportSource | null
    totalContacts: number | null
    createdAt: Date | null
  }

  export type ContactSegmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    importSource: $Enums.ContactImportSource | null
    totalContacts: number | null
    createdAt: Date | null
  }

  export type ContactSegmentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    importSource: number
    totalContacts: number
    createdAt: number
    _all: number
  }


  export type ContactSegmentAvgAggregateInputType = {
    totalContacts?: true
  }

  export type ContactSegmentSumAggregateInputType = {
    totalContacts?: true
  }

  export type ContactSegmentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    importSource?: true
    totalContacts?: true
    createdAt?: true
  }

  export type ContactSegmentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    importSource?: true
    totalContacts?: true
    createdAt?: true
  }

  export type ContactSegmentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    importSource?: true
    totalContacts?: true
    createdAt?: true
    _all?: true
  }

  export type ContactSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSegment to aggregate.
     */
    where?: ContactSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSegments to fetch.
     */
    orderBy?: ContactSegmentOrderByWithRelationInput | ContactSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSegments
    **/
    _count?: true | ContactSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSegmentMaxAggregateInputType
  }

  export type GetContactSegmentAggregateType<T extends ContactSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSegment[P]>
      : GetScalarType<T[P], AggregateContactSegment[P]>
  }




  export type ContactSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSegmentWhereInput
    orderBy?: ContactSegmentOrderByWithAggregationInput | ContactSegmentOrderByWithAggregationInput[]
    by: ContactSegmentScalarFieldEnum[] | ContactSegmentScalarFieldEnum
    having?: ContactSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSegmentCountAggregateInputType | true
    _avg?: ContactSegmentAvgAggregateInputType
    _sum?: ContactSegmentSumAggregateInputType
    _min?: ContactSegmentMinAggregateInputType
    _max?: ContactSegmentMaxAggregateInputType
  }

  export type ContactSegmentGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts: number
    createdAt: Date
    _count: ContactSegmentCountAggregateOutputType | null
    _avg: ContactSegmentAvgAggregateOutputType | null
    _sum: ContactSegmentSumAggregateOutputType | null
    _min: ContactSegmentMinAggregateOutputType | null
    _max: ContactSegmentMaxAggregateOutputType | null
  }

  type GetContactSegmentGroupByPayload<T extends ContactSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSegmentGroupByOutputType[P]>
        }
      >
    >


  export type ContactSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    importSource?: boolean
    totalContacts?: boolean
    createdAt?: boolean
    campaigns?: boolean | ContactSegment$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ContactSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactSegment"]>

  export type ContactSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    importSource?: boolean
    totalContacts?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactSegment"]>

  export type ContactSegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    importSource?: boolean
    totalContacts?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactSegment"]>

  export type ContactSegmentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    importSource?: boolean
    totalContacts?: boolean
    createdAt?: boolean
  }

  export type ContactSegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "importSource" | "totalContacts" | "createdAt", ExtArgs["result"]["contactSegment"]>
  export type ContactSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ContactSegment$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ContactSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactSegmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSegment"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string
      importSource: $Enums.ContactImportSource
      totalContacts: number
      createdAt: Date
    }, ExtArgs["result"]["contactSegment"]>
    composites: {}
  }

  type ContactSegmentGetPayload<S extends boolean | null | undefined | ContactSegmentDefaultArgs> = $Result.GetResult<Prisma.$ContactSegmentPayload, S>

  type ContactSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSegmentCountAggregateInputType | true
    }

  export interface ContactSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSegment'], meta: { name: 'ContactSegment' } }
    /**
     * Find zero or one ContactSegment that matches the filter.
     * @param {ContactSegmentFindUniqueArgs} args - Arguments to find a ContactSegment
     * @example
     * // Get one ContactSegment
     * const contactSegment = await prisma.contactSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSegmentFindUniqueArgs>(args: SelectSubset<T, ContactSegmentFindUniqueArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSegment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSegmentFindUniqueOrThrowArgs} args - Arguments to find a ContactSegment
     * @example
     * // Get one ContactSegment
     * const contactSegment = await prisma.contactSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentFindFirstArgs} args - Arguments to find a ContactSegment
     * @example
     * // Get one ContactSegment
     * const contactSegment = await prisma.contactSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSegmentFindFirstArgs>(args?: SelectSubset<T, ContactSegmentFindFirstArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentFindFirstOrThrowArgs} args - Arguments to find a ContactSegment
     * @example
     * // Get one ContactSegment
     * const contactSegment = await prisma.contactSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSegments
     * const contactSegments = await prisma.contactSegment.findMany()
     * 
     * // Get first 10 ContactSegments
     * const contactSegments = await prisma.contactSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSegmentWithIdOnly = await prisma.contactSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSegmentFindManyArgs>(args?: SelectSubset<T, ContactSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSegment.
     * @param {ContactSegmentCreateArgs} args - Arguments to create a ContactSegment.
     * @example
     * // Create one ContactSegment
     * const ContactSegment = await prisma.contactSegment.create({
     *   data: {
     *     // ... data to create a ContactSegment
     *   }
     * })
     * 
     */
    create<T extends ContactSegmentCreateArgs>(args: SelectSubset<T, ContactSegmentCreateArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSegments.
     * @param {ContactSegmentCreateManyArgs} args - Arguments to create many ContactSegments.
     * @example
     * // Create many ContactSegments
     * const contactSegment = await prisma.contactSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSegmentCreateManyArgs>(args?: SelectSubset<T, ContactSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSegments and returns the data saved in the database.
     * @param {ContactSegmentCreateManyAndReturnArgs} args - Arguments to create many ContactSegments.
     * @example
     * // Create many ContactSegments
     * const contactSegment = await prisma.contactSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSegments and only return the `id`
     * const contactSegmentWithIdOnly = await prisma.contactSegment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSegment.
     * @param {ContactSegmentDeleteArgs} args - Arguments to delete one ContactSegment.
     * @example
     * // Delete one ContactSegment
     * const ContactSegment = await prisma.contactSegment.delete({
     *   where: {
     *     // ... filter to delete one ContactSegment
     *   }
     * })
     * 
     */
    delete<T extends ContactSegmentDeleteArgs>(args: SelectSubset<T, ContactSegmentDeleteArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSegment.
     * @param {ContactSegmentUpdateArgs} args - Arguments to update one ContactSegment.
     * @example
     * // Update one ContactSegment
     * const contactSegment = await prisma.contactSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSegmentUpdateArgs>(args: SelectSubset<T, ContactSegmentUpdateArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSegments.
     * @param {ContactSegmentDeleteManyArgs} args - Arguments to filter ContactSegments to delete.
     * @example
     * // Delete a few ContactSegments
     * const { count } = await prisma.contactSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSegmentDeleteManyArgs>(args?: SelectSubset<T, ContactSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSegments
     * const contactSegment = await prisma.contactSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSegmentUpdateManyArgs>(args: SelectSubset<T, ContactSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSegments and returns the data updated in the database.
     * @param {ContactSegmentUpdateManyAndReturnArgs} args - Arguments to update many ContactSegments.
     * @example
     * // Update many ContactSegments
     * const contactSegment = await prisma.contactSegment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSegments and only return the `id`
     * const contactSegmentWithIdOnly = await prisma.contactSegment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSegment.
     * @param {ContactSegmentUpsertArgs} args - Arguments to update or create a ContactSegment.
     * @example
     * // Update or create a ContactSegment
     * const contactSegment = await prisma.contactSegment.upsert({
     *   create: {
     *     // ... data to create a ContactSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSegment we want to update
     *   }
     * })
     */
    upsert<T extends ContactSegmentUpsertArgs>(args: SelectSubset<T, ContactSegmentUpsertArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentCountArgs} args - Arguments to filter ContactSegments to count.
     * @example
     * // Count the number of ContactSegments
     * const count = await prisma.contactSegment.count({
     *   where: {
     *     // ... the filter for the ContactSegments we want to count
     *   }
     * })
    **/
    count<T extends ContactSegmentCountArgs>(
      args?: Subset<T, ContactSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSegmentAggregateArgs>(args: Subset<T, ContactSegmentAggregateArgs>): Prisma.PrismaPromise<GetContactSegmentAggregateType<T>>

    /**
     * Group by ContactSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSegmentGroupByArgs['orderBy'] }
        : { orderBy?: ContactSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSegment model
   */
  readonly fields: ContactSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends ContactSegment$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, ContactSegment$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSegment model
   */
  interface ContactSegmentFieldRefs {
    readonly id: FieldRef<"ContactSegment", 'String'>
    readonly userId: FieldRef<"ContactSegment", 'String'>
    readonly name: FieldRef<"ContactSegment", 'String'>
    readonly description: FieldRef<"ContactSegment", 'String'>
    readonly importSource: FieldRef<"ContactSegment", 'ContactImportSource'>
    readonly totalContacts: FieldRef<"ContactSegment", 'Int'>
    readonly createdAt: FieldRef<"ContactSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactSegment findUnique
   */
  export type ContactSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter, which ContactSegment to fetch.
     */
    where: ContactSegmentWhereUniqueInput
  }

  /**
   * ContactSegment findUniqueOrThrow
   */
  export type ContactSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter, which ContactSegment to fetch.
     */
    where: ContactSegmentWhereUniqueInput
  }

  /**
   * ContactSegment findFirst
   */
  export type ContactSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter, which ContactSegment to fetch.
     */
    where?: ContactSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSegments to fetch.
     */
    orderBy?: ContactSegmentOrderByWithRelationInput | ContactSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSegments.
     */
    cursor?: ContactSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSegments.
     */
    distinct?: ContactSegmentScalarFieldEnum | ContactSegmentScalarFieldEnum[]
  }

  /**
   * ContactSegment findFirstOrThrow
   */
  export type ContactSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter, which ContactSegment to fetch.
     */
    where?: ContactSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSegments to fetch.
     */
    orderBy?: ContactSegmentOrderByWithRelationInput | ContactSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSegments.
     */
    cursor?: ContactSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSegments.
     */
    distinct?: ContactSegmentScalarFieldEnum | ContactSegmentScalarFieldEnum[]
  }

  /**
   * ContactSegment findMany
   */
  export type ContactSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter, which ContactSegments to fetch.
     */
    where?: ContactSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSegments to fetch.
     */
    orderBy?: ContactSegmentOrderByWithRelationInput | ContactSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSegments.
     */
    cursor?: ContactSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSegments.
     */
    skip?: number
    distinct?: ContactSegmentScalarFieldEnum | ContactSegmentScalarFieldEnum[]
  }

  /**
   * ContactSegment create
   */
  export type ContactSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactSegment.
     */
    data: XOR<ContactSegmentCreateInput, ContactSegmentUncheckedCreateInput>
  }

  /**
   * ContactSegment createMany
   */
  export type ContactSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSegments.
     */
    data: ContactSegmentCreateManyInput | ContactSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSegment createManyAndReturn
   */
  export type ContactSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSegments.
     */
    data: ContactSegmentCreateManyInput | ContactSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactSegment update
   */
  export type ContactSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactSegment.
     */
    data: XOR<ContactSegmentUpdateInput, ContactSegmentUncheckedUpdateInput>
    /**
     * Choose, which ContactSegment to update.
     */
    where: ContactSegmentWhereUniqueInput
  }

  /**
   * ContactSegment updateMany
   */
  export type ContactSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSegments.
     */
    data: XOR<ContactSegmentUpdateManyMutationInput, ContactSegmentUncheckedUpdateManyInput>
    /**
     * Filter which ContactSegments to update
     */
    where?: ContactSegmentWhereInput
    /**
     * Limit how many ContactSegments to update.
     */
    limit?: number
  }

  /**
   * ContactSegment updateManyAndReturn
   */
  export type ContactSegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * The data used to update ContactSegments.
     */
    data: XOR<ContactSegmentUpdateManyMutationInput, ContactSegmentUncheckedUpdateManyInput>
    /**
     * Filter which ContactSegments to update
     */
    where?: ContactSegmentWhereInput
    /**
     * Limit how many ContactSegments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactSegment upsert
   */
  export type ContactSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactSegment to update in case it exists.
     */
    where: ContactSegmentWhereUniqueInput
    /**
     * In case the ContactSegment found by the `where` argument doesn't exist, create a new ContactSegment with this data.
     */
    create: XOR<ContactSegmentCreateInput, ContactSegmentUncheckedCreateInput>
    /**
     * In case the ContactSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSegmentUpdateInput, ContactSegmentUncheckedUpdateInput>
  }

  /**
   * ContactSegment delete
   */
  export type ContactSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
    /**
     * Filter which ContactSegment to delete.
     */
    where: ContactSegmentWhereUniqueInput
  }

  /**
   * ContactSegment deleteMany
   */
  export type ContactSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSegments to delete
     */
    where?: ContactSegmentWhereInput
    /**
     * Limit how many ContactSegments to delete.
     */
    limit?: number
  }

  /**
   * ContactSegment.campaigns
   */
  export type ContactSegment$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * ContactSegment without action
   */
  export type ContactSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSegment
     */
    select?: ContactSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSegment
     */
    omit?: ContactSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactSegmentInclude<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    mediaUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    mediaUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    variables: number
    mediaUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    mediaUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    mediaUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    variables?: true
    mediaUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    userId: string
    title: string
    body: string
    variables: string[]
    mediaUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    variables?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | MessageTemplate$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MessageTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    variables?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    variables?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    variables?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "variables" | "mediaUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["messageTemplate"]>
  export type MessageTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | MessageTemplate$campaignsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MessageTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      body: string
      variables: string[]
      mediaUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {MessageTemplateCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates and returns the data updated in the database.
     * @param {MessageTemplateUpdateManyAndReturnArgs} args - Arguments to update many MessageTemplates.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends MessageTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, MessageTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly userId: FieldRef<"MessageTemplate", 'String'>
    readonly title: FieldRef<"MessageTemplate", 'String'>
    readonly body: FieldRef<"MessageTemplate", 'String'>
    readonly variables: FieldRef<"MessageTemplate", 'String[]'>
    readonly mediaUrl: FieldRef<"MessageTemplate", 'String'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate createManyAndReturn
   */
  export type MessageTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to update.
     */
    limit?: number
  }

  /**
   * MessageTemplate updateManyAndReturn
   */
  export type MessageTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
    /**
     * Limit how many MessageTemplates to delete.
     */
    limit?: number
  }

  /**
   * MessageTemplate.campaigns
   */
  export type MessageTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageTemplate
     */
    omit?: MessageTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    maxMessagesPerMinute: number | null
  }

  export type CampaignSumAggregateOutputType = {
    maxMessagesPerMinute: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    userId: string | null
    evolutionConfigId: string | null
    name: string | null
    description: string | null
    channel: $Enums.CampaignChannel | null
    status: $Enums.CampaignStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    segmentId: string | null
    templateId: string | null
    externalId: string | null
    maxMessagesPerMinute: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    evolutionConfigId: string | null
    name: string | null
    description: string | null
    channel: $Enums.CampaignChannel | null
    status: $Enums.CampaignStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    segmentId: string | null
    templateId: string | null
    externalId: string | null
    maxMessagesPerMinute: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    userId: number
    evolutionConfigId: number
    name: number
    description: number
    channel: number
    status: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    segmentId: number
    templateId: number
    externalId: number
    maxMessagesPerMinute: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    maxMessagesPerMinute?: true
  }

  export type CampaignSumAggregateInputType = {
    maxMessagesPerMinute?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    userId?: true
    evolutionConfigId?: true
    name?: true
    description?: true
    channel?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    segmentId?: true
    templateId?: true
    externalId?: true
    maxMessagesPerMinute?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    userId?: true
    evolutionConfigId?: true
    name?: true
    description?: true
    channel?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    segmentId?: true
    templateId?: true
    externalId?: true
    maxMessagesPerMinute?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    userId?: true
    evolutionConfigId?: true
    name?: true
    description?: true
    channel?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    segmentId?: true
    templateId?: true
    externalId?: true
    maxMessagesPerMinute?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    userId: string
    evolutionConfigId: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    segmentId: string
    templateId: string
    externalId: string | null
    maxMessagesPerMinute: number
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    evolutionConfigId?: boolean
    name?: boolean
    description?: boolean
    channel?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    segmentId?: boolean
    templateId?: boolean
    externalId?: boolean
    maxMessagesPerMinute?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    runs?: boolean | Campaign$runsArgs<ExtArgs>
    timeline?: boolean | Campaign$timelineArgs<ExtArgs>
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    evolutionConfigId?: boolean
    name?: boolean
    description?: boolean
    channel?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    segmentId?: boolean
    templateId?: boolean
    externalId?: boolean
    maxMessagesPerMinute?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    evolutionConfigId?: boolean
    name?: boolean
    description?: boolean
    channel?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    segmentId?: boolean
    templateId?: boolean
    externalId?: boolean
    maxMessagesPerMinute?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    userId?: boolean
    evolutionConfigId?: boolean
    name?: boolean
    description?: boolean
    channel?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    segmentId?: boolean
    templateId?: boolean
    externalId?: boolean
    maxMessagesPerMinute?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "evolutionConfigId" | "name" | "description" | "channel" | "status" | "scheduledAt" | "startedAt" | "completedAt" | "segmentId" | "templateId" | "externalId" | "maxMessagesPerMinute" | "createdAt" | "updatedAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    runs?: boolean | Campaign$runsArgs<ExtArgs>
    timeline?: boolean | Campaign$timelineArgs<ExtArgs>
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolutionConfig?: boolean | Campaign$evolutionConfigArgs<ExtArgs>
    segment?: boolean | ContactSegmentDefaultArgs<ExtArgs>
    template?: boolean | MessageTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      metrics: Prisma.$CampaignMetricsPayload<ExtArgs> | null
      runs: Prisma.$CampaignRunPayload<ExtArgs>[]
      timeline: Prisma.$CampaignTimelinePointPayload<ExtArgs>[]
      evolutionConfig: Prisma.$EvolutionApiConfigPayload<ExtArgs> | null
      segment: Prisma.$ContactSegmentPayload<ExtArgs>
      template: Prisma.$MessageTemplatePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      evolutionConfigId: string | null
      name: string
      description: string
      channel: $Enums.CampaignChannel
      status: $Enums.CampaignStatus
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      segmentId: string
      templateId: string
      externalId: string | null
      maxMessagesPerMinute: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    metrics<T extends Campaign$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$metricsArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    runs<T extends Campaign$runsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeline<T extends Campaign$timelineArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$timelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolutionConfig<T extends Campaign$evolutionConfigArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$evolutionConfigArgs<ExtArgs>>): Prisma__EvolutionApiConfigClient<$Result.GetResult<Prisma.$EvolutionApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    segment<T extends ContactSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactSegmentDefaultArgs<ExtArgs>>): Prisma__ContactSegmentClient<$Result.GetResult<Prisma.$ContactSegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends MessageTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageTemplateDefaultArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly evolutionConfigId: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly channel: FieldRef<"Campaign", 'CampaignChannel'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly scheduledAt: FieldRef<"Campaign", 'DateTime'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly segmentId: FieldRef<"Campaign", 'String'>
    readonly templateId: FieldRef<"Campaign", 'String'>
    readonly externalId: FieldRef<"Campaign", 'String'>
    readonly maxMessagesPerMinute: FieldRef<"Campaign", 'Int'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.metrics
   */
  export type Campaign$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    where?: CampaignMetricsWhereInput
  }

  /**
   * Campaign.runs
   */
  export type Campaign$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    where?: CampaignRunWhereInput
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    cursor?: CampaignRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignRunScalarFieldEnum | CampaignRunScalarFieldEnum[]
  }

  /**
   * Campaign.timeline
   */
  export type Campaign$timelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    where?: CampaignTimelinePointWhereInput
    orderBy?: CampaignTimelinePointOrderByWithRelationInput | CampaignTimelinePointOrderByWithRelationInput[]
    cursor?: CampaignTimelinePointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTimelinePointScalarFieldEnum | CampaignTimelinePointScalarFieldEnum[]
  }

  /**
   * Campaign.evolutionConfig
   */
  export type Campaign$evolutionConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionApiConfig
     */
    select?: EvolutionApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionApiConfig
     */
    omit?: EvolutionApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionApiConfigInclude<ExtArgs> | null
    where?: EvolutionApiConfigWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignRun
   */

  export type AggregateCampaignRun = {
    _count: CampaignRunCountAggregateOutputType | null
    _min: CampaignRunMinAggregateOutputType | null
    _max: CampaignRunMaxAggregateOutputType | null
  }

  export type CampaignRunMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    initiatedBy: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.CampaignStatus | null
    summary: string | null
  }

  export type CampaignRunMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    initiatedBy: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.CampaignStatus | null
    summary: string | null
  }

  export type CampaignRunCountAggregateOutputType = {
    id: number
    campaignId: number
    initiatedBy: number
    startedAt: number
    endedAt: number
    status: number
    summary: number
    _all: number
  }


  export type CampaignRunMinAggregateInputType = {
    id?: true
    campaignId?: true
    initiatedBy?: true
    startedAt?: true
    endedAt?: true
    status?: true
    summary?: true
  }

  export type CampaignRunMaxAggregateInputType = {
    id?: true
    campaignId?: true
    initiatedBy?: true
    startedAt?: true
    endedAt?: true
    status?: true
    summary?: true
  }

  export type CampaignRunCountAggregateInputType = {
    id?: true
    campaignId?: true
    initiatedBy?: true
    startedAt?: true
    endedAt?: true
    status?: true
    summary?: true
    _all?: true
  }

  export type CampaignRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRun to aggregate.
     */
    where?: CampaignRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRuns to fetch.
     */
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignRuns
    **/
    _count?: true | CampaignRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignRunMaxAggregateInputType
  }

  export type GetCampaignRunAggregateType<T extends CampaignRunAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignRun[P]>
      : GetScalarType<T[P], AggregateCampaignRun[P]>
  }




  export type CampaignRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRunWhereInput
    orderBy?: CampaignRunOrderByWithAggregationInput | CampaignRunOrderByWithAggregationInput[]
    by: CampaignRunScalarFieldEnum[] | CampaignRunScalarFieldEnum
    having?: CampaignRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignRunCountAggregateInputType | true
    _min?: CampaignRunMinAggregateInputType
    _max?: CampaignRunMaxAggregateInputType
  }

  export type CampaignRunGroupByOutputType = {
    id: string
    campaignId: string
    initiatedBy: string
    startedAt: Date
    endedAt: Date | null
    status: $Enums.CampaignStatus
    summary: string | null
    _count: CampaignRunCountAggregateOutputType | null
    _min: CampaignRunMinAggregateOutputType | null
    _max: CampaignRunMaxAggregateOutputType | null
  }

  type GetCampaignRunGroupByPayload<T extends CampaignRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignRunGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignRunGroupByOutputType[P]>
        }
      >
    >


  export type CampaignRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    initiatedBy?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    summary?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRun"]>

  export type CampaignRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    initiatedBy?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    summary?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRun"]>

  export type CampaignRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    initiatedBy?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    summary?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRun"]>

  export type CampaignRunSelectScalar = {
    id?: boolean
    campaignId?: boolean
    initiatedBy?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    summary?: boolean
  }

  export type CampaignRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "initiatedBy" | "startedAt" | "endedAt" | "status" | "summary", ExtArgs["result"]["campaignRun"]>
  export type CampaignRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignRun"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      initiator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      initiatedBy: string
      startedAt: Date
      endedAt: Date | null
      status: $Enums.CampaignStatus
      summary: string | null
    }, ExtArgs["result"]["campaignRun"]>
    composites: {}
  }

  type CampaignRunGetPayload<S extends boolean | null | undefined | CampaignRunDefaultArgs> = $Result.GetResult<Prisma.$CampaignRunPayload, S>

  type CampaignRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignRunCountAggregateInputType | true
    }

  export interface CampaignRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignRun'], meta: { name: 'CampaignRun' } }
    /**
     * Find zero or one CampaignRun that matches the filter.
     * @param {CampaignRunFindUniqueArgs} args - Arguments to find a CampaignRun
     * @example
     * // Get one CampaignRun
     * const campaignRun = await prisma.campaignRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignRunFindUniqueArgs>(args: SelectSubset<T, CampaignRunFindUniqueArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignRunFindUniqueOrThrowArgs} args - Arguments to find a CampaignRun
     * @example
     * // Get one CampaignRun
     * const campaignRun = await prisma.campaignRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignRunFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunFindFirstArgs} args - Arguments to find a CampaignRun
     * @example
     * // Get one CampaignRun
     * const campaignRun = await prisma.campaignRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignRunFindFirstArgs>(args?: SelectSubset<T, CampaignRunFindFirstArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunFindFirstOrThrowArgs} args - Arguments to find a CampaignRun
     * @example
     * // Get one CampaignRun
     * const campaignRun = await prisma.campaignRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignRunFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignRuns
     * const campaignRuns = await prisma.campaignRun.findMany()
     * 
     * // Get first 10 CampaignRuns
     * const campaignRuns = await prisma.campaignRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignRunWithIdOnly = await prisma.campaignRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignRunFindManyArgs>(args?: SelectSubset<T, CampaignRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignRun.
     * @param {CampaignRunCreateArgs} args - Arguments to create a CampaignRun.
     * @example
     * // Create one CampaignRun
     * const CampaignRun = await prisma.campaignRun.create({
     *   data: {
     *     // ... data to create a CampaignRun
     *   }
     * })
     * 
     */
    create<T extends CampaignRunCreateArgs>(args: SelectSubset<T, CampaignRunCreateArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignRuns.
     * @param {CampaignRunCreateManyArgs} args - Arguments to create many CampaignRuns.
     * @example
     * // Create many CampaignRuns
     * const campaignRun = await prisma.campaignRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignRunCreateManyArgs>(args?: SelectSubset<T, CampaignRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignRuns and returns the data saved in the database.
     * @param {CampaignRunCreateManyAndReturnArgs} args - Arguments to create many CampaignRuns.
     * @example
     * // Create many CampaignRuns
     * const campaignRun = await prisma.campaignRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignRuns and only return the `id`
     * const campaignRunWithIdOnly = await prisma.campaignRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignRunCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignRun.
     * @param {CampaignRunDeleteArgs} args - Arguments to delete one CampaignRun.
     * @example
     * // Delete one CampaignRun
     * const CampaignRun = await prisma.campaignRun.delete({
     *   where: {
     *     // ... filter to delete one CampaignRun
     *   }
     * })
     * 
     */
    delete<T extends CampaignRunDeleteArgs>(args: SelectSubset<T, CampaignRunDeleteArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignRun.
     * @param {CampaignRunUpdateArgs} args - Arguments to update one CampaignRun.
     * @example
     * // Update one CampaignRun
     * const campaignRun = await prisma.campaignRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignRunUpdateArgs>(args: SelectSubset<T, CampaignRunUpdateArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignRuns.
     * @param {CampaignRunDeleteManyArgs} args - Arguments to filter CampaignRuns to delete.
     * @example
     * // Delete a few CampaignRuns
     * const { count } = await prisma.campaignRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignRunDeleteManyArgs>(args?: SelectSubset<T, CampaignRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignRuns
     * const campaignRun = await prisma.campaignRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignRunUpdateManyArgs>(args: SelectSubset<T, CampaignRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignRuns and returns the data updated in the database.
     * @param {CampaignRunUpdateManyAndReturnArgs} args - Arguments to update many CampaignRuns.
     * @example
     * // Update many CampaignRuns
     * const campaignRun = await prisma.campaignRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignRuns and only return the `id`
     * const campaignRunWithIdOnly = await prisma.campaignRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignRunUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignRun.
     * @param {CampaignRunUpsertArgs} args - Arguments to update or create a CampaignRun.
     * @example
     * // Update or create a CampaignRun
     * const campaignRun = await prisma.campaignRun.upsert({
     *   create: {
     *     // ... data to create a CampaignRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignRun we want to update
     *   }
     * })
     */
    upsert<T extends CampaignRunUpsertArgs>(args: SelectSubset<T, CampaignRunUpsertArgs<ExtArgs>>): Prisma__CampaignRunClient<$Result.GetResult<Prisma.$CampaignRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunCountArgs} args - Arguments to filter CampaignRuns to count.
     * @example
     * // Count the number of CampaignRuns
     * const count = await prisma.campaignRun.count({
     *   where: {
     *     // ... the filter for the CampaignRuns we want to count
     *   }
     * })
    **/
    count<T extends CampaignRunCountArgs>(
      args?: Subset<T, CampaignRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignRunAggregateArgs>(args: Subset<T, CampaignRunAggregateArgs>): Prisma.PrismaPromise<GetCampaignRunAggregateType<T>>

    /**
     * Group by CampaignRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignRunGroupByArgs['orderBy'] }
        : { orderBy?: CampaignRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignRun model
   */
  readonly fields: CampaignRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    initiator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignRun model
   */
  interface CampaignRunFieldRefs {
    readonly id: FieldRef<"CampaignRun", 'String'>
    readonly campaignId: FieldRef<"CampaignRun", 'String'>
    readonly initiatedBy: FieldRef<"CampaignRun", 'String'>
    readonly startedAt: FieldRef<"CampaignRun", 'DateTime'>
    readonly endedAt: FieldRef<"CampaignRun", 'DateTime'>
    readonly status: FieldRef<"CampaignRun", 'CampaignStatus'>
    readonly summary: FieldRef<"CampaignRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignRun findUnique
   */
  export type CampaignRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRun to fetch.
     */
    where: CampaignRunWhereUniqueInput
  }

  /**
   * CampaignRun findUniqueOrThrow
   */
  export type CampaignRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRun to fetch.
     */
    where: CampaignRunWhereUniqueInput
  }

  /**
   * CampaignRun findFirst
   */
  export type CampaignRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRun to fetch.
     */
    where?: CampaignRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRuns to fetch.
     */
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRuns.
     */
    cursor?: CampaignRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRuns.
     */
    distinct?: CampaignRunScalarFieldEnum | CampaignRunScalarFieldEnum[]
  }

  /**
   * CampaignRun findFirstOrThrow
   */
  export type CampaignRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRun to fetch.
     */
    where?: CampaignRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRuns to fetch.
     */
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRuns.
     */
    cursor?: CampaignRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRuns.
     */
    distinct?: CampaignRunScalarFieldEnum | CampaignRunScalarFieldEnum[]
  }

  /**
   * CampaignRun findMany
   */
  export type CampaignRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRuns to fetch.
     */
    where?: CampaignRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRuns to fetch.
     */
    orderBy?: CampaignRunOrderByWithRelationInput | CampaignRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignRuns.
     */
    cursor?: CampaignRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRuns.
     */
    skip?: number
    distinct?: CampaignRunScalarFieldEnum | CampaignRunScalarFieldEnum[]
  }

  /**
   * CampaignRun create
   */
  export type CampaignRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignRun.
     */
    data: XOR<CampaignRunCreateInput, CampaignRunUncheckedCreateInput>
  }

  /**
   * CampaignRun createMany
   */
  export type CampaignRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignRuns.
     */
    data: CampaignRunCreateManyInput | CampaignRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignRun createManyAndReturn
   */
  export type CampaignRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignRuns.
     */
    data: CampaignRunCreateManyInput | CampaignRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignRun update
   */
  export type CampaignRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignRun.
     */
    data: XOR<CampaignRunUpdateInput, CampaignRunUncheckedUpdateInput>
    /**
     * Choose, which CampaignRun to update.
     */
    where: CampaignRunWhereUniqueInput
  }

  /**
   * CampaignRun updateMany
   */
  export type CampaignRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignRuns.
     */
    data: XOR<CampaignRunUpdateManyMutationInput, CampaignRunUncheckedUpdateManyInput>
    /**
     * Filter which CampaignRuns to update
     */
    where?: CampaignRunWhereInput
    /**
     * Limit how many CampaignRuns to update.
     */
    limit?: number
  }

  /**
   * CampaignRun updateManyAndReturn
   */
  export type CampaignRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * The data used to update CampaignRuns.
     */
    data: XOR<CampaignRunUpdateManyMutationInput, CampaignRunUncheckedUpdateManyInput>
    /**
     * Filter which CampaignRuns to update
     */
    where?: CampaignRunWhereInput
    /**
     * Limit how many CampaignRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignRun upsert
   */
  export type CampaignRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignRun to update in case it exists.
     */
    where: CampaignRunWhereUniqueInput
    /**
     * In case the CampaignRun found by the `where` argument doesn't exist, create a new CampaignRun with this data.
     */
    create: XOR<CampaignRunCreateInput, CampaignRunUncheckedCreateInput>
    /**
     * In case the CampaignRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignRunUpdateInput, CampaignRunUncheckedUpdateInput>
  }

  /**
   * CampaignRun delete
   */
  export type CampaignRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
    /**
     * Filter which CampaignRun to delete.
     */
    where: CampaignRunWhereUniqueInput
  }

  /**
   * CampaignRun deleteMany
   */
  export type CampaignRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRuns to delete
     */
    where?: CampaignRunWhereInput
    /**
     * Limit how many CampaignRuns to delete.
     */
    limit?: number
  }

  /**
   * CampaignRun without action
   */
  export type CampaignRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRun
     */
    select?: CampaignRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignRun
     */
    omit?: CampaignRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRunInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMetrics
   */

  export type AggregateCampaignMetrics = {
    _count: CampaignMetricsCountAggregateOutputType | null
    _avg: CampaignMetricsAvgAggregateOutputType | null
    _sum: CampaignMetricsSumAggregateOutputType | null
    _min: CampaignMetricsMinAggregateOutputType | null
    _max: CampaignMetricsMaxAggregateOutputType | null
  }

  export type CampaignMetricsAvgAggregateOutputType = {
    totalMessages: number | null
    delivered: number | null
    failed: number | null
    pending: number | null
    averageDeliveryMs: number | null
  }

  export type CampaignMetricsSumAggregateOutputType = {
    totalMessages: number | null
    delivered: number | null
    failed: number | null
    pending: number | null
    averageDeliveryMs: number | null
  }

  export type CampaignMetricsMinAggregateOutputType = {
    campaignId: string | null
    totalMessages: number | null
    delivered: number | null
    failed: number | null
    pending: number | null
    averageDeliveryMs: number | null
    lastUpdatedAt: Date | null
  }

  export type CampaignMetricsMaxAggregateOutputType = {
    campaignId: string | null
    totalMessages: number | null
    delivered: number | null
    failed: number | null
    pending: number | null
    averageDeliveryMs: number | null
    lastUpdatedAt: Date | null
  }

  export type CampaignMetricsCountAggregateOutputType = {
    campaignId: number
    totalMessages: number
    delivered: number
    failed: number
    pending: number
    averageDeliveryMs: number
    lastUpdatedAt: number
    _all: number
  }


  export type CampaignMetricsAvgAggregateInputType = {
    totalMessages?: true
    delivered?: true
    failed?: true
    pending?: true
    averageDeliveryMs?: true
  }

  export type CampaignMetricsSumAggregateInputType = {
    totalMessages?: true
    delivered?: true
    failed?: true
    pending?: true
    averageDeliveryMs?: true
  }

  export type CampaignMetricsMinAggregateInputType = {
    campaignId?: true
    totalMessages?: true
    delivered?: true
    failed?: true
    pending?: true
    averageDeliveryMs?: true
    lastUpdatedAt?: true
  }

  export type CampaignMetricsMaxAggregateInputType = {
    campaignId?: true
    totalMessages?: true
    delivered?: true
    failed?: true
    pending?: true
    averageDeliveryMs?: true
    lastUpdatedAt?: true
  }

  export type CampaignMetricsCountAggregateInputType = {
    campaignId?: true
    totalMessages?: true
    delivered?: true
    failed?: true
    pending?: true
    averageDeliveryMs?: true
    lastUpdatedAt?: true
    _all?: true
  }

  export type CampaignMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetrics to aggregate.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMetrics
    **/
    _count?: true | CampaignMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMetricsMaxAggregateInputType
  }

  export type GetCampaignMetricsAggregateType<T extends CampaignMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMetrics[P]>
      : GetScalarType<T[P], AggregateCampaignMetrics[P]>
  }




  export type CampaignMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMetricsWhereInput
    orderBy?: CampaignMetricsOrderByWithAggregationInput | CampaignMetricsOrderByWithAggregationInput[]
    by: CampaignMetricsScalarFieldEnum[] | CampaignMetricsScalarFieldEnum
    having?: CampaignMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMetricsCountAggregateInputType | true
    _avg?: CampaignMetricsAvgAggregateInputType
    _sum?: CampaignMetricsSumAggregateInputType
    _min?: CampaignMetricsMinAggregateInputType
    _max?: CampaignMetricsMaxAggregateInputType
  }

  export type CampaignMetricsGroupByOutputType = {
    campaignId: string
    totalMessages: number
    delivered: number
    failed: number
    pending: number
    averageDeliveryMs: number
    lastUpdatedAt: Date
    _count: CampaignMetricsCountAggregateOutputType | null
    _avg: CampaignMetricsAvgAggregateOutputType | null
    _sum: CampaignMetricsSumAggregateOutputType | null
    _min: CampaignMetricsMinAggregateOutputType | null
    _max: CampaignMetricsMaxAggregateOutputType | null
  }

  type GetCampaignMetricsGroupByPayload<T extends CampaignMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMetricsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    totalMessages?: boolean
    delivered?: boolean
    failed?: boolean
    pending?: boolean
    averageDeliveryMs?: boolean
    lastUpdatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    totalMessages?: boolean
    delivered?: boolean
    failed?: boolean
    pending?: boolean
    averageDeliveryMs?: boolean
    lastUpdatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    totalMessages?: boolean
    delivered?: boolean
    failed?: boolean
    pending?: boolean
    averageDeliveryMs?: boolean
    lastUpdatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectScalar = {
    campaignId?: boolean
    totalMessages?: boolean
    delivered?: boolean
    failed?: boolean
    pending?: boolean
    averageDeliveryMs?: boolean
    lastUpdatedAt?: boolean
  }

  export type CampaignMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"campaignId" | "totalMessages" | "delivered" | "failed" | "pending" | "averageDeliveryMs" | "lastUpdatedAt", ExtArgs["result"]["campaignMetrics"]>
  export type CampaignMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMetrics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      campaignId: string
      totalMessages: number
      delivered: number
      failed: number
      pending: number
      averageDeliveryMs: number
      lastUpdatedAt: Date
    }, ExtArgs["result"]["campaignMetrics"]>
    composites: {}
  }

  type CampaignMetricsGetPayload<S extends boolean | null | undefined | CampaignMetricsDefaultArgs> = $Result.GetResult<Prisma.$CampaignMetricsPayload, S>

  type CampaignMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignMetricsCountAggregateInputType | true
    }

  export interface CampaignMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMetrics'], meta: { name: 'CampaignMetrics' } }
    /**
     * Find zero or one CampaignMetrics that matches the filter.
     * @param {CampaignMetricsFindUniqueArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMetricsFindUniqueArgs>(args: SelectSubset<T, CampaignMetricsFindUniqueArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignMetricsFindUniqueOrThrowArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindFirstArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMetricsFindFirstArgs>(args?: SelectSubset<T, CampaignMetricsFindFirstArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindFirstOrThrowArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findMany()
     * 
     * // Get first 10 CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findMany({ take: 10 })
     * 
     * // Only select the `campaignId`
     * const campaignMetricsWithCampaignIdOnly = await prisma.campaignMetrics.findMany({ select: { campaignId: true } })
     * 
     */
    findMany<T extends CampaignMetricsFindManyArgs>(args?: SelectSubset<T, CampaignMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignMetrics.
     * @param {CampaignMetricsCreateArgs} args - Arguments to create a CampaignMetrics.
     * @example
     * // Create one CampaignMetrics
     * const CampaignMetrics = await prisma.campaignMetrics.create({
     *   data: {
     *     // ... data to create a CampaignMetrics
     *   }
     * })
     * 
     */
    create<T extends CampaignMetricsCreateArgs>(args: SelectSubset<T, CampaignMetricsCreateArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignMetrics.
     * @param {CampaignMetricsCreateManyArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMetricsCreateManyArgs>(args?: SelectSubset<T, CampaignMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMetrics and returns the data saved in the database.
     * @param {CampaignMetricsCreateManyAndReturnArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMetrics and only return the `campaignId`
     * const campaignMetricsWithCampaignIdOnly = await prisma.campaignMetrics.createManyAndReturn({
     *   select: { campaignId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignMetrics.
     * @param {CampaignMetricsDeleteArgs} args - Arguments to delete one CampaignMetrics.
     * @example
     * // Delete one CampaignMetrics
     * const CampaignMetrics = await prisma.campaignMetrics.delete({
     *   where: {
     *     // ... filter to delete one CampaignMetrics
     *   }
     * })
     * 
     */
    delete<T extends CampaignMetricsDeleteArgs>(args: SelectSubset<T, CampaignMetricsDeleteArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignMetrics.
     * @param {CampaignMetricsUpdateArgs} args - Arguments to update one CampaignMetrics.
     * @example
     * // Update one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMetricsUpdateArgs>(args: SelectSubset<T, CampaignMetricsUpdateArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignMetrics.
     * @param {CampaignMetricsDeleteManyArgs} args - Arguments to filter CampaignMetrics to delete.
     * @example
     * // Delete a few CampaignMetrics
     * const { count } = await prisma.campaignMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMetricsDeleteManyArgs>(args?: SelectSubset<T, CampaignMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMetricsUpdateManyArgs>(args: SelectSubset<T, CampaignMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMetrics and returns the data updated in the database.
     * @param {CampaignMetricsUpdateManyAndReturnArgs} args - Arguments to update many CampaignMetrics.
     * @example
     * // Update many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignMetrics and only return the `campaignId`
     * const campaignMetricsWithCampaignIdOnly = await prisma.campaignMetrics.updateManyAndReturn({
     *   select: { campaignId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignMetrics.
     * @param {CampaignMetricsUpsertArgs} args - Arguments to update or create a CampaignMetrics.
     * @example
     * // Update or create a CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.upsert({
     *   create: {
     *     // ... data to create a CampaignMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMetrics we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMetricsUpsertArgs>(args: SelectSubset<T, CampaignMetricsUpsertArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsCountArgs} args - Arguments to filter CampaignMetrics to count.
     * @example
     * // Count the number of CampaignMetrics
     * const count = await prisma.campaignMetrics.count({
     *   where: {
     *     // ... the filter for the CampaignMetrics we want to count
     *   }
     * })
    **/
    count<T extends CampaignMetricsCountArgs>(
      args?: Subset<T, CampaignMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMetricsAggregateArgs>(args: Subset<T, CampaignMetricsAggregateArgs>): Prisma.PrismaPromise<GetCampaignMetricsAggregateType<T>>

    /**
     * Group by CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMetricsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMetrics model
   */
  readonly fields: CampaignMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMetrics model
   */
  interface CampaignMetricsFieldRefs {
    readonly campaignId: FieldRef<"CampaignMetrics", 'String'>
    readonly totalMessages: FieldRef<"CampaignMetrics", 'Int'>
    readonly delivered: FieldRef<"CampaignMetrics", 'Int'>
    readonly failed: FieldRef<"CampaignMetrics", 'Int'>
    readonly pending: FieldRef<"CampaignMetrics", 'Int'>
    readonly averageDeliveryMs: FieldRef<"CampaignMetrics", 'Int'>
    readonly lastUpdatedAt: FieldRef<"CampaignMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMetrics findUnique
   */
  export type CampaignMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics findUniqueOrThrow
   */
  export type CampaignMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics findFirst
   */
  export type CampaignMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics findFirstOrThrow
   */
  export type CampaignMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics findMany
   */
  export type CampaignMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics create
   */
  export type CampaignMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMetrics.
     */
    data: XOR<CampaignMetricsCreateInput, CampaignMetricsUncheckedCreateInput>
  }

  /**
   * CampaignMetrics createMany
   */
  export type CampaignMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricsCreateManyInput | CampaignMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMetrics createManyAndReturn
   */
  export type CampaignMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricsCreateManyInput | CampaignMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMetrics update
   */
  export type CampaignMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateInput, CampaignMetricsUncheckedUpdateInput>
    /**
     * Choose, which CampaignMetrics to update.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics updateMany
   */
  export type CampaignMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateManyMutationInput, CampaignMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMetrics to update
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to update.
     */
    limit?: number
  }

  /**
   * CampaignMetrics updateManyAndReturn
   */
  export type CampaignMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * The data used to update CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateManyMutationInput, CampaignMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMetrics to update
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMetrics upsert
   */
  export type CampaignMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMetrics to update in case it exists.
     */
    where: CampaignMetricsWhereUniqueInput
    /**
     * In case the CampaignMetrics found by the `where` argument doesn't exist, create a new CampaignMetrics with this data.
     */
    create: XOR<CampaignMetricsCreateInput, CampaignMetricsUncheckedCreateInput>
    /**
     * In case the CampaignMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMetricsUpdateInput, CampaignMetricsUncheckedUpdateInput>
  }

  /**
   * CampaignMetrics delete
   */
  export type CampaignMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter which CampaignMetrics to delete.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics deleteMany
   */
  export type CampaignMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetrics to delete
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to delete.
     */
    limit?: number
  }

  /**
   * CampaignMetrics without action
   */
  export type CampaignMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
  }


  /**
   * Model CampaignTimelinePoint
   */

  export type AggregateCampaignTimelinePoint = {
    _count: CampaignTimelinePointCountAggregateOutputType | null
    _avg: CampaignTimelinePointAvgAggregateOutputType | null
    _sum: CampaignTimelinePointSumAggregateOutputType | null
    _min: CampaignTimelinePointMinAggregateOutputType | null
    _max: CampaignTimelinePointMaxAggregateOutputType | null
  }

  export type CampaignTimelinePointAvgAggregateOutputType = {
    delivered: number | null
    failed: number | null
  }

  export type CampaignTimelinePointSumAggregateOutputType = {
    delivered: number | null
    failed: number | null
  }

  export type CampaignTimelinePointMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    timestamp: Date | null
    delivered: number | null
    failed: number | null
  }

  export type CampaignTimelinePointMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    timestamp: Date | null
    delivered: number | null
    failed: number | null
  }

  export type CampaignTimelinePointCountAggregateOutputType = {
    id: number
    campaignId: number
    timestamp: number
    delivered: number
    failed: number
    _all: number
  }


  export type CampaignTimelinePointAvgAggregateInputType = {
    delivered?: true
    failed?: true
  }

  export type CampaignTimelinePointSumAggregateInputType = {
    delivered?: true
    failed?: true
  }

  export type CampaignTimelinePointMinAggregateInputType = {
    id?: true
    campaignId?: true
    timestamp?: true
    delivered?: true
    failed?: true
  }

  export type CampaignTimelinePointMaxAggregateInputType = {
    id?: true
    campaignId?: true
    timestamp?: true
    delivered?: true
    failed?: true
  }

  export type CampaignTimelinePointCountAggregateInputType = {
    id?: true
    campaignId?: true
    timestamp?: true
    delivered?: true
    failed?: true
    _all?: true
  }

  export type CampaignTimelinePointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTimelinePoint to aggregate.
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelinePoints to fetch.
     */
    orderBy?: CampaignTimelinePointOrderByWithRelationInput | CampaignTimelinePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignTimelinePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelinePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelinePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTimelinePoints
    **/
    _count?: true | CampaignTimelinePointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignTimelinePointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignTimelinePointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTimelinePointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTimelinePointMaxAggregateInputType
  }

  export type GetCampaignTimelinePointAggregateType<T extends CampaignTimelinePointAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignTimelinePoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignTimelinePoint[P]>
      : GetScalarType<T[P], AggregateCampaignTimelinePoint[P]>
  }




  export type CampaignTimelinePointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTimelinePointWhereInput
    orderBy?: CampaignTimelinePointOrderByWithAggregationInput | CampaignTimelinePointOrderByWithAggregationInput[]
    by: CampaignTimelinePointScalarFieldEnum[] | CampaignTimelinePointScalarFieldEnum
    having?: CampaignTimelinePointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTimelinePointCountAggregateInputType | true
    _avg?: CampaignTimelinePointAvgAggregateInputType
    _sum?: CampaignTimelinePointSumAggregateInputType
    _min?: CampaignTimelinePointMinAggregateInputType
    _max?: CampaignTimelinePointMaxAggregateInputType
  }

  export type CampaignTimelinePointGroupByOutputType = {
    id: string
    campaignId: string
    timestamp: Date
    delivered: number
    failed: number
    _count: CampaignTimelinePointCountAggregateOutputType | null
    _avg: CampaignTimelinePointAvgAggregateOutputType | null
    _sum: CampaignTimelinePointSumAggregateOutputType | null
    _min: CampaignTimelinePointMinAggregateOutputType | null
    _max: CampaignTimelinePointMaxAggregateOutputType | null
  }

  type GetCampaignTimelinePointGroupByPayload<T extends CampaignTimelinePointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignTimelinePointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTimelinePointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTimelinePointGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTimelinePointGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTimelinePointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    timestamp?: boolean
    delivered?: boolean
    failed?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTimelinePoint"]>

  export type CampaignTimelinePointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    timestamp?: boolean
    delivered?: boolean
    failed?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTimelinePoint"]>

  export type CampaignTimelinePointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    timestamp?: boolean
    delivered?: boolean
    failed?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTimelinePoint"]>

  export type CampaignTimelinePointSelectScalar = {
    id?: boolean
    campaignId?: boolean
    timestamp?: boolean
    delivered?: boolean
    failed?: boolean
  }

  export type CampaignTimelinePointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "timestamp" | "delivered" | "failed", ExtArgs["result"]["campaignTimelinePoint"]>
  export type CampaignTimelinePointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignTimelinePointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignTimelinePointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignTimelinePointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignTimelinePoint"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      timestamp: Date
      delivered: number
      failed: number
    }, ExtArgs["result"]["campaignTimelinePoint"]>
    composites: {}
  }

  type CampaignTimelinePointGetPayload<S extends boolean | null | undefined | CampaignTimelinePointDefaultArgs> = $Result.GetResult<Prisma.$CampaignTimelinePointPayload, S>

  type CampaignTimelinePointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignTimelinePointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignTimelinePointCountAggregateInputType | true
    }

  export interface CampaignTimelinePointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignTimelinePoint'], meta: { name: 'CampaignTimelinePoint' } }
    /**
     * Find zero or one CampaignTimelinePoint that matches the filter.
     * @param {CampaignTimelinePointFindUniqueArgs} args - Arguments to find a CampaignTimelinePoint
     * @example
     * // Get one CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignTimelinePointFindUniqueArgs>(args: SelectSubset<T, CampaignTimelinePointFindUniqueArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignTimelinePoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignTimelinePointFindUniqueOrThrowArgs} args - Arguments to find a CampaignTimelinePoint
     * @example
     * // Get one CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignTimelinePointFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignTimelinePointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignTimelinePoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointFindFirstArgs} args - Arguments to find a CampaignTimelinePoint
     * @example
     * // Get one CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignTimelinePointFindFirstArgs>(args?: SelectSubset<T, CampaignTimelinePointFindFirstArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignTimelinePoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointFindFirstOrThrowArgs} args - Arguments to find a CampaignTimelinePoint
     * @example
     * // Get one CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignTimelinePointFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignTimelinePointFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignTimelinePoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTimelinePoints
     * const campaignTimelinePoints = await prisma.campaignTimelinePoint.findMany()
     * 
     * // Get first 10 CampaignTimelinePoints
     * const campaignTimelinePoints = await prisma.campaignTimelinePoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTimelinePointWithIdOnly = await prisma.campaignTimelinePoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignTimelinePointFindManyArgs>(args?: SelectSubset<T, CampaignTimelinePointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignTimelinePoint.
     * @param {CampaignTimelinePointCreateArgs} args - Arguments to create a CampaignTimelinePoint.
     * @example
     * // Create one CampaignTimelinePoint
     * const CampaignTimelinePoint = await prisma.campaignTimelinePoint.create({
     *   data: {
     *     // ... data to create a CampaignTimelinePoint
     *   }
     * })
     * 
     */
    create<T extends CampaignTimelinePointCreateArgs>(args: SelectSubset<T, CampaignTimelinePointCreateArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignTimelinePoints.
     * @param {CampaignTimelinePointCreateManyArgs} args - Arguments to create many CampaignTimelinePoints.
     * @example
     * // Create many CampaignTimelinePoints
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignTimelinePointCreateManyArgs>(args?: SelectSubset<T, CampaignTimelinePointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignTimelinePoints and returns the data saved in the database.
     * @param {CampaignTimelinePointCreateManyAndReturnArgs} args - Arguments to create many CampaignTimelinePoints.
     * @example
     * // Create many CampaignTimelinePoints
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignTimelinePoints and only return the `id`
     * const campaignTimelinePointWithIdOnly = await prisma.campaignTimelinePoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignTimelinePointCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignTimelinePointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignTimelinePoint.
     * @param {CampaignTimelinePointDeleteArgs} args - Arguments to delete one CampaignTimelinePoint.
     * @example
     * // Delete one CampaignTimelinePoint
     * const CampaignTimelinePoint = await prisma.campaignTimelinePoint.delete({
     *   where: {
     *     // ... filter to delete one CampaignTimelinePoint
     *   }
     * })
     * 
     */
    delete<T extends CampaignTimelinePointDeleteArgs>(args: SelectSubset<T, CampaignTimelinePointDeleteArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignTimelinePoint.
     * @param {CampaignTimelinePointUpdateArgs} args - Arguments to update one CampaignTimelinePoint.
     * @example
     * // Update one CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignTimelinePointUpdateArgs>(args: SelectSubset<T, CampaignTimelinePointUpdateArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignTimelinePoints.
     * @param {CampaignTimelinePointDeleteManyArgs} args - Arguments to filter CampaignTimelinePoints to delete.
     * @example
     * // Delete a few CampaignTimelinePoints
     * const { count } = await prisma.campaignTimelinePoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignTimelinePointDeleteManyArgs>(args?: SelectSubset<T, CampaignTimelinePointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTimelinePoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTimelinePoints
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignTimelinePointUpdateManyArgs>(args: SelectSubset<T, CampaignTimelinePointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTimelinePoints and returns the data updated in the database.
     * @param {CampaignTimelinePointUpdateManyAndReturnArgs} args - Arguments to update many CampaignTimelinePoints.
     * @example
     * // Update many CampaignTimelinePoints
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignTimelinePoints and only return the `id`
     * const campaignTimelinePointWithIdOnly = await prisma.campaignTimelinePoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignTimelinePointUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignTimelinePointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignTimelinePoint.
     * @param {CampaignTimelinePointUpsertArgs} args - Arguments to update or create a CampaignTimelinePoint.
     * @example
     * // Update or create a CampaignTimelinePoint
     * const campaignTimelinePoint = await prisma.campaignTimelinePoint.upsert({
     *   create: {
     *     // ... data to create a CampaignTimelinePoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignTimelinePoint we want to update
     *   }
     * })
     */
    upsert<T extends CampaignTimelinePointUpsertArgs>(args: SelectSubset<T, CampaignTimelinePointUpsertArgs<ExtArgs>>): Prisma__CampaignTimelinePointClient<$Result.GetResult<Prisma.$CampaignTimelinePointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignTimelinePoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointCountArgs} args - Arguments to filter CampaignTimelinePoints to count.
     * @example
     * // Count the number of CampaignTimelinePoints
     * const count = await prisma.campaignTimelinePoint.count({
     *   where: {
     *     // ... the filter for the CampaignTimelinePoints we want to count
     *   }
     * })
    **/
    count<T extends CampaignTimelinePointCountArgs>(
      args?: Subset<T, CampaignTimelinePointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTimelinePointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignTimelinePoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTimelinePointAggregateArgs>(args: Subset<T, CampaignTimelinePointAggregateArgs>): Prisma.PrismaPromise<GetCampaignTimelinePointAggregateType<T>>

    /**
     * Group by CampaignTimelinePoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelinePointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTimelinePointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTimelinePointGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTimelinePointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTimelinePointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTimelinePointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignTimelinePoint model
   */
  readonly fields: CampaignTimelinePointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignTimelinePoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignTimelinePointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignTimelinePoint model
   */
  interface CampaignTimelinePointFieldRefs {
    readonly id: FieldRef<"CampaignTimelinePoint", 'String'>
    readonly campaignId: FieldRef<"CampaignTimelinePoint", 'String'>
    readonly timestamp: FieldRef<"CampaignTimelinePoint", 'DateTime'>
    readonly delivered: FieldRef<"CampaignTimelinePoint", 'Int'>
    readonly failed: FieldRef<"CampaignTimelinePoint", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CampaignTimelinePoint findUnique
   */
  export type CampaignTimelinePointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelinePoint to fetch.
     */
    where: CampaignTimelinePointWhereUniqueInput
  }

  /**
   * CampaignTimelinePoint findUniqueOrThrow
   */
  export type CampaignTimelinePointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelinePoint to fetch.
     */
    where: CampaignTimelinePointWhereUniqueInput
  }

  /**
   * CampaignTimelinePoint findFirst
   */
  export type CampaignTimelinePointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelinePoint to fetch.
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelinePoints to fetch.
     */
    orderBy?: CampaignTimelinePointOrderByWithRelationInput | CampaignTimelinePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTimelinePoints.
     */
    cursor?: CampaignTimelinePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelinePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelinePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTimelinePoints.
     */
    distinct?: CampaignTimelinePointScalarFieldEnum | CampaignTimelinePointScalarFieldEnum[]
  }

  /**
   * CampaignTimelinePoint findFirstOrThrow
   */
  export type CampaignTimelinePointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelinePoint to fetch.
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelinePoints to fetch.
     */
    orderBy?: CampaignTimelinePointOrderByWithRelationInput | CampaignTimelinePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTimelinePoints.
     */
    cursor?: CampaignTimelinePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelinePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelinePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTimelinePoints.
     */
    distinct?: CampaignTimelinePointScalarFieldEnum | CampaignTimelinePointScalarFieldEnum[]
  }

  /**
   * CampaignTimelinePoint findMany
   */
  export type CampaignTimelinePointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelinePoints to fetch.
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelinePoints to fetch.
     */
    orderBy?: CampaignTimelinePointOrderByWithRelationInput | CampaignTimelinePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTimelinePoints.
     */
    cursor?: CampaignTimelinePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelinePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelinePoints.
     */
    skip?: number
    distinct?: CampaignTimelinePointScalarFieldEnum | CampaignTimelinePointScalarFieldEnum[]
  }

  /**
   * CampaignTimelinePoint create
   */
  export type CampaignTimelinePointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignTimelinePoint.
     */
    data: XOR<CampaignTimelinePointCreateInput, CampaignTimelinePointUncheckedCreateInput>
  }

  /**
   * CampaignTimelinePoint createMany
   */
  export type CampaignTimelinePointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignTimelinePoints.
     */
    data: CampaignTimelinePointCreateManyInput | CampaignTimelinePointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignTimelinePoint createManyAndReturn
   */
  export type CampaignTimelinePointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignTimelinePoints.
     */
    data: CampaignTimelinePointCreateManyInput | CampaignTimelinePointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignTimelinePoint update
   */
  export type CampaignTimelinePointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignTimelinePoint.
     */
    data: XOR<CampaignTimelinePointUpdateInput, CampaignTimelinePointUncheckedUpdateInput>
    /**
     * Choose, which CampaignTimelinePoint to update.
     */
    where: CampaignTimelinePointWhereUniqueInput
  }

  /**
   * CampaignTimelinePoint updateMany
   */
  export type CampaignTimelinePointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignTimelinePoints.
     */
    data: XOR<CampaignTimelinePointUpdateManyMutationInput, CampaignTimelinePointUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTimelinePoints to update
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * Limit how many CampaignTimelinePoints to update.
     */
    limit?: number
  }

  /**
   * CampaignTimelinePoint updateManyAndReturn
   */
  export type CampaignTimelinePointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * The data used to update CampaignTimelinePoints.
     */
    data: XOR<CampaignTimelinePointUpdateManyMutationInput, CampaignTimelinePointUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTimelinePoints to update
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * Limit how many CampaignTimelinePoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignTimelinePoint upsert
   */
  export type CampaignTimelinePointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignTimelinePoint to update in case it exists.
     */
    where: CampaignTimelinePointWhereUniqueInput
    /**
     * In case the CampaignTimelinePoint found by the `where` argument doesn't exist, create a new CampaignTimelinePoint with this data.
     */
    create: XOR<CampaignTimelinePointCreateInput, CampaignTimelinePointUncheckedCreateInput>
    /**
     * In case the CampaignTimelinePoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignTimelinePointUpdateInput, CampaignTimelinePointUncheckedUpdateInput>
  }

  /**
   * CampaignTimelinePoint delete
   */
  export type CampaignTimelinePointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
    /**
     * Filter which CampaignTimelinePoint to delete.
     */
    where: CampaignTimelinePointWhereUniqueInput
  }

  /**
   * CampaignTimelinePoint deleteMany
   */
  export type CampaignTimelinePointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTimelinePoints to delete
     */
    where?: CampaignTimelinePointWhereInput
    /**
     * Limit how many CampaignTimelinePoints to delete.
     */
    limit?: number
  }

  /**
   * CampaignTimelinePoint without action
   */
  export type CampaignTimelinePointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimelinePoint
     */
    select?: CampaignTimelinePointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignTimelinePoint
     */
    omit?: CampaignTimelinePointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelinePointInclude<ExtArgs> | null
  }


  /**
   * Model ResourceCategory
   */

  export type AggregateResourceCategory = {
    _count: ResourceCategoryCountAggregateOutputType | null
    _avg: ResourceCategoryAvgAggregateOutputType | null
    _sum: ResourceCategorySumAggregateOutputType | null
    _min: ResourceCategoryMinAggregateOutputType | null
    _max: ResourceCategoryMaxAggregateOutputType | null
  }

  export type ResourceCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type ResourceCategorySumAggregateOutputType = {
    order: number | null
  }

  export type ResourceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ResourceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ResourceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    order: number
    createdAt: number
    _all: number
  }


  export type ResourceCategoryAvgAggregateInputType = {
    order?: true
  }

  export type ResourceCategorySumAggregateInputType = {
    order?: true
  }

  export type ResourceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
  }

  export type ResourceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
  }

  export type ResourceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ResourceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceCategory to aggregate.
     */
    where?: ResourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceCategories to fetch.
     */
    orderBy?: ResourceCategoryOrderByWithRelationInput | ResourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceCategories
    **/
    _count?: true | ResourceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceCategoryMaxAggregateInputType
  }

  export type GetResourceCategoryAggregateType<T extends ResourceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceCategory[P]>
      : GetScalarType<T[P], AggregateResourceCategory[P]>
  }




  export type ResourceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceCategoryWhereInput
    orderBy?: ResourceCategoryOrderByWithAggregationInput | ResourceCategoryOrderByWithAggregationInput[]
    by: ResourceCategoryScalarFieldEnum[] | ResourceCategoryScalarFieldEnum
    having?: ResourceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCategoryCountAggregateInputType | true
    _avg?: ResourceCategoryAvgAggregateInputType
    _sum?: ResourceCategorySumAggregateInputType
    _min?: ResourceCategoryMinAggregateInputType
    _max?: ResourceCategoryMaxAggregateInputType
  }

  export type ResourceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string
    icon: string
    order: number
    createdAt: Date
    _count: ResourceCategoryCountAggregateOutputType | null
    _avg: ResourceCategoryAvgAggregateOutputType | null
    _sum: ResourceCategorySumAggregateOutputType | null
    _min: ResourceCategoryMinAggregateOutputType | null
    _max: ResourceCategoryMaxAggregateOutputType | null
  }

  type GetResourceCategoryGroupByPayload<T extends ResourceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ResourceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
    resources?: boolean | ResourceCategory$resourcesArgs<ExtArgs>
    _count?: boolean | ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceCategory"]>

  export type ResourceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resourceCategory"]>

  export type ResourceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resourceCategory"]>

  export type ResourceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ResourceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "order" | "createdAt", ExtArgs["result"]["resourceCategory"]>
  export type ResourceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | ResourceCategory$resourcesArgs<ExtArgs>
    _count?: boolean | ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ResourceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ResourceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceCategory"
    objects: {
      resources: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      icon: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["resourceCategory"]>
    composites: {}
  }

  type ResourceCategoryGetPayload<S extends boolean | null | undefined | ResourceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ResourceCategoryPayload, S>

  type ResourceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCategoryCountAggregateInputType | true
    }

  export interface ResourceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceCategory'], meta: { name: 'ResourceCategory' } }
    /**
     * Find zero or one ResourceCategory that matches the filter.
     * @param {ResourceCategoryFindUniqueArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceCategoryFindUniqueArgs>(args: SelectSubset<T, ResourceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryFindFirstArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceCategoryFindFirstArgs>(args?: SelectSubset<T, ResourceCategoryFindFirstArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryFindFirstOrThrowArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceCategories
     * const resourceCategories = await prisma.resourceCategory.findMany()
     * 
     * // Get first 10 ResourceCategories
     * const resourceCategories = await prisma.resourceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceCategoryFindManyArgs>(args?: SelectSubset<T, ResourceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceCategory.
     * @param {ResourceCategoryCreateArgs} args - Arguments to create a ResourceCategory.
     * @example
     * // Create one ResourceCategory
     * const ResourceCategory = await prisma.resourceCategory.create({
     *   data: {
     *     // ... data to create a ResourceCategory
     *   }
     * })
     * 
     */
    create<T extends ResourceCategoryCreateArgs>(args: SelectSubset<T, ResourceCategoryCreateArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceCategories.
     * @param {ResourceCategoryCreateManyArgs} args - Arguments to create many ResourceCategories.
     * @example
     * // Create many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCategoryCreateManyArgs>(args?: SelectSubset<T, ResourceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceCategories and returns the data saved in the database.
     * @param {ResourceCategoryCreateManyAndReturnArgs} args - Arguments to create many ResourceCategories.
     * @example
     * // Create many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceCategories and only return the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceCategory.
     * @param {ResourceCategoryDeleteArgs} args - Arguments to delete one ResourceCategory.
     * @example
     * // Delete one ResourceCategory
     * const ResourceCategory = await prisma.resourceCategory.delete({
     *   where: {
     *     // ... filter to delete one ResourceCategory
     *   }
     * })
     * 
     */
    delete<T extends ResourceCategoryDeleteArgs>(args: SelectSubset<T, ResourceCategoryDeleteArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceCategory.
     * @param {ResourceCategoryUpdateArgs} args - Arguments to update one ResourceCategory.
     * @example
     * // Update one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceCategoryUpdateArgs>(args: SelectSubset<T, ResourceCategoryUpdateArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceCategories.
     * @param {ResourceCategoryDeleteManyArgs} args - Arguments to filter ResourceCategories to delete.
     * @example
     * // Delete a few ResourceCategories
     * const { count } = await prisma.resourceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceCategoryDeleteManyArgs>(args?: SelectSubset<T, ResourceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceCategoryUpdateManyArgs>(args: SelectSubset<T, ResourceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceCategories and returns the data updated in the database.
     * @param {ResourceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ResourceCategories.
     * @example
     * // Update many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceCategories and only return the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceCategory.
     * @param {ResourceCategoryUpsertArgs} args - Arguments to update or create a ResourceCategory.
     * @example
     * // Update or create a ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.upsert({
     *   create: {
     *     // ... data to create a ResourceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ResourceCategoryUpsertArgs>(args: SelectSubset<T, ResourceCategoryUpsertArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryCountArgs} args - Arguments to filter ResourceCategories to count.
     * @example
     * // Count the number of ResourceCategories
     * const count = await prisma.resourceCategory.count({
     *   where: {
     *     // ... the filter for the ResourceCategories we want to count
     *   }
     * })
    **/
    count<T extends ResourceCategoryCountArgs>(
      args?: Subset<T, ResourceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceCategoryAggregateArgs>(args: Subset<T, ResourceCategoryAggregateArgs>): Prisma.PrismaPromise<GetResourceCategoryAggregateType<T>>

    /**
     * Group by ResourceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ResourceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceCategory model
   */
  readonly fields: ResourceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resources<T extends ResourceCategory$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, ResourceCategory$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceCategory model
   */
  interface ResourceCategoryFieldRefs {
    readonly id: FieldRef<"ResourceCategory", 'String'>
    readonly name: FieldRef<"ResourceCategory", 'String'>
    readonly description: FieldRef<"ResourceCategory", 'String'>
    readonly icon: FieldRef<"ResourceCategory", 'String'>
    readonly order: FieldRef<"ResourceCategory", 'Int'>
    readonly createdAt: FieldRef<"ResourceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResourceCategory findUnique
   */
  export type ResourceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ResourceCategory to fetch.
     */
    where: ResourceCategoryWhereUniqueInput
  }

  /**
   * ResourceCategory findUniqueOrThrow
   */
  export type ResourceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ResourceCategory to fetch.
     */
    where: ResourceCategoryWhereUniqueInput
  }

  /**
   * ResourceCategory findFirst
   */
  export type ResourceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ResourceCategory to fetch.
     */
    where?: ResourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceCategories to fetch.
     */
    orderBy?: ResourceCategoryOrderByWithRelationInput | ResourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceCategories.
     */
    cursor?: ResourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceCategories.
     */
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * ResourceCategory findFirstOrThrow
   */
  export type ResourceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ResourceCategory to fetch.
     */
    where?: ResourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceCategories to fetch.
     */
    orderBy?: ResourceCategoryOrderByWithRelationInput | ResourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceCategories.
     */
    cursor?: ResourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceCategories.
     */
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * ResourceCategory findMany
   */
  export type ResourceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ResourceCategories to fetch.
     */
    where?: ResourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceCategories to fetch.
     */
    orderBy?: ResourceCategoryOrderByWithRelationInput | ResourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceCategories.
     */
    cursor?: ResourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceCategories.
     */
    skip?: number
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * ResourceCategory create
   */
  export type ResourceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceCategory.
     */
    data: XOR<ResourceCategoryCreateInput, ResourceCategoryUncheckedCreateInput>
  }

  /**
   * ResourceCategory createMany
   */
  export type ResourceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceCategories.
     */
    data: ResourceCategoryCreateManyInput | ResourceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceCategory createManyAndReturn
   */
  export type ResourceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceCategories.
     */
    data: ResourceCategoryCreateManyInput | ResourceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceCategory update
   */
  export type ResourceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceCategory.
     */
    data: XOR<ResourceCategoryUpdateInput, ResourceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ResourceCategory to update.
     */
    where: ResourceCategoryWhereUniqueInput
  }

  /**
   * ResourceCategory updateMany
   */
  export type ResourceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceCategories.
     */
    data: XOR<ResourceCategoryUpdateManyMutationInput, ResourceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ResourceCategories to update
     */
    where?: ResourceCategoryWhereInput
    /**
     * Limit how many ResourceCategories to update.
     */
    limit?: number
  }

  /**
   * ResourceCategory updateManyAndReturn
   */
  export type ResourceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ResourceCategories.
     */
    data: XOR<ResourceCategoryUpdateManyMutationInput, ResourceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ResourceCategories to update
     */
    where?: ResourceCategoryWhereInput
    /**
     * Limit how many ResourceCategories to update.
     */
    limit?: number
  }

  /**
   * ResourceCategory upsert
   */
  export type ResourceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceCategory to update in case it exists.
     */
    where: ResourceCategoryWhereUniqueInput
    /**
     * In case the ResourceCategory found by the `where` argument doesn't exist, create a new ResourceCategory with this data.
     */
    create: XOR<ResourceCategoryCreateInput, ResourceCategoryUncheckedCreateInput>
    /**
     * In case the ResourceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceCategoryUpdateInput, ResourceCategoryUncheckedUpdateInput>
  }

  /**
   * ResourceCategory delete
   */
  export type ResourceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ResourceCategory to delete.
     */
    where: ResourceCategoryWhereUniqueInput
  }

  /**
   * ResourceCategory deleteMany
   */
  export type ResourceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceCategories to delete
     */
    where?: ResourceCategoryWhereInput
    /**
     * Limit how many ResourceCategories to delete.
     */
    limit?: number
  }

  /**
   * ResourceCategory.resources
   */
  export type ResourceCategory$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * ResourceCategory without action
   */
  export type ResourceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategory
     */
    select?: ResourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceCategory
     */
    omit?: ResourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ResourceTag
   */

  export type AggregateResourceTag = {
    _count: ResourceTagCountAggregateOutputType | null
    _min: ResourceTagMinAggregateOutputType | null
    _max: ResourceTagMaxAggregateOutputType | null
  }

  export type ResourceTagMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ResourceTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ResourceTagCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ResourceTagMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ResourceTagMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ResourceTagCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ResourceTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceTag to aggregate.
     */
    where?: ResourceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTags to fetch.
     */
    orderBy?: ResourceTagOrderByWithRelationInput | ResourceTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceTags
    **/
    _count?: true | ResourceTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceTagMaxAggregateInputType
  }

  export type GetResourceTagAggregateType<T extends ResourceTagAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceTag[P]>
      : GetScalarType<T[P], AggregateResourceTag[P]>
  }




  export type ResourceTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceTagWhereInput
    orderBy?: ResourceTagOrderByWithAggregationInput | ResourceTagOrderByWithAggregationInput[]
    by: ResourceTagScalarFieldEnum[] | ResourceTagScalarFieldEnum
    having?: ResourceTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceTagCountAggregateInputType | true
    _min?: ResourceTagMinAggregateInputType
    _max?: ResourceTagMaxAggregateInputType
  }

  export type ResourceTagGroupByOutputType = {
    id: string
    name: string
    _count: ResourceTagCountAggregateOutputType | null
    _min: ResourceTagMinAggregateOutputType | null
    _max: ResourceTagMaxAggregateOutputType | null
  }

  type GetResourceTagGroupByPayload<T extends ResourceTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceTagGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceTagGroupByOutputType[P]>
        }
      >
    >


  export type ResourceTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tagAssignments?: boolean | ResourceTag$tagAssignmentsArgs<ExtArgs>
    _count?: boolean | ResourceTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceTag"]>

  export type ResourceTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["resourceTag"]>

  export type ResourceTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["resourceTag"]>

  export type ResourceTagSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ResourceTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["resourceTag"]>
  export type ResourceTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagAssignments?: boolean | ResourceTag$tagAssignmentsArgs<ExtArgs>
    _count?: boolean | ResourceTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ResourceTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ResourceTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceTag"
    objects: {
      tagAssignments: Prisma.$ResourceTagAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["resourceTag"]>
    composites: {}
  }

  type ResourceTagGetPayload<S extends boolean | null | undefined | ResourceTagDefaultArgs> = $Result.GetResult<Prisma.$ResourceTagPayload, S>

  type ResourceTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceTagCountAggregateInputType | true
    }

  export interface ResourceTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceTag'], meta: { name: 'ResourceTag' } }
    /**
     * Find zero or one ResourceTag that matches the filter.
     * @param {ResourceTagFindUniqueArgs} args - Arguments to find a ResourceTag
     * @example
     * // Get one ResourceTag
     * const resourceTag = await prisma.resourceTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceTagFindUniqueArgs>(args: SelectSubset<T, ResourceTagFindUniqueArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceTagFindUniqueOrThrowArgs} args - Arguments to find a ResourceTag
     * @example
     * // Get one ResourceTag
     * const resourceTag = await prisma.resourceTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagFindFirstArgs} args - Arguments to find a ResourceTag
     * @example
     * // Get one ResourceTag
     * const resourceTag = await prisma.resourceTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceTagFindFirstArgs>(args?: SelectSubset<T, ResourceTagFindFirstArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagFindFirstOrThrowArgs} args - Arguments to find a ResourceTag
     * @example
     * // Get one ResourceTag
     * const resourceTag = await prisma.resourceTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceTags
     * const resourceTags = await prisma.resourceTag.findMany()
     * 
     * // Get first 10 ResourceTags
     * const resourceTags = await prisma.resourceTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceTagWithIdOnly = await prisma.resourceTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceTagFindManyArgs>(args?: SelectSubset<T, ResourceTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceTag.
     * @param {ResourceTagCreateArgs} args - Arguments to create a ResourceTag.
     * @example
     * // Create one ResourceTag
     * const ResourceTag = await prisma.resourceTag.create({
     *   data: {
     *     // ... data to create a ResourceTag
     *   }
     * })
     * 
     */
    create<T extends ResourceTagCreateArgs>(args: SelectSubset<T, ResourceTagCreateArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceTags.
     * @param {ResourceTagCreateManyArgs} args - Arguments to create many ResourceTags.
     * @example
     * // Create many ResourceTags
     * const resourceTag = await prisma.resourceTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceTagCreateManyArgs>(args?: SelectSubset<T, ResourceTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceTags and returns the data saved in the database.
     * @param {ResourceTagCreateManyAndReturnArgs} args - Arguments to create many ResourceTags.
     * @example
     * // Create many ResourceTags
     * const resourceTag = await prisma.resourceTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceTags and only return the `id`
     * const resourceTagWithIdOnly = await prisma.resourceTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceTag.
     * @param {ResourceTagDeleteArgs} args - Arguments to delete one ResourceTag.
     * @example
     * // Delete one ResourceTag
     * const ResourceTag = await prisma.resourceTag.delete({
     *   where: {
     *     // ... filter to delete one ResourceTag
     *   }
     * })
     * 
     */
    delete<T extends ResourceTagDeleteArgs>(args: SelectSubset<T, ResourceTagDeleteArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceTag.
     * @param {ResourceTagUpdateArgs} args - Arguments to update one ResourceTag.
     * @example
     * // Update one ResourceTag
     * const resourceTag = await prisma.resourceTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceTagUpdateArgs>(args: SelectSubset<T, ResourceTagUpdateArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceTags.
     * @param {ResourceTagDeleteManyArgs} args - Arguments to filter ResourceTags to delete.
     * @example
     * // Delete a few ResourceTags
     * const { count } = await prisma.resourceTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceTagDeleteManyArgs>(args?: SelectSubset<T, ResourceTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceTags
     * const resourceTag = await prisma.resourceTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceTagUpdateManyArgs>(args: SelectSubset<T, ResourceTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceTags and returns the data updated in the database.
     * @param {ResourceTagUpdateManyAndReturnArgs} args - Arguments to update many ResourceTags.
     * @example
     * // Update many ResourceTags
     * const resourceTag = await prisma.resourceTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceTags and only return the `id`
     * const resourceTagWithIdOnly = await prisma.resourceTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceTag.
     * @param {ResourceTagUpsertArgs} args - Arguments to update or create a ResourceTag.
     * @example
     * // Update or create a ResourceTag
     * const resourceTag = await prisma.resourceTag.upsert({
     *   create: {
     *     // ... data to create a ResourceTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceTag we want to update
     *   }
     * })
     */
    upsert<T extends ResourceTagUpsertArgs>(args: SelectSubset<T, ResourceTagUpsertArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagCountArgs} args - Arguments to filter ResourceTags to count.
     * @example
     * // Count the number of ResourceTags
     * const count = await prisma.resourceTag.count({
     *   where: {
     *     // ... the filter for the ResourceTags we want to count
     *   }
     * })
    **/
    count<T extends ResourceTagCountArgs>(
      args?: Subset<T, ResourceTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceTagAggregateArgs>(args: Subset<T, ResourceTagAggregateArgs>): Prisma.PrismaPromise<GetResourceTagAggregateType<T>>

    /**
     * Group by ResourceTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceTagGroupByArgs['orderBy'] }
        : { orderBy?: ResourceTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceTag model
   */
  readonly fields: ResourceTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tagAssignments<T extends ResourceTag$tagAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ResourceTag$tagAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceTag model
   */
  interface ResourceTagFieldRefs {
    readonly id: FieldRef<"ResourceTag", 'String'>
    readonly name: FieldRef<"ResourceTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResourceTag findUnique
   */
  export type ResourceTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTag to fetch.
     */
    where: ResourceTagWhereUniqueInput
  }

  /**
   * ResourceTag findUniqueOrThrow
   */
  export type ResourceTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTag to fetch.
     */
    where: ResourceTagWhereUniqueInput
  }

  /**
   * ResourceTag findFirst
   */
  export type ResourceTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTag to fetch.
     */
    where?: ResourceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTags to fetch.
     */
    orderBy?: ResourceTagOrderByWithRelationInput | ResourceTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceTags.
     */
    cursor?: ResourceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceTags.
     */
    distinct?: ResourceTagScalarFieldEnum | ResourceTagScalarFieldEnum[]
  }

  /**
   * ResourceTag findFirstOrThrow
   */
  export type ResourceTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTag to fetch.
     */
    where?: ResourceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTags to fetch.
     */
    orderBy?: ResourceTagOrderByWithRelationInput | ResourceTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceTags.
     */
    cursor?: ResourceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceTags.
     */
    distinct?: ResourceTagScalarFieldEnum | ResourceTagScalarFieldEnum[]
  }

  /**
   * ResourceTag findMany
   */
  export type ResourceTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTags to fetch.
     */
    where?: ResourceTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTags to fetch.
     */
    orderBy?: ResourceTagOrderByWithRelationInput | ResourceTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceTags.
     */
    cursor?: ResourceTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTags.
     */
    skip?: number
    distinct?: ResourceTagScalarFieldEnum | ResourceTagScalarFieldEnum[]
  }

  /**
   * ResourceTag create
   */
  export type ResourceTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceTag.
     */
    data: XOR<ResourceTagCreateInput, ResourceTagUncheckedCreateInput>
  }

  /**
   * ResourceTag createMany
   */
  export type ResourceTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceTags.
     */
    data: ResourceTagCreateManyInput | ResourceTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceTag createManyAndReturn
   */
  export type ResourceTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceTags.
     */
    data: ResourceTagCreateManyInput | ResourceTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceTag update
   */
  export type ResourceTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceTag.
     */
    data: XOR<ResourceTagUpdateInput, ResourceTagUncheckedUpdateInput>
    /**
     * Choose, which ResourceTag to update.
     */
    where: ResourceTagWhereUniqueInput
  }

  /**
   * ResourceTag updateMany
   */
  export type ResourceTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceTags.
     */
    data: XOR<ResourceTagUpdateManyMutationInput, ResourceTagUncheckedUpdateManyInput>
    /**
     * Filter which ResourceTags to update
     */
    where?: ResourceTagWhereInput
    /**
     * Limit how many ResourceTags to update.
     */
    limit?: number
  }

  /**
   * ResourceTag updateManyAndReturn
   */
  export type ResourceTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * The data used to update ResourceTags.
     */
    data: XOR<ResourceTagUpdateManyMutationInput, ResourceTagUncheckedUpdateManyInput>
    /**
     * Filter which ResourceTags to update
     */
    where?: ResourceTagWhereInput
    /**
     * Limit how many ResourceTags to update.
     */
    limit?: number
  }

  /**
   * ResourceTag upsert
   */
  export type ResourceTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceTag to update in case it exists.
     */
    where: ResourceTagWhereUniqueInput
    /**
     * In case the ResourceTag found by the `where` argument doesn't exist, create a new ResourceTag with this data.
     */
    create: XOR<ResourceTagCreateInput, ResourceTagUncheckedCreateInput>
    /**
     * In case the ResourceTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceTagUpdateInput, ResourceTagUncheckedUpdateInput>
  }

  /**
   * ResourceTag delete
   */
  export type ResourceTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
    /**
     * Filter which ResourceTag to delete.
     */
    where: ResourceTagWhereUniqueInput
  }

  /**
   * ResourceTag deleteMany
   */
  export type ResourceTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceTags to delete
     */
    where?: ResourceTagWhereInput
    /**
     * Limit how many ResourceTags to delete.
     */
    limit?: number
  }

  /**
   * ResourceTag.tagAssignments
   */
  export type ResourceTag$tagAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    where?: ResourceTagAssignmentWhereInput
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    cursor?: ResourceTagAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceTagAssignmentScalarFieldEnum | ResourceTagAssignmentScalarFieldEnum[]
  }

  /**
   * ResourceTag without action
   */
  export type ResourceTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTag
     */
    select?: ResourceTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTag
     */
    omit?: ResourceTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    downloadCount: number | null
    viewCount: number | null
  }

  export type ResourceSumAggregateOutputType = {
    downloadCount: number | null
    viewCount: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    type: $Enums.ResourceType | null
    categoryId: string | null
    thumbnailUrl: string | null
    visibility: $Enums.Visibility | null
    featured: boolean | null
    downloadCount: number | null
    viewCount: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    type: $Enums.ResourceType | null
    categoryId: string | null
    thumbnailUrl: string | null
    visibility: $Enums.Visibility | null
    featured: boolean | null
    downloadCount: number | null
    viewCount: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    type: number
    categoryId: number
    thumbnailUrl: number
    visibility: number
    featured: number
    downloadCount: number
    viewCount: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    downloadCount?: true
    viewCount?: true
  }

  export type ResourceSumAggregateInputType = {
    downloadCount?: true
    viewCount?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    type?: true
    categoryId?: true
    thumbnailUrl?: true
    visibility?: true
    featured?: true
    downloadCount?: true
    viewCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    type?: true
    categoryId?: true
    thumbnailUrl?: true
    visibility?: true
    featured?: true
    downloadCount?: true
    viewCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    type?: true
    categoryId?: true
    thumbnailUrl?: true
    visibility?: true
    featured?: true
    downloadCount?: true
    viewCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl: string | null
    visibility: $Enums.Visibility
    featured: boolean
    downloadCount: number
    viewCount: number
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    thumbnailUrl?: boolean
    visibility?: boolean
    featured?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assets?: boolean | Resource$assetsArgs<ExtArgs>
    downloads?: boolean | Resource$downloadsArgs<ExtArgs>
    tags?: boolean | Resource$tagsArgs<ExtArgs>
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    thumbnailUrl?: boolean
    visibility?: boolean
    featured?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    thumbnailUrl?: boolean
    visibility?: boolean
    featured?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    thumbnailUrl?: boolean
    visibility?: boolean
    featured?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "description" | "type" | "categoryId" | "thumbnailUrl" | "visibility" | "featured" | "downloadCount" | "viewCount" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | Resource$assetsArgs<ExtArgs>
    downloads?: boolean | Resource$downloadsArgs<ExtArgs>
    tags?: boolean | Resource$tagsArgs<ExtArgs>
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResourceCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      assets: Prisma.$ResourceAssetPayload<ExtArgs>[]
      downloads: Prisma.$ResourceDownloadLogPayload<ExtArgs>[]
      tags: Prisma.$ResourceTagAssignmentPayload<ExtArgs>[]
      category: Prisma.$ResourceCategoryPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string
      type: $Enums.ResourceType
      categoryId: string
      thumbnailUrl: string | null
      visibility: $Enums.Visibility
      featured: boolean
      downloadCount: number
      viewCount: number
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assets<T extends Resource$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    downloads<T extends Resource$downloadsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$downloadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Resource$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends ResourceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceCategoryDefaultArgs<ExtArgs>>): Prisma__ResourceCategoryClient<$Result.GetResult<Prisma.$ResourceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly slug: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'ResourceType'>
    readonly categoryId: FieldRef<"Resource", 'String'>
    readonly thumbnailUrl: FieldRef<"Resource", 'String'>
    readonly visibility: FieldRef<"Resource", 'Visibility'>
    readonly featured: FieldRef<"Resource", 'Boolean'>
    readonly downloadCount: FieldRef<"Resource", 'Int'>
    readonly viewCount: FieldRef<"Resource", 'Int'>
    readonly createdById: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource.assets
   */
  export type Resource$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    where?: ResourceAssetWhereInput
    orderBy?: ResourceAssetOrderByWithRelationInput | ResourceAssetOrderByWithRelationInput[]
    cursor?: ResourceAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceAssetScalarFieldEnum | ResourceAssetScalarFieldEnum[]
  }

  /**
   * Resource.downloads
   */
  export type Resource$downloadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    where?: ResourceDownloadLogWhereInput
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    cursor?: ResourceDownloadLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceDownloadLogScalarFieldEnum | ResourceDownloadLogScalarFieldEnum[]
  }

  /**
   * Resource.tags
   */
  export type Resource$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    where?: ResourceTagAssignmentWhereInput
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    cursor?: ResourceTagAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceTagAssignmentScalarFieldEnum | ResourceTagAssignmentScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model ResourceTagAssignment
   */

  export type AggregateResourceTagAssignment = {
    _count: ResourceTagAssignmentCountAggregateOutputType | null
    _min: ResourceTagAssignmentMinAggregateOutputType | null
    _max: ResourceTagAssignmentMaxAggregateOutputType | null
  }

  export type ResourceTagAssignmentMinAggregateOutputType = {
    resourceId: string | null
    tagId: string | null
  }

  export type ResourceTagAssignmentMaxAggregateOutputType = {
    resourceId: string | null
    tagId: string | null
  }

  export type ResourceTagAssignmentCountAggregateOutputType = {
    resourceId: number
    tagId: number
    _all: number
  }


  export type ResourceTagAssignmentMinAggregateInputType = {
    resourceId?: true
    tagId?: true
  }

  export type ResourceTagAssignmentMaxAggregateInputType = {
    resourceId?: true
    tagId?: true
  }

  export type ResourceTagAssignmentCountAggregateInputType = {
    resourceId?: true
    tagId?: true
    _all?: true
  }

  export type ResourceTagAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceTagAssignment to aggregate.
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTagAssignments to fetch.
     */
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceTagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceTagAssignments
    **/
    _count?: true | ResourceTagAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceTagAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceTagAssignmentMaxAggregateInputType
  }

  export type GetResourceTagAssignmentAggregateType<T extends ResourceTagAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceTagAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceTagAssignment[P]>
      : GetScalarType<T[P], AggregateResourceTagAssignment[P]>
  }




  export type ResourceTagAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceTagAssignmentWhereInput
    orderBy?: ResourceTagAssignmentOrderByWithAggregationInput | ResourceTagAssignmentOrderByWithAggregationInput[]
    by: ResourceTagAssignmentScalarFieldEnum[] | ResourceTagAssignmentScalarFieldEnum
    having?: ResourceTagAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceTagAssignmentCountAggregateInputType | true
    _min?: ResourceTagAssignmentMinAggregateInputType
    _max?: ResourceTagAssignmentMaxAggregateInputType
  }

  export type ResourceTagAssignmentGroupByOutputType = {
    resourceId: string
    tagId: string
    _count: ResourceTagAssignmentCountAggregateOutputType | null
    _min: ResourceTagAssignmentMinAggregateOutputType | null
    _max: ResourceTagAssignmentMaxAggregateOutputType | null
  }

  type GetResourceTagAssignmentGroupByPayload<T extends ResourceTagAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceTagAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceTagAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceTagAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceTagAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ResourceTagAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resourceId?: boolean
    tagId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceTagAssignment"]>

  export type ResourceTagAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resourceId?: boolean
    tagId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceTagAssignment"]>

  export type ResourceTagAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resourceId?: boolean
    tagId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceTagAssignment"]>

  export type ResourceTagAssignmentSelectScalar = {
    resourceId?: boolean
    tagId?: boolean
  }

  export type ResourceTagAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"resourceId" | "tagId", ExtArgs["result"]["resourceTagAssignment"]>
  export type ResourceTagAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }
  export type ResourceTagAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }
  export type ResourceTagAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    tag?: boolean | ResourceTagDefaultArgs<ExtArgs>
  }

  export type $ResourceTagAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceTagAssignment"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      tag: Prisma.$ResourceTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resourceId: string
      tagId: string
    }, ExtArgs["result"]["resourceTagAssignment"]>
    composites: {}
  }

  type ResourceTagAssignmentGetPayload<S extends boolean | null | undefined | ResourceTagAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ResourceTagAssignmentPayload, S>

  type ResourceTagAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceTagAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceTagAssignmentCountAggregateInputType | true
    }

  export interface ResourceTagAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceTagAssignment'], meta: { name: 'ResourceTagAssignment' } }
    /**
     * Find zero or one ResourceTagAssignment that matches the filter.
     * @param {ResourceTagAssignmentFindUniqueArgs} args - Arguments to find a ResourceTagAssignment
     * @example
     * // Get one ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceTagAssignmentFindUniqueArgs>(args: SelectSubset<T, ResourceTagAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceTagAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceTagAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ResourceTagAssignment
     * @example
     * // Get one ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceTagAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceTagAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceTagAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentFindFirstArgs} args - Arguments to find a ResourceTagAssignment
     * @example
     * // Get one ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceTagAssignmentFindFirstArgs>(args?: SelectSubset<T, ResourceTagAssignmentFindFirstArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceTagAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentFindFirstOrThrowArgs} args - Arguments to find a ResourceTagAssignment
     * @example
     * // Get one ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceTagAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceTagAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceTagAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceTagAssignments
     * const resourceTagAssignments = await prisma.resourceTagAssignment.findMany()
     * 
     * // Get first 10 ResourceTagAssignments
     * const resourceTagAssignments = await prisma.resourceTagAssignment.findMany({ take: 10 })
     * 
     * // Only select the `resourceId`
     * const resourceTagAssignmentWithResourceIdOnly = await prisma.resourceTagAssignment.findMany({ select: { resourceId: true } })
     * 
     */
    findMany<T extends ResourceTagAssignmentFindManyArgs>(args?: SelectSubset<T, ResourceTagAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceTagAssignment.
     * @param {ResourceTagAssignmentCreateArgs} args - Arguments to create a ResourceTagAssignment.
     * @example
     * // Create one ResourceTagAssignment
     * const ResourceTagAssignment = await prisma.resourceTagAssignment.create({
     *   data: {
     *     // ... data to create a ResourceTagAssignment
     *   }
     * })
     * 
     */
    create<T extends ResourceTagAssignmentCreateArgs>(args: SelectSubset<T, ResourceTagAssignmentCreateArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceTagAssignments.
     * @param {ResourceTagAssignmentCreateManyArgs} args - Arguments to create many ResourceTagAssignments.
     * @example
     * // Create many ResourceTagAssignments
     * const resourceTagAssignment = await prisma.resourceTagAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceTagAssignmentCreateManyArgs>(args?: SelectSubset<T, ResourceTagAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceTagAssignments and returns the data saved in the database.
     * @param {ResourceTagAssignmentCreateManyAndReturnArgs} args - Arguments to create many ResourceTagAssignments.
     * @example
     * // Create many ResourceTagAssignments
     * const resourceTagAssignment = await prisma.resourceTagAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceTagAssignments and only return the `resourceId`
     * const resourceTagAssignmentWithResourceIdOnly = await prisma.resourceTagAssignment.createManyAndReturn({
     *   select: { resourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceTagAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceTagAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceTagAssignment.
     * @param {ResourceTagAssignmentDeleteArgs} args - Arguments to delete one ResourceTagAssignment.
     * @example
     * // Delete one ResourceTagAssignment
     * const ResourceTagAssignment = await prisma.resourceTagAssignment.delete({
     *   where: {
     *     // ... filter to delete one ResourceTagAssignment
     *   }
     * })
     * 
     */
    delete<T extends ResourceTagAssignmentDeleteArgs>(args: SelectSubset<T, ResourceTagAssignmentDeleteArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceTagAssignment.
     * @param {ResourceTagAssignmentUpdateArgs} args - Arguments to update one ResourceTagAssignment.
     * @example
     * // Update one ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceTagAssignmentUpdateArgs>(args: SelectSubset<T, ResourceTagAssignmentUpdateArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceTagAssignments.
     * @param {ResourceTagAssignmentDeleteManyArgs} args - Arguments to filter ResourceTagAssignments to delete.
     * @example
     * // Delete a few ResourceTagAssignments
     * const { count } = await prisma.resourceTagAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceTagAssignmentDeleteManyArgs>(args?: SelectSubset<T, ResourceTagAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceTagAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceTagAssignments
     * const resourceTagAssignment = await prisma.resourceTagAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceTagAssignmentUpdateManyArgs>(args: SelectSubset<T, ResourceTagAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceTagAssignments and returns the data updated in the database.
     * @param {ResourceTagAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ResourceTagAssignments.
     * @example
     * // Update many ResourceTagAssignments
     * const resourceTagAssignment = await prisma.resourceTagAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceTagAssignments and only return the `resourceId`
     * const resourceTagAssignmentWithResourceIdOnly = await prisma.resourceTagAssignment.updateManyAndReturn({
     *   select: { resourceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceTagAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceTagAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceTagAssignment.
     * @param {ResourceTagAssignmentUpsertArgs} args - Arguments to update or create a ResourceTagAssignment.
     * @example
     * // Update or create a ResourceTagAssignment
     * const resourceTagAssignment = await prisma.resourceTagAssignment.upsert({
     *   create: {
     *     // ... data to create a ResourceTagAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceTagAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ResourceTagAssignmentUpsertArgs>(args: SelectSubset<T, ResourceTagAssignmentUpsertArgs<ExtArgs>>): Prisma__ResourceTagAssignmentClient<$Result.GetResult<Prisma.$ResourceTagAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceTagAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentCountArgs} args - Arguments to filter ResourceTagAssignments to count.
     * @example
     * // Count the number of ResourceTagAssignments
     * const count = await prisma.resourceTagAssignment.count({
     *   where: {
     *     // ... the filter for the ResourceTagAssignments we want to count
     *   }
     * })
    **/
    count<T extends ResourceTagAssignmentCountArgs>(
      args?: Subset<T, ResourceTagAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceTagAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceTagAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceTagAssignmentAggregateArgs>(args: Subset<T, ResourceTagAssignmentAggregateArgs>): Prisma.PrismaPromise<GetResourceTagAssignmentAggregateType<T>>

    /**
     * Group by ResourceTagAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceTagAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceTagAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceTagAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ResourceTagAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceTagAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceTagAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceTagAssignment model
   */
  readonly fields: ResourceTagAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceTagAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceTagAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends ResourceTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceTagDefaultArgs<ExtArgs>>): Prisma__ResourceTagClient<$Result.GetResult<Prisma.$ResourceTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceTagAssignment model
   */
  interface ResourceTagAssignmentFieldRefs {
    readonly resourceId: FieldRef<"ResourceTagAssignment", 'String'>
    readonly tagId: FieldRef<"ResourceTagAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResourceTagAssignment findUnique
   */
  export type ResourceTagAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTagAssignment to fetch.
     */
    where: ResourceTagAssignmentWhereUniqueInput
  }

  /**
   * ResourceTagAssignment findUniqueOrThrow
   */
  export type ResourceTagAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTagAssignment to fetch.
     */
    where: ResourceTagAssignmentWhereUniqueInput
  }

  /**
   * ResourceTagAssignment findFirst
   */
  export type ResourceTagAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTagAssignment to fetch.
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTagAssignments to fetch.
     */
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceTagAssignments.
     */
    cursor?: ResourceTagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceTagAssignments.
     */
    distinct?: ResourceTagAssignmentScalarFieldEnum | ResourceTagAssignmentScalarFieldEnum[]
  }

  /**
   * ResourceTagAssignment findFirstOrThrow
   */
  export type ResourceTagAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTagAssignment to fetch.
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTagAssignments to fetch.
     */
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceTagAssignments.
     */
    cursor?: ResourceTagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceTagAssignments.
     */
    distinct?: ResourceTagAssignmentScalarFieldEnum | ResourceTagAssignmentScalarFieldEnum[]
  }

  /**
   * ResourceTagAssignment findMany
   */
  export type ResourceTagAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ResourceTagAssignments to fetch.
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceTagAssignments to fetch.
     */
    orderBy?: ResourceTagAssignmentOrderByWithRelationInput | ResourceTagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceTagAssignments.
     */
    cursor?: ResourceTagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceTagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceTagAssignments.
     */
    skip?: number
    distinct?: ResourceTagAssignmentScalarFieldEnum | ResourceTagAssignmentScalarFieldEnum[]
  }

  /**
   * ResourceTagAssignment create
   */
  export type ResourceTagAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceTagAssignment.
     */
    data: XOR<ResourceTagAssignmentCreateInput, ResourceTagAssignmentUncheckedCreateInput>
  }

  /**
   * ResourceTagAssignment createMany
   */
  export type ResourceTagAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceTagAssignments.
     */
    data: ResourceTagAssignmentCreateManyInput | ResourceTagAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceTagAssignment createManyAndReturn
   */
  export type ResourceTagAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceTagAssignments.
     */
    data: ResourceTagAssignmentCreateManyInput | ResourceTagAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceTagAssignment update
   */
  export type ResourceTagAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceTagAssignment.
     */
    data: XOR<ResourceTagAssignmentUpdateInput, ResourceTagAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ResourceTagAssignment to update.
     */
    where: ResourceTagAssignmentWhereUniqueInput
  }

  /**
   * ResourceTagAssignment updateMany
   */
  export type ResourceTagAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceTagAssignments.
     */
    data: XOR<ResourceTagAssignmentUpdateManyMutationInput, ResourceTagAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ResourceTagAssignments to update
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * Limit how many ResourceTagAssignments to update.
     */
    limit?: number
  }

  /**
   * ResourceTagAssignment updateManyAndReturn
   */
  export type ResourceTagAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ResourceTagAssignments.
     */
    data: XOR<ResourceTagAssignmentUpdateManyMutationInput, ResourceTagAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ResourceTagAssignments to update
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * Limit how many ResourceTagAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceTagAssignment upsert
   */
  export type ResourceTagAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceTagAssignment to update in case it exists.
     */
    where: ResourceTagAssignmentWhereUniqueInput
    /**
     * In case the ResourceTagAssignment found by the `where` argument doesn't exist, create a new ResourceTagAssignment with this data.
     */
    create: XOR<ResourceTagAssignmentCreateInput, ResourceTagAssignmentUncheckedCreateInput>
    /**
     * In case the ResourceTagAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceTagAssignmentUpdateInput, ResourceTagAssignmentUncheckedUpdateInput>
  }

  /**
   * ResourceTagAssignment delete
   */
  export type ResourceTagAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ResourceTagAssignment to delete.
     */
    where: ResourceTagAssignmentWhereUniqueInput
  }

  /**
   * ResourceTagAssignment deleteMany
   */
  export type ResourceTagAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceTagAssignments to delete
     */
    where?: ResourceTagAssignmentWhereInput
    /**
     * Limit how many ResourceTagAssignments to delete.
     */
    limit?: number
  }

  /**
   * ResourceTagAssignment without action
   */
  export type ResourceTagAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceTagAssignment
     */
    select?: ResourceTagAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceTagAssignment
     */
    omit?: ResourceTagAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceTagAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ResourceAsset
   */

  export type AggregateResourceAsset = {
    _count: ResourceAssetCountAggregateOutputType | null
    _avg: ResourceAssetAvgAggregateOutputType | null
    _sum: ResourceAssetSumAggregateOutputType | null
    _min: ResourceAssetMinAggregateOutputType | null
    _max: ResourceAssetMaxAggregateOutputType | null
  }

  export type ResourceAssetAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ResourceAssetSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ResourceAssetMinAggregateOutputType = {
    id: string | null
    resourceId: string | null
    fileUrl: string | null
    fileName: string | null
    mimeType: string | null
    sizeBytes: number | null
    createdAt: Date | null
  }

  export type ResourceAssetMaxAggregateOutputType = {
    id: string | null
    resourceId: string | null
    fileUrl: string | null
    fileName: string | null
    mimeType: string | null
    sizeBytes: number | null
    createdAt: Date | null
  }

  export type ResourceAssetCountAggregateOutputType = {
    id: number
    resourceId: number
    fileUrl: number
    fileName: number
    mimeType: number
    sizeBytes: number
    createdAt: number
    _all: number
  }


  export type ResourceAssetAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type ResourceAssetSumAggregateInputType = {
    sizeBytes?: true
  }

  export type ResourceAssetMinAggregateInputType = {
    id?: true
    resourceId?: true
    fileUrl?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type ResourceAssetMaxAggregateInputType = {
    id?: true
    resourceId?: true
    fileUrl?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type ResourceAssetCountAggregateInputType = {
    id?: true
    resourceId?: true
    fileUrl?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
    _all?: true
  }

  export type ResourceAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceAsset to aggregate.
     */
    where?: ResourceAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceAssets to fetch.
     */
    orderBy?: ResourceAssetOrderByWithRelationInput | ResourceAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceAssets
    **/
    _count?: true | ResourceAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceAssetMaxAggregateInputType
  }

  export type GetResourceAssetAggregateType<T extends ResourceAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceAsset[P]>
      : GetScalarType<T[P], AggregateResourceAsset[P]>
  }




  export type ResourceAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceAssetWhereInput
    orderBy?: ResourceAssetOrderByWithAggregationInput | ResourceAssetOrderByWithAggregationInput[]
    by: ResourceAssetScalarFieldEnum[] | ResourceAssetScalarFieldEnum
    having?: ResourceAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceAssetCountAggregateInputType | true
    _avg?: ResourceAssetAvgAggregateInputType
    _sum?: ResourceAssetSumAggregateInputType
    _min?: ResourceAssetMinAggregateInputType
    _max?: ResourceAssetMaxAggregateInputType
  }

  export type ResourceAssetGroupByOutputType = {
    id: string
    resourceId: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt: Date
    _count: ResourceAssetCountAggregateOutputType | null
    _avg: ResourceAssetAvgAggregateOutputType | null
    _sum: ResourceAssetSumAggregateOutputType | null
    _min: ResourceAssetMinAggregateOutputType | null
    _max: ResourceAssetMaxAggregateOutputType | null
  }

  type GetResourceAssetGroupByPayload<T extends ResourceAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceAssetGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceAssetGroupByOutputType[P]>
        }
      >
    >


  export type ResourceAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAsset"]>

  export type ResourceAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAsset"]>

  export type ResourceAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAsset"]>

  export type ResourceAssetSelectScalar = {
    id?: boolean
    resourceId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
  }

  export type ResourceAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resourceId" | "fileUrl" | "fileName" | "mimeType" | "sizeBytes" | "createdAt", ExtArgs["result"]["resourceAsset"]>
  export type ResourceAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type ResourceAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type ResourceAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $ResourceAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceAsset"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resourceId: string
      fileUrl: string
      fileName: string
      mimeType: string
      sizeBytes: number
      createdAt: Date
    }, ExtArgs["result"]["resourceAsset"]>
    composites: {}
  }

  type ResourceAssetGetPayload<S extends boolean | null | undefined | ResourceAssetDefaultArgs> = $Result.GetResult<Prisma.$ResourceAssetPayload, S>

  type ResourceAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceAssetCountAggregateInputType | true
    }

  export interface ResourceAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceAsset'], meta: { name: 'ResourceAsset' } }
    /**
     * Find zero or one ResourceAsset that matches the filter.
     * @param {ResourceAssetFindUniqueArgs} args - Arguments to find a ResourceAsset
     * @example
     * // Get one ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceAssetFindUniqueArgs>(args: SelectSubset<T, ResourceAssetFindUniqueArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceAssetFindUniqueOrThrowArgs} args - Arguments to find a ResourceAsset
     * @example
     * // Get one ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetFindFirstArgs} args - Arguments to find a ResourceAsset
     * @example
     * // Get one ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceAssetFindFirstArgs>(args?: SelectSubset<T, ResourceAssetFindFirstArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetFindFirstOrThrowArgs} args - Arguments to find a ResourceAsset
     * @example
     * // Get one ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceAssets
     * const resourceAssets = await prisma.resourceAsset.findMany()
     * 
     * // Get first 10 ResourceAssets
     * const resourceAssets = await prisma.resourceAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceAssetWithIdOnly = await prisma.resourceAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceAssetFindManyArgs>(args?: SelectSubset<T, ResourceAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceAsset.
     * @param {ResourceAssetCreateArgs} args - Arguments to create a ResourceAsset.
     * @example
     * // Create one ResourceAsset
     * const ResourceAsset = await prisma.resourceAsset.create({
     *   data: {
     *     // ... data to create a ResourceAsset
     *   }
     * })
     * 
     */
    create<T extends ResourceAssetCreateArgs>(args: SelectSubset<T, ResourceAssetCreateArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceAssets.
     * @param {ResourceAssetCreateManyArgs} args - Arguments to create many ResourceAssets.
     * @example
     * // Create many ResourceAssets
     * const resourceAsset = await prisma.resourceAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceAssetCreateManyArgs>(args?: SelectSubset<T, ResourceAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceAssets and returns the data saved in the database.
     * @param {ResourceAssetCreateManyAndReturnArgs} args - Arguments to create many ResourceAssets.
     * @example
     * // Create many ResourceAssets
     * const resourceAsset = await prisma.resourceAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceAssets and only return the `id`
     * const resourceAssetWithIdOnly = await prisma.resourceAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceAsset.
     * @param {ResourceAssetDeleteArgs} args - Arguments to delete one ResourceAsset.
     * @example
     * // Delete one ResourceAsset
     * const ResourceAsset = await prisma.resourceAsset.delete({
     *   where: {
     *     // ... filter to delete one ResourceAsset
     *   }
     * })
     * 
     */
    delete<T extends ResourceAssetDeleteArgs>(args: SelectSubset<T, ResourceAssetDeleteArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceAsset.
     * @param {ResourceAssetUpdateArgs} args - Arguments to update one ResourceAsset.
     * @example
     * // Update one ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceAssetUpdateArgs>(args: SelectSubset<T, ResourceAssetUpdateArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceAssets.
     * @param {ResourceAssetDeleteManyArgs} args - Arguments to filter ResourceAssets to delete.
     * @example
     * // Delete a few ResourceAssets
     * const { count } = await prisma.resourceAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceAssetDeleteManyArgs>(args?: SelectSubset<T, ResourceAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceAssets
     * const resourceAsset = await prisma.resourceAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceAssetUpdateManyArgs>(args: SelectSubset<T, ResourceAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceAssets and returns the data updated in the database.
     * @param {ResourceAssetUpdateManyAndReturnArgs} args - Arguments to update many ResourceAssets.
     * @example
     * // Update many ResourceAssets
     * const resourceAsset = await prisma.resourceAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceAssets and only return the `id`
     * const resourceAssetWithIdOnly = await prisma.resourceAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceAsset.
     * @param {ResourceAssetUpsertArgs} args - Arguments to update or create a ResourceAsset.
     * @example
     * // Update or create a ResourceAsset
     * const resourceAsset = await prisma.resourceAsset.upsert({
     *   create: {
     *     // ... data to create a ResourceAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceAsset we want to update
     *   }
     * })
     */
    upsert<T extends ResourceAssetUpsertArgs>(args: SelectSubset<T, ResourceAssetUpsertArgs<ExtArgs>>): Prisma__ResourceAssetClient<$Result.GetResult<Prisma.$ResourceAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetCountArgs} args - Arguments to filter ResourceAssets to count.
     * @example
     * // Count the number of ResourceAssets
     * const count = await prisma.resourceAsset.count({
     *   where: {
     *     // ... the filter for the ResourceAssets we want to count
     *   }
     * })
    **/
    count<T extends ResourceAssetCountArgs>(
      args?: Subset<T, ResourceAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAssetAggregateArgs>(args: Subset<T, ResourceAssetAggregateArgs>): Prisma.PrismaPromise<GetResourceAssetAggregateType<T>>

    /**
     * Group by ResourceAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceAssetGroupByArgs['orderBy'] }
        : { orderBy?: ResourceAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceAsset model
   */
  readonly fields: ResourceAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceAsset model
   */
  interface ResourceAssetFieldRefs {
    readonly id: FieldRef<"ResourceAsset", 'String'>
    readonly resourceId: FieldRef<"ResourceAsset", 'String'>
    readonly fileUrl: FieldRef<"ResourceAsset", 'String'>
    readonly fileName: FieldRef<"ResourceAsset", 'String'>
    readonly mimeType: FieldRef<"ResourceAsset", 'String'>
    readonly sizeBytes: FieldRef<"ResourceAsset", 'Int'>
    readonly createdAt: FieldRef<"ResourceAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResourceAsset findUnique
   */
  export type ResourceAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAsset to fetch.
     */
    where: ResourceAssetWhereUniqueInput
  }

  /**
   * ResourceAsset findUniqueOrThrow
   */
  export type ResourceAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAsset to fetch.
     */
    where: ResourceAssetWhereUniqueInput
  }

  /**
   * ResourceAsset findFirst
   */
  export type ResourceAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAsset to fetch.
     */
    where?: ResourceAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceAssets to fetch.
     */
    orderBy?: ResourceAssetOrderByWithRelationInput | ResourceAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceAssets.
     */
    cursor?: ResourceAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceAssets.
     */
    distinct?: ResourceAssetScalarFieldEnum | ResourceAssetScalarFieldEnum[]
  }

  /**
   * ResourceAsset findFirstOrThrow
   */
  export type ResourceAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAsset to fetch.
     */
    where?: ResourceAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceAssets to fetch.
     */
    orderBy?: ResourceAssetOrderByWithRelationInput | ResourceAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceAssets.
     */
    cursor?: ResourceAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceAssets.
     */
    distinct?: ResourceAssetScalarFieldEnum | ResourceAssetScalarFieldEnum[]
  }

  /**
   * ResourceAsset findMany
   */
  export type ResourceAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAssets to fetch.
     */
    where?: ResourceAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceAssets to fetch.
     */
    orderBy?: ResourceAssetOrderByWithRelationInput | ResourceAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceAssets.
     */
    cursor?: ResourceAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceAssets.
     */
    skip?: number
    distinct?: ResourceAssetScalarFieldEnum | ResourceAssetScalarFieldEnum[]
  }

  /**
   * ResourceAsset create
   */
  export type ResourceAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceAsset.
     */
    data: XOR<ResourceAssetCreateInput, ResourceAssetUncheckedCreateInput>
  }

  /**
   * ResourceAsset createMany
   */
  export type ResourceAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceAssets.
     */
    data: ResourceAssetCreateManyInput | ResourceAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceAsset createManyAndReturn
   */
  export type ResourceAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceAssets.
     */
    data: ResourceAssetCreateManyInput | ResourceAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceAsset update
   */
  export type ResourceAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceAsset.
     */
    data: XOR<ResourceAssetUpdateInput, ResourceAssetUncheckedUpdateInput>
    /**
     * Choose, which ResourceAsset to update.
     */
    where: ResourceAssetWhereUniqueInput
  }

  /**
   * ResourceAsset updateMany
   */
  export type ResourceAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceAssets.
     */
    data: XOR<ResourceAssetUpdateManyMutationInput, ResourceAssetUncheckedUpdateManyInput>
    /**
     * Filter which ResourceAssets to update
     */
    where?: ResourceAssetWhereInput
    /**
     * Limit how many ResourceAssets to update.
     */
    limit?: number
  }

  /**
   * ResourceAsset updateManyAndReturn
   */
  export type ResourceAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * The data used to update ResourceAssets.
     */
    data: XOR<ResourceAssetUpdateManyMutationInput, ResourceAssetUncheckedUpdateManyInput>
    /**
     * Filter which ResourceAssets to update
     */
    where?: ResourceAssetWhereInput
    /**
     * Limit how many ResourceAssets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceAsset upsert
   */
  export type ResourceAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceAsset to update in case it exists.
     */
    where: ResourceAssetWhereUniqueInput
    /**
     * In case the ResourceAsset found by the `where` argument doesn't exist, create a new ResourceAsset with this data.
     */
    create: XOR<ResourceAssetCreateInput, ResourceAssetUncheckedCreateInput>
    /**
     * In case the ResourceAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceAssetUpdateInput, ResourceAssetUncheckedUpdateInput>
  }

  /**
   * ResourceAsset delete
   */
  export type ResourceAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
    /**
     * Filter which ResourceAsset to delete.
     */
    where: ResourceAssetWhereUniqueInput
  }

  /**
   * ResourceAsset deleteMany
   */
  export type ResourceAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceAssets to delete
     */
    where?: ResourceAssetWhereInput
    /**
     * Limit how many ResourceAssets to delete.
     */
    limit?: number
  }

  /**
   * ResourceAsset without action
   */
  export type ResourceAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAsset
     */
    select?: ResourceAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAsset
     */
    omit?: ResourceAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceAssetInclude<ExtArgs> | null
  }


  /**
   * Model ResourceDownloadLog
   */

  export type AggregateResourceDownloadLog = {
    _count: ResourceDownloadLogCountAggregateOutputType | null
    _min: ResourceDownloadLogMinAggregateOutputType | null
    _max: ResourceDownloadLogMaxAggregateOutputType | null
  }

  export type ResourceDownloadLogMinAggregateOutputType = {
    id: string | null
    resourceId: string | null
    userId: string | null
    downloadedAt: Date | null
    ipAddress: string | null
  }

  export type ResourceDownloadLogMaxAggregateOutputType = {
    id: string | null
    resourceId: string | null
    userId: string | null
    downloadedAt: Date | null
    ipAddress: string | null
  }

  export type ResourceDownloadLogCountAggregateOutputType = {
    id: number
    resourceId: number
    userId: number
    downloadedAt: number
    ipAddress: number
    _all: number
  }


  export type ResourceDownloadLogMinAggregateInputType = {
    id?: true
    resourceId?: true
    userId?: true
    downloadedAt?: true
    ipAddress?: true
  }

  export type ResourceDownloadLogMaxAggregateInputType = {
    id?: true
    resourceId?: true
    userId?: true
    downloadedAt?: true
    ipAddress?: true
  }

  export type ResourceDownloadLogCountAggregateInputType = {
    id?: true
    resourceId?: true
    userId?: true
    downloadedAt?: true
    ipAddress?: true
    _all?: true
  }

  export type ResourceDownloadLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceDownloadLog to aggregate.
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceDownloadLogs to fetch.
     */
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceDownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceDownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceDownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceDownloadLogs
    **/
    _count?: true | ResourceDownloadLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceDownloadLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceDownloadLogMaxAggregateInputType
  }

  export type GetResourceDownloadLogAggregateType<T extends ResourceDownloadLogAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceDownloadLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceDownloadLog[P]>
      : GetScalarType<T[P], AggregateResourceDownloadLog[P]>
  }




  export type ResourceDownloadLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceDownloadLogWhereInput
    orderBy?: ResourceDownloadLogOrderByWithAggregationInput | ResourceDownloadLogOrderByWithAggregationInput[]
    by: ResourceDownloadLogScalarFieldEnum[] | ResourceDownloadLogScalarFieldEnum
    having?: ResourceDownloadLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceDownloadLogCountAggregateInputType | true
    _min?: ResourceDownloadLogMinAggregateInputType
    _max?: ResourceDownloadLogMaxAggregateInputType
  }

  export type ResourceDownloadLogGroupByOutputType = {
    id: string
    resourceId: string
    userId: string
    downloadedAt: Date
    ipAddress: string
    _count: ResourceDownloadLogCountAggregateOutputType | null
    _min: ResourceDownloadLogMinAggregateOutputType | null
    _max: ResourceDownloadLogMaxAggregateOutputType | null
  }

  type GetResourceDownloadLogGroupByPayload<T extends ResourceDownloadLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceDownloadLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceDownloadLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceDownloadLogGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceDownloadLogGroupByOutputType[P]>
        }
      >
    >


  export type ResourceDownloadLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    userId?: boolean
    downloadedAt?: boolean
    ipAddress?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceDownloadLog"]>

  export type ResourceDownloadLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    userId?: boolean
    downloadedAt?: boolean
    ipAddress?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceDownloadLog"]>

  export type ResourceDownloadLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    userId?: boolean
    downloadedAt?: boolean
    ipAddress?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceDownloadLog"]>

  export type ResourceDownloadLogSelectScalar = {
    id?: boolean
    resourceId?: boolean
    userId?: boolean
    downloadedAt?: boolean
    ipAddress?: boolean
  }

  export type ResourceDownloadLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resourceId" | "userId" | "downloadedAt" | "ipAddress", ExtArgs["result"]["resourceDownloadLog"]>
  export type ResourceDownloadLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceDownloadLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceDownloadLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourceDownloadLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceDownloadLog"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resourceId: string
      userId: string
      downloadedAt: Date
      ipAddress: string
    }, ExtArgs["result"]["resourceDownloadLog"]>
    composites: {}
  }

  type ResourceDownloadLogGetPayload<S extends boolean | null | undefined | ResourceDownloadLogDefaultArgs> = $Result.GetResult<Prisma.$ResourceDownloadLogPayload, S>

  type ResourceDownloadLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceDownloadLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceDownloadLogCountAggregateInputType | true
    }

  export interface ResourceDownloadLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceDownloadLog'], meta: { name: 'ResourceDownloadLog' } }
    /**
     * Find zero or one ResourceDownloadLog that matches the filter.
     * @param {ResourceDownloadLogFindUniqueArgs} args - Arguments to find a ResourceDownloadLog
     * @example
     * // Get one ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceDownloadLogFindUniqueArgs>(args: SelectSubset<T, ResourceDownloadLogFindUniqueArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceDownloadLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceDownloadLogFindUniqueOrThrowArgs} args - Arguments to find a ResourceDownloadLog
     * @example
     * // Get one ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceDownloadLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceDownloadLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceDownloadLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogFindFirstArgs} args - Arguments to find a ResourceDownloadLog
     * @example
     * // Get one ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceDownloadLogFindFirstArgs>(args?: SelectSubset<T, ResourceDownloadLogFindFirstArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceDownloadLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogFindFirstOrThrowArgs} args - Arguments to find a ResourceDownloadLog
     * @example
     * // Get one ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceDownloadLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceDownloadLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceDownloadLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceDownloadLogs
     * const resourceDownloadLogs = await prisma.resourceDownloadLog.findMany()
     * 
     * // Get first 10 ResourceDownloadLogs
     * const resourceDownloadLogs = await prisma.resourceDownloadLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceDownloadLogWithIdOnly = await prisma.resourceDownloadLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceDownloadLogFindManyArgs>(args?: SelectSubset<T, ResourceDownloadLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceDownloadLog.
     * @param {ResourceDownloadLogCreateArgs} args - Arguments to create a ResourceDownloadLog.
     * @example
     * // Create one ResourceDownloadLog
     * const ResourceDownloadLog = await prisma.resourceDownloadLog.create({
     *   data: {
     *     // ... data to create a ResourceDownloadLog
     *   }
     * })
     * 
     */
    create<T extends ResourceDownloadLogCreateArgs>(args: SelectSubset<T, ResourceDownloadLogCreateArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceDownloadLogs.
     * @param {ResourceDownloadLogCreateManyArgs} args - Arguments to create many ResourceDownloadLogs.
     * @example
     * // Create many ResourceDownloadLogs
     * const resourceDownloadLog = await prisma.resourceDownloadLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceDownloadLogCreateManyArgs>(args?: SelectSubset<T, ResourceDownloadLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceDownloadLogs and returns the data saved in the database.
     * @param {ResourceDownloadLogCreateManyAndReturnArgs} args - Arguments to create many ResourceDownloadLogs.
     * @example
     * // Create many ResourceDownloadLogs
     * const resourceDownloadLog = await prisma.resourceDownloadLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceDownloadLogs and only return the `id`
     * const resourceDownloadLogWithIdOnly = await prisma.resourceDownloadLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceDownloadLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceDownloadLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceDownloadLog.
     * @param {ResourceDownloadLogDeleteArgs} args - Arguments to delete one ResourceDownloadLog.
     * @example
     * // Delete one ResourceDownloadLog
     * const ResourceDownloadLog = await prisma.resourceDownloadLog.delete({
     *   where: {
     *     // ... filter to delete one ResourceDownloadLog
     *   }
     * })
     * 
     */
    delete<T extends ResourceDownloadLogDeleteArgs>(args: SelectSubset<T, ResourceDownloadLogDeleteArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceDownloadLog.
     * @param {ResourceDownloadLogUpdateArgs} args - Arguments to update one ResourceDownloadLog.
     * @example
     * // Update one ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceDownloadLogUpdateArgs>(args: SelectSubset<T, ResourceDownloadLogUpdateArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceDownloadLogs.
     * @param {ResourceDownloadLogDeleteManyArgs} args - Arguments to filter ResourceDownloadLogs to delete.
     * @example
     * // Delete a few ResourceDownloadLogs
     * const { count } = await prisma.resourceDownloadLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDownloadLogDeleteManyArgs>(args?: SelectSubset<T, ResourceDownloadLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceDownloadLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceDownloadLogs
     * const resourceDownloadLog = await prisma.resourceDownloadLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceDownloadLogUpdateManyArgs>(args: SelectSubset<T, ResourceDownloadLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceDownloadLogs and returns the data updated in the database.
     * @param {ResourceDownloadLogUpdateManyAndReturnArgs} args - Arguments to update many ResourceDownloadLogs.
     * @example
     * // Update many ResourceDownloadLogs
     * const resourceDownloadLog = await prisma.resourceDownloadLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceDownloadLogs and only return the `id`
     * const resourceDownloadLogWithIdOnly = await prisma.resourceDownloadLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceDownloadLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceDownloadLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceDownloadLog.
     * @param {ResourceDownloadLogUpsertArgs} args - Arguments to update or create a ResourceDownloadLog.
     * @example
     * // Update or create a ResourceDownloadLog
     * const resourceDownloadLog = await prisma.resourceDownloadLog.upsert({
     *   create: {
     *     // ... data to create a ResourceDownloadLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceDownloadLog we want to update
     *   }
     * })
     */
    upsert<T extends ResourceDownloadLogUpsertArgs>(args: SelectSubset<T, ResourceDownloadLogUpsertArgs<ExtArgs>>): Prisma__ResourceDownloadLogClient<$Result.GetResult<Prisma.$ResourceDownloadLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceDownloadLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogCountArgs} args - Arguments to filter ResourceDownloadLogs to count.
     * @example
     * // Count the number of ResourceDownloadLogs
     * const count = await prisma.resourceDownloadLog.count({
     *   where: {
     *     // ... the filter for the ResourceDownloadLogs we want to count
     *   }
     * })
    **/
    count<T extends ResourceDownloadLogCountArgs>(
      args?: Subset<T, ResourceDownloadLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceDownloadLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceDownloadLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceDownloadLogAggregateArgs>(args: Subset<T, ResourceDownloadLogAggregateArgs>): Prisma.PrismaPromise<GetResourceDownloadLogAggregateType<T>>

    /**
     * Group by ResourceDownloadLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceDownloadLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceDownloadLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceDownloadLogGroupByArgs['orderBy'] }
        : { orderBy?: ResourceDownloadLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceDownloadLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceDownloadLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceDownloadLog model
   */
  readonly fields: ResourceDownloadLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceDownloadLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceDownloadLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceDownloadLog model
   */
  interface ResourceDownloadLogFieldRefs {
    readonly id: FieldRef<"ResourceDownloadLog", 'String'>
    readonly resourceId: FieldRef<"ResourceDownloadLog", 'String'>
    readonly userId: FieldRef<"ResourceDownloadLog", 'String'>
    readonly downloadedAt: FieldRef<"ResourceDownloadLog", 'DateTime'>
    readonly ipAddress: FieldRef<"ResourceDownloadLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResourceDownloadLog findUnique
   */
  export type ResourceDownloadLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which ResourceDownloadLog to fetch.
     */
    where: ResourceDownloadLogWhereUniqueInput
  }

  /**
   * ResourceDownloadLog findUniqueOrThrow
   */
  export type ResourceDownloadLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which ResourceDownloadLog to fetch.
     */
    where: ResourceDownloadLogWhereUniqueInput
  }

  /**
   * ResourceDownloadLog findFirst
   */
  export type ResourceDownloadLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which ResourceDownloadLog to fetch.
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceDownloadLogs to fetch.
     */
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceDownloadLogs.
     */
    cursor?: ResourceDownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceDownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceDownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceDownloadLogs.
     */
    distinct?: ResourceDownloadLogScalarFieldEnum | ResourceDownloadLogScalarFieldEnum[]
  }

  /**
   * ResourceDownloadLog findFirstOrThrow
   */
  export type ResourceDownloadLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which ResourceDownloadLog to fetch.
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceDownloadLogs to fetch.
     */
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceDownloadLogs.
     */
    cursor?: ResourceDownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceDownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceDownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceDownloadLogs.
     */
    distinct?: ResourceDownloadLogScalarFieldEnum | ResourceDownloadLogScalarFieldEnum[]
  }

  /**
   * ResourceDownloadLog findMany
   */
  export type ResourceDownloadLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which ResourceDownloadLogs to fetch.
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceDownloadLogs to fetch.
     */
    orderBy?: ResourceDownloadLogOrderByWithRelationInput | ResourceDownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceDownloadLogs.
     */
    cursor?: ResourceDownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceDownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceDownloadLogs.
     */
    skip?: number
    distinct?: ResourceDownloadLogScalarFieldEnum | ResourceDownloadLogScalarFieldEnum[]
  }

  /**
   * ResourceDownloadLog create
   */
  export type ResourceDownloadLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceDownloadLog.
     */
    data: XOR<ResourceDownloadLogCreateInput, ResourceDownloadLogUncheckedCreateInput>
  }

  /**
   * ResourceDownloadLog createMany
   */
  export type ResourceDownloadLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceDownloadLogs.
     */
    data: ResourceDownloadLogCreateManyInput | ResourceDownloadLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceDownloadLog createManyAndReturn
   */
  export type ResourceDownloadLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceDownloadLogs.
     */
    data: ResourceDownloadLogCreateManyInput | ResourceDownloadLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceDownloadLog update
   */
  export type ResourceDownloadLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceDownloadLog.
     */
    data: XOR<ResourceDownloadLogUpdateInput, ResourceDownloadLogUncheckedUpdateInput>
    /**
     * Choose, which ResourceDownloadLog to update.
     */
    where: ResourceDownloadLogWhereUniqueInput
  }

  /**
   * ResourceDownloadLog updateMany
   */
  export type ResourceDownloadLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceDownloadLogs.
     */
    data: XOR<ResourceDownloadLogUpdateManyMutationInput, ResourceDownloadLogUncheckedUpdateManyInput>
    /**
     * Filter which ResourceDownloadLogs to update
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * Limit how many ResourceDownloadLogs to update.
     */
    limit?: number
  }

  /**
   * ResourceDownloadLog updateManyAndReturn
   */
  export type ResourceDownloadLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * The data used to update ResourceDownloadLogs.
     */
    data: XOR<ResourceDownloadLogUpdateManyMutationInput, ResourceDownloadLogUncheckedUpdateManyInput>
    /**
     * Filter which ResourceDownloadLogs to update
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * Limit how many ResourceDownloadLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceDownloadLog upsert
   */
  export type ResourceDownloadLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceDownloadLog to update in case it exists.
     */
    where: ResourceDownloadLogWhereUniqueInput
    /**
     * In case the ResourceDownloadLog found by the `where` argument doesn't exist, create a new ResourceDownloadLog with this data.
     */
    create: XOR<ResourceDownloadLogCreateInput, ResourceDownloadLogUncheckedCreateInput>
    /**
     * In case the ResourceDownloadLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceDownloadLogUpdateInput, ResourceDownloadLogUncheckedUpdateInput>
  }

  /**
   * ResourceDownloadLog delete
   */
  export type ResourceDownloadLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
    /**
     * Filter which ResourceDownloadLog to delete.
     */
    where: ResourceDownloadLogWhereUniqueInput
  }

  /**
   * ResourceDownloadLog deleteMany
   */
  export type ResourceDownloadLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceDownloadLogs to delete
     */
    where?: ResourceDownloadLogWhereInput
    /**
     * Limit how many ResourceDownloadLogs to delete.
     */
    limit?: number
  }

  /**
   * ResourceDownloadLog without action
   */
  export type ResourceDownloadLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceDownloadLog
     */
    select?: ResourceDownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceDownloadLog
     */
    omit?: ResourceDownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceDownloadLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    profileDisplayName: 'profileDisplayName',
    profileAvatarUrl: 'profileAvatarUrl',
    profileBio: 'profileBio',
    profileTimezone: 'profileTimezone',
    profileBadges: 'profileBadges',
    profileSocialLinks: 'profileSocialLinks',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshTokenHash: 'refreshTokenHash',
    device: 'device',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const MemberAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    feature: 'feature',
    enabled: 'enabled',
    permissions: 'permissions',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberAccessScalarFieldEnum = (typeof MemberAccessScalarFieldEnum)[keyof typeof MemberAccessScalarFieldEnum]


  export const HeroBannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    primaryCtaLabel: 'primaryCtaLabel',
    primaryCtaHref: 'primaryCtaHref',
    primaryCtaExternal: 'primaryCtaExternal',
    secondaryCtaLabel: 'secondaryCtaLabel',
    secondaryCtaHref: 'secondaryCtaHref',
    secondaryCtaExternal: 'secondaryCtaExternal',
    imageUrl: 'imageUrl',
    order: 'order',
    status: 'status',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroBannerScalarFieldEnum = (typeof HeroBannerScalarFieldEnum)[keyof typeof HeroBannerScalarFieldEnum]


  export const FeatureToggleScalarFieldEnum: {
    id: 'id',
    featureKey: 'featureKey',
    description: 'description',
    status: 'status',
    rolloutPercentage: 'rolloutPercentage',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureToggleScalarFieldEnum = (typeof FeatureToggleScalarFieldEnum)[keyof typeof FeatureToggleScalarFieldEnum]


  export const MemberAccessOverrideScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    feature: 'feature',
    enabled: 'enabled',
    permissions: 'permissions',
    reason: 'reason',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt'
  };

  export type MemberAccessOverrideScalarFieldEnum = (typeof MemberAccessOverrideScalarFieldEnum)[keyof typeof MemberAccessOverrideScalarFieldEnum]


  export const InvitationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    bodyMarkdown: 'bodyMarkdown',
    visibility: 'visibility',
    createdAt: 'createdAt'
  };

  export type InvitationTemplateScalarFieldEnum = (typeof InvitationTemplateScalarFieldEnum)[keyof typeof InvitationTemplateScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    email: 'email',
    role: 'role',
    status: 'status',
    invitedById: 'invitedById',
    grantedAccess: 'grantedAccess',
    expiresAt: 'expiresAt',
    acceptedById: 'acceptedById',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    coverImage: 'coverImage',
    level: 'level',
    status: 'status',
    visibility: 'visibility',
    estimatedDurationMinutes: 'estimatedDurationMinutes',
    totalLessons: 'totalLessons',
    tags: 'tags',
    releaseDate: 'releaseDate',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isFeatured: 'isFeatured',
    recommendationScore: 'recommendationScore'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    order: 'order',
    title: 'title',
    description: 'description',
    durationMinutes: 'durationMinutes',
    dripDaysAfter: 'dripDaysAfter',
    dripReleaseAt: 'dripReleaseAt',
    dripAfterModuleId: 'dripAfterModuleId'
  };

  export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    order: 'order',
    title: 'title',
    summary: 'summary',
    type: 'type',
    content: 'content',
    durationMinutes: 'durationMinutes',
    isPreview: 'isPreview',
    releaseAt: 'releaseAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const CourseProgressScalarFieldEnum: {
    courseId: 'courseId',
    userId: 'userId',
    completedLessonIds: 'completedLessonIds',
    percentage: 'percentage',
    lastLessonId: 'lastLessonId',
    updatedAt: 'updatedAt'
  };

  export type CourseProgressScalarFieldEnum = (typeof CourseProgressScalarFieldEnum)[keyof typeof CourseProgressScalarFieldEnum]


  export const LessonCommentScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    userId: 'userId',
    body: 'body',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pendingModeration: 'pendingModeration',
    moderatedAt: 'moderatedAt',
    moderatedById: 'moderatedById',
    moderationStatus: 'moderationStatus'
  };

  export type LessonCommentScalarFieldEnum = (typeof LessonCommentScalarFieldEnum)[keyof typeof LessonCommentScalarFieldEnum]


  export const LessonCommentReplyScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    body: 'body',
    createdAt: 'createdAt',
    moderatedAt: 'moderatedAt',
    moderatedById: 'moderatedById',
    moderationStatus: 'moderationStatus',
    parentReplyId: 'parentReplyId',
    pendingModeration: 'pendingModeration',
    updatedAt: 'updatedAt'
  };

  export type LessonCommentReplyScalarFieldEnum = (typeof LessonCommentReplyScalarFieldEnum)[keyof typeof LessonCommentReplyScalarFieldEnum]


  export const CourseRecommendationScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    reason: 'reason',
    badge: 'badge'
  };

  export type CourseRecommendationScalarFieldEnum = (typeof CourseRecommendationScalarFieldEnum)[keyof typeof CourseRecommendationScalarFieldEnum]


  export const LessonRatingScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    userId: 'userId',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type LessonRatingScalarFieldEnum = (typeof LessonRatingScalarFieldEnum)[keyof typeof LessonRatingScalarFieldEnum]


  export const LessonProgressEventScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    userId: 'userId',
    occurredAt: 'occurredAt',
    positionSec: 'positionSec'
  };

  export type LessonProgressEventScalarFieldEnum = (typeof LessonProgressEventScalarFieldEnum)[keyof typeof LessonProgressEventScalarFieldEnum]


  export const LessonProgressAggregateScalarFieldEnum: {
    lessonId: 'lessonId',
    userId: 'userId',
    lastPositionSec: 'lastPositionSec',
    percentage: 'percentage',
    updatedAt: 'updatedAt'
  };

  export type LessonProgressAggregateScalarFieldEnum = (typeof LessonProgressAggregateScalarFieldEnum)[keyof typeof LessonProgressAggregateScalarFieldEnum]


  export const EvolutionApiConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    baseUrl: 'baseUrl',
    apiKeyEncrypted: 'apiKeyEncrypted',
    connectedAt: 'connectedAt',
    lastHealthCheckAt: 'lastHealthCheckAt',
    status: 'status',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvolutionApiConfigScalarFieldEnum = (typeof EvolutionApiConfigScalarFieldEnum)[keyof typeof EvolutionApiConfigScalarFieldEnum]


  export const ContactSegmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    importSource: 'importSource',
    totalContacts: 'totalContacts',
    createdAt: 'createdAt'
  };

  export type ContactSegmentScalarFieldEnum = (typeof ContactSegmentScalarFieldEnum)[keyof typeof ContactSegmentScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    variables: 'variables',
    mediaUrl: 'mediaUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    evolutionConfigId: 'evolutionConfigId',
    name: 'name',
    description: 'description',
    channel: 'channel',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    segmentId: 'segmentId',
    templateId: 'templateId',
    externalId: 'externalId',
    maxMessagesPerMinute: 'maxMessagesPerMinute',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignRunScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    initiatedBy: 'initiatedBy',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    summary: 'summary'
  };

  export type CampaignRunScalarFieldEnum = (typeof CampaignRunScalarFieldEnum)[keyof typeof CampaignRunScalarFieldEnum]


  export const CampaignMetricsScalarFieldEnum: {
    campaignId: 'campaignId',
    totalMessages: 'totalMessages',
    delivered: 'delivered',
    failed: 'failed',
    pending: 'pending',
    averageDeliveryMs: 'averageDeliveryMs',
    lastUpdatedAt: 'lastUpdatedAt'
  };

  export type CampaignMetricsScalarFieldEnum = (typeof CampaignMetricsScalarFieldEnum)[keyof typeof CampaignMetricsScalarFieldEnum]


  export const CampaignTimelinePointScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    timestamp: 'timestamp',
    delivered: 'delivered',
    failed: 'failed'
  };

  export type CampaignTimelinePointScalarFieldEnum = (typeof CampaignTimelinePointScalarFieldEnum)[keyof typeof CampaignTimelinePointScalarFieldEnum]


  export const ResourceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ResourceCategoryScalarFieldEnum = (typeof ResourceCategoryScalarFieldEnum)[keyof typeof ResourceCategoryScalarFieldEnum]


  export const ResourceTagScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ResourceTagScalarFieldEnum = (typeof ResourceTagScalarFieldEnum)[keyof typeof ResourceTagScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    type: 'type',
    categoryId: 'categoryId',
    thumbnailUrl: 'thumbnailUrl',
    visibility: 'visibility',
    featured: 'featured',
    downloadCount: 'downloadCount',
    viewCount: 'viewCount',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const ResourceTagAssignmentScalarFieldEnum: {
    resourceId: 'resourceId',
    tagId: 'tagId'
  };

  export type ResourceTagAssignmentScalarFieldEnum = (typeof ResourceTagAssignmentScalarFieldEnum)[keyof typeof ResourceTagAssignmentScalarFieldEnum]


  export const ResourceAssetScalarFieldEnum: {
    id: 'id',
    resourceId: 'resourceId',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt'
  };

  export type ResourceAssetScalarFieldEnum = (typeof ResourceAssetScalarFieldEnum)[keyof typeof ResourceAssetScalarFieldEnum]


  export const ResourceDownloadLogScalarFieldEnum: {
    id: 'id',
    resourceId: 'resourceId',
    userId: 'userId',
    downloadedAt: 'downloadedAt',
    ipAddress: 'ipAddress'
  };

  export type ResourceDownloadLogScalarFieldEnum = (typeof ResourceDownloadLogScalarFieldEnum)[keyof typeof ResourceDownloadLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FeatureAccessKey'
   */
  export type EnumFeatureAccessKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureAccessKey'>
    


  /**
   * Reference to a field of type 'FeatureAccessKey[]'
   */
  export type ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureAccessKey[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BannerStatus'
   */
  export type EnumBannerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BannerStatus'>
    


  /**
   * Reference to a field of type 'BannerStatus[]'
   */
  export type ListEnumBannerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BannerStatus[]'>
    


  /**
   * Reference to a field of type 'FeatureToggleStatus'
   */
  export type EnumFeatureToggleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureToggleStatus'>
    


  /**
   * Reference to a field of type 'FeatureToggleStatus[]'
   */
  export type ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureToggleStatus[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'CourseLevel'
   */
  export type EnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel'>
    


  /**
   * Reference to a field of type 'CourseLevel[]'
   */
  export type ListEnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel[]'>
    


  /**
   * Reference to a field of type 'CourseStatus'
   */
  export type EnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus'>
    


  /**
   * Reference to a field of type 'CourseStatus[]'
   */
  export type ListEnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'LessonCommentModerationStatus'
   */
  export type EnumLessonCommentModerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonCommentModerationStatus'>
    


  /**
   * Reference to a field of type 'LessonCommentModerationStatus[]'
   */
  export type ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonCommentModerationStatus[]'>
    


  /**
   * Reference to a field of type 'RecommendationBadge'
   */
  export type EnumRecommendationBadgeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationBadge'>
    


  /**
   * Reference to a field of type 'RecommendationBadge[]'
   */
  export type ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationBadge[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'EvolutionConnectionStatus'
   */
  export type EnumEvolutionConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvolutionConnectionStatus'>
    


  /**
   * Reference to a field of type 'EvolutionConnectionStatus[]'
   */
  export type ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvolutionConnectionStatus[]'>
    


  /**
   * Reference to a field of type 'ContactImportSource'
   */
  export type EnumContactImportSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactImportSource'>
    


  /**
   * Reference to a field of type 'ContactImportSource[]'
   */
  export type ListEnumContactImportSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactImportSource[]'>
    


  /**
   * Reference to a field of type 'CampaignChannel'
   */
  export type EnumCampaignChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignChannel'>
    


  /**
   * Reference to a field of type 'CampaignChannel[]'
   */
  export type ListEnumCampaignChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignChannel[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profileDisplayName?: StringFilter<"User"> | string
    profileAvatarUrl?: StringNullableFilter<"User"> | string | null
    profileBio?: StringNullableFilter<"User"> | string | null
    profileTimezone?: StringFilter<"User"> | string
    profileBadges?: StringNullableListFilter<"User">
    profileSocialLinks?: JsonFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    courseProgresses?: CourseProgressListRelationFilter
    coursesAuthored?: CourseListRelationFilter
    moderatedLessonCommentReplies?: LessonCommentReplyListRelationFilter
    lessonCommentReplies?: LessonCommentReplyListRelationFilter
    moderatedLessonComments?: LessonCommentListRelationFilter
    lessonComments?: LessonCommentListRelationFilter
    LessonProgressAggregate?: LessonProgressAggregateListRelationFilter
    LessonProgressEvent?: LessonProgressEventListRelationFilter
    LessonRating?: LessonRatingListRelationFilter
    featureTogglesCreated?: FeatureToggleListRelationFilter
    createdBanners?: HeroBannerListRelationFilter
    invitationsAccepted?: InvitationListRelationFilter
    invitationsSent?: InvitationListRelationFilter
    overridesGranted?: MemberAccessOverrideListRelationFilter
    accessOverrides?: MemberAccessOverrideListRelationFilter
    memberAccessGrants?: MemberAccessListRelationFilter
    memberAccesses?: MemberAccessListRelationFilter
    sessions?: SessionListRelationFilter
    resourceDownloadLogs?: ResourceDownloadLogListRelationFilter
    resourcesAuthored?: ResourceListRelationFilter
    campaignRunsInitiated?: CampaignRunListRelationFilter
    campaigns?: CampaignListRelationFilter
    contactSegments?: ContactSegmentListRelationFilter
    evolutionConfig?: XOR<EvolutionApiConfigNullableScalarRelationFilter, EvolutionApiConfigWhereInput> | null
    messageTemplates?: MessageTemplateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    profileDisplayName?: SortOrder
    profileAvatarUrl?: SortOrderInput | SortOrder
    profileBio?: SortOrderInput | SortOrder
    profileTimezone?: SortOrder
    profileBadges?: SortOrder
    profileSocialLinks?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseProgresses?: CourseProgressOrderByRelationAggregateInput
    coursesAuthored?: CourseOrderByRelationAggregateInput
    moderatedLessonCommentReplies?: LessonCommentReplyOrderByRelationAggregateInput
    lessonCommentReplies?: LessonCommentReplyOrderByRelationAggregateInput
    moderatedLessonComments?: LessonCommentOrderByRelationAggregateInput
    lessonComments?: LessonCommentOrderByRelationAggregateInput
    LessonProgressAggregate?: LessonProgressAggregateOrderByRelationAggregateInput
    LessonProgressEvent?: LessonProgressEventOrderByRelationAggregateInput
    LessonRating?: LessonRatingOrderByRelationAggregateInput
    featureTogglesCreated?: FeatureToggleOrderByRelationAggregateInput
    createdBanners?: HeroBannerOrderByRelationAggregateInput
    invitationsAccepted?: InvitationOrderByRelationAggregateInput
    invitationsSent?: InvitationOrderByRelationAggregateInput
    overridesGranted?: MemberAccessOverrideOrderByRelationAggregateInput
    accessOverrides?: MemberAccessOverrideOrderByRelationAggregateInput
    memberAccessGrants?: MemberAccessOrderByRelationAggregateInput
    memberAccesses?: MemberAccessOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    resourceDownloadLogs?: ResourceDownloadLogOrderByRelationAggregateInput
    resourcesAuthored?: ResourceOrderByRelationAggregateInput
    campaignRunsInitiated?: CampaignRunOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    contactSegments?: ContactSegmentOrderByRelationAggregateInput
    evolutionConfig?: EvolutionApiConfigOrderByWithRelationInput
    messageTemplates?: MessageTemplateOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profileDisplayName?: StringFilter<"User"> | string
    profileAvatarUrl?: StringNullableFilter<"User"> | string | null
    profileBio?: StringNullableFilter<"User"> | string | null
    profileTimezone?: StringFilter<"User"> | string
    profileBadges?: StringNullableListFilter<"User">
    profileSocialLinks?: JsonFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    courseProgresses?: CourseProgressListRelationFilter
    coursesAuthored?: CourseListRelationFilter
    moderatedLessonCommentReplies?: LessonCommentReplyListRelationFilter
    lessonCommentReplies?: LessonCommentReplyListRelationFilter
    moderatedLessonComments?: LessonCommentListRelationFilter
    lessonComments?: LessonCommentListRelationFilter
    LessonProgressAggregate?: LessonProgressAggregateListRelationFilter
    LessonProgressEvent?: LessonProgressEventListRelationFilter
    LessonRating?: LessonRatingListRelationFilter
    featureTogglesCreated?: FeatureToggleListRelationFilter
    createdBanners?: HeroBannerListRelationFilter
    invitationsAccepted?: InvitationListRelationFilter
    invitationsSent?: InvitationListRelationFilter
    overridesGranted?: MemberAccessOverrideListRelationFilter
    accessOverrides?: MemberAccessOverrideListRelationFilter
    memberAccessGrants?: MemberAccessListRelationFilter
    memberAccesses?: MemberAccessListRelationFilter
    sessions?: SessionListRelationFilter
    resourceDownloadLogs?: ResourceDownloadLogListRelationFilter
    resourcesAuthored?: ResourceListRelationFilter
    campaignRunsInitiated?: CampaignRunListRelationFilter
    campaigns?: CampaignListRelationFilter
    contactSegments?: ContactSegmentListRelationFilter
    evolutionConfig?: XOR<EvolutionApiConfigNullableScalarRelationFilter, EvolutionApiConfigWhereInput> | null
    messageTemplates?: MessageTemplateListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    profileDisplayName?: SortOrder
    profileAvatarUrl?: SortOrderInput | SortOrder
    profileBio?: SortOrderInput | SortOrder
    profileTimezone?: SortOrder
    profileBadges?: SortOrder
    profileSocialLinks?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    profileDisplayName?: StringWithAggregatesFilter<"User"> | string
    profileAvatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileBio?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileTimezone?: StringWithAggregatesFilter<"User"> | string
    profileBadges?: StringNullableListFilter<"User">
    profileSocialLinks?: JsonWithAggregatesFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshTokenHash?: StringFilter<"Session"> | string
    device?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    ipAddress?: StringFilter<"Session"> | string
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    device?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshTokenHash?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    device?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    ipAddress?: StringFilter<"Session"> | string
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refreshTokenHash">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    device?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshTokenHash?: StringWithAggregatesFilter<"Session"> | string
    device?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringWithAggregatesFilter<"Session"> | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type MemberAccessWhereInput = {
    AND?: MemberAccessWhereInput | MemberAccessWhereInput[]
    OR?: MemberAccessWhereInput[]
    NOT?: MemberAccessWhereInput | MemberAccessWhereInput[]
    id?: StringFilter<"MemberAccess"> | string
    userId?: StringFilter<"MemberAccess"> | string
    feature?: EnumFeatureAccessKeyFilter<"MemberAccess"> | $Enums.FeatureAccessKey
    enabled?: BoolFilter<"MemberAccess"> | boolean
    permissions?: StringNullableListFilter<"MemberAccess">
    grantedById?: StringNullableFilter<"MemberAccess"> | string | null
    grantedAt?: DateTimeNullableFilter<"MemberAccess"> | Date | string | null
    createdAt?: DateTimeFilter<"MemberAccess"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAccess"> | Date | string
    grantedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    grantedById?: SortOrderInput | SortOrder
    grantedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grantedBy?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_feature?: MemberAccessUserIdFeatureCompoundUniqueInput
    AND?: MemberAccessWhereInput | MemberAccessWhereInput[]
    OR?: MemberAccessWhereInput[]
    NOT?: MemberAccessWhereInput | MemberAccessWhereInput[]
    userId?: StringFilter<"MemberAccess"> | string
    feature?: EnumFeatureAccessKeyFilter<"MemberAccess"> | $Enums.FeatureAccessKey
    enabled?: BoolFilter<"MemberAccess"> | boolean
    permissions?: StringNullableListFilter<"MemberAccess">
    grantedById?: StringNullableFilter<"MemberAccess"> | string | null
    grantedAt?: DateTimeNullableFilter<"MemberAccess"> | Date | string | null
    createdAt?: DateTimeFilter<"MemberAccess"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAccess"> | Date | string
    grantedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_feature">

  export type MemberAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    grantedById?: SortOrderInput | SortOrder
    grantedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberAccessCountOrderByAggregateInput
    _max?: MemberAccessMaxOrderByAggregateInput
    _min?: MemberAccessMinOrderByAggregateInput
  }

  export type MemberAccessScalarWhereWithAggregatesInput = {
    AND?: MemberAccessScalarWhereWithAggregatesInput | MemberAccessScalarWhereWithAggregatesInput[]
    OR?: MemberAccessScalarWhereWithAggregatesInput[]
    NOT?: MemberAccessScalarWhereWithAggregatesInput | MemberAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MemberAccess"> | string
    userId?: StringWithAggregatesFilter<"MemberAccess"> | string
    feature?: EnumFeatureAccessKeyWithAggregatesFilter<"MemberAccess"> | $Enums.FeatureAccessKey
    enabled?: BoolWithAggregatesFilter<"MemberAccess"> | boolean
    permissions?: StringNullableListFilter<"MemberAccess">
    grantedById?: StringNullableWithAggregatesFilter<"MemberAccess"> | string | null
    grantedAt?: DateTimeNullableWithAggregatesFilter<"MemberAccess"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MemberAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberAccess"> | Date | string
  }

  export type HeroBannerWhereInput = {
    AND?: HeroBannerWhereInput | HeroBannerWhereInput[]
    OR?: HeroBannerWhereInput[]
    NOT?: HeroBannerWhereInput | HeroBannerWhereInput[]
    id?: StringFilter<"HeroBanner"> | string
    title?: StringFilter<"HeroBanner"> | string
    description?: StringFilter<"HeroBanner"> | string
    primaryCtaLabel?: StringFilter<"HeroBanner"> | string
    primaryCtaHref?: StringFilter<"HeroBanner"> | string
    primaryCtaExternal?: BoolFilter<"HeroBanner"> | boolean
    secondaryCtaLabel?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaHref?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaExternal?: BoolNullableFilter<"HeroBanner"> | boolean | null
    imageUrl?: StringFilter<"HeroBanner"> | string
    order?: IntFilter<"HeroBanner"> | number
    status?: EnumBannerStatusFilter<"HeroBanner"> | $Enums.BannerStatus
    startsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    createdById?: StringFilter<"HeroBanner"> | string
    createdAt?: DateTimeFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBanner"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type HeroBannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    primaryCtaLabel?: SortOrder
    primaryCtaHref?: SortOrder
    primaryCtaExternal?: SortOrder
    secondaryCtaLabel?: SortOrderInput | SortOrder
    secondaryCtaHref?: SortOrderInput | SortOrder
    secondaryCtaExternal?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type HeroBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroBannerWhereInput | HeroBannerWhereInput[]
    OR?: HeroBannerWhereInput[]
    NOT?: HeroBannerWhereInput | HeroBannerWhereInput[]
    title?: StringFilter<"HeroBanner"> | string
    description?: StringFilter<"HeroBanner"> | string
    primaryCtaLabel?: StringFilter<"HeroBanner"> | string
    primaryCtaHref?: StringFilter<"HeroBanner"> | string
    primaryCtaExternal?: BoolFilter<"HeroBanner"> | boolean
    secondaryCtaLabel?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaHref?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaExternal?: BoolNullableFilter<"HeroBanner"> | boolean | null
    imageUrl?: StringFilter<"HeroBanner"> | string
    order?: IntFilter<"HeroBanner"> | number
    status?: EnumBannerStatusFilter<"HeroBanner"> | $Enums.BannerStatus
    startsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    createdById?: StringFilter<"HeroBanner"> | string
    createdAt?: DateTimeFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBanner"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type HeroBannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    primaryCtaLabel?: SortOrder
    primaryCtaHref?: SortOrder
    primaryCtaExternal?: SortOrder
    secondaryCtaLabel?: SortOrderInput | SortOrder
    secondaryCtaHref?: SortOrderInput | SortOrder
    secondaryCtaExternal?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroBannerCountOrderByAggregateInput
    _avg?: HeroBannerAvgOrderByAggregateInput
    _max?: HeroBannerMaxOrderByAggregateInput
    _min?: HeroBannerMinOrderByAggregateInput
    _sum?: HeroBannerSumOrderByAggregateInput
  }

  export type HeroBannerScalarWhereWithAggregatesInput = {
    AND?: HeroBannerScalarWhereWithAggregatesInput | HeroBannerScalarWhereWithAggregatesInput[]
    OR?: HeroBannerScalarWhereWithAggregatesInput[]
    NOT?: HeroBannerScalarWhereWithAggregatesInput | HeroBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroBanner"> | string
    title?: StringWithAggregatesFilter<"HeroBanner"> | string
    description?: StringWithAggregatesFilter<"HeroBanner"> | string
    primaryCtaLabel?: StringWithAggregatesFilter<"HeroBanner"> | string
    primaryCtaHref?: StringWithAggregatesFilter<"HeroBanner"> | string
    primaryCtaExternal?: BoolWithAggregatesFilter<"HeroBanner"> | boolean
    secondaryCtaLabel?: StringNullableWithAggregatesFilter<"HeroBanner"> | string | null
    secondaryCtaHref?: StringNullableWithAggregatesFilter<"HeroBanner"> | string | null
    secondaryCtaExternal?: BoolNullableWithAggregatesFilter<"HeroBanner"> | boolean | null
    imageUrl?: StringWithAggregatesFilter<"HeroBanner"> | string
    order?: IntWithAggregatesFilter<"HeroBanner"> | number
    status?: EnumBannerStatusWithAggregatesFilter<"HeroBanner"> | $Enums.BannerStatus
    startsAt?: DateTimeNullableWithAggregatesFilter<"HeroBanner"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"HeroBanner"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"HeroBanner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroBanner"> | Date | string
  }

  export type FeatureToggleWhereInput = {
    AND?: FeatureToggleWhereInput | FeatureToggleWhereInput[]
    OR?: FeatureToggleWhereInput[]
    NOT?: FeatureToggleWhereInput | FeatureToggleWhereInput[]
    id?: StringFilter<"FeatureToggle"> | string
    featureKey?: StringFilter<"FeatureToggle"> | string
    description?: StringFilter<"FeatureToggle"> | string
    status?: EnumFeatureToggleStatusFilter<"FeatureToggle"> | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFilter<"FeatureToggle"> | number
    createdById?: StringFilter<"FeatureToggle"> | string
    createdAt?: DateTimeFilter<"FeatureToggle"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureToggle"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeatureToggleOrderByWithRelationInput = {
    id?: SortOrder
    featureKey?: SortOrder
    description?: SortOrder
    status?: SortOrder
    rolloutPercentage?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type FeatureToggleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    featureKey?: string
    AND?: FeatureToggleWhereInput | FeatureToggleWhereInput[]
    OR?: FeatureToggleWhereInput[]
    NOT?: FeatureToggleWhereInput | FeatureToggleWhereInput[]
    description?: StringFilter<"FeatureToggle"> | string
    status?: EnumFeatureToggleStatusFilter<"FeatureToggle"> | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFilter<"FeatureToggle"> | number
    createdById?: StringFilter<"FeatureToggle"> | string
    createdAt?: DateTimeFilter<"FeatureToggle"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureToggle"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "featureKey">

  export type FeatureToggleOrderByWithAggregationInput = {
    id?: SortOrder
    featureKey?: SortOrder
    description?: SortOrder
    status?: SortOrder
    rolloutPercentage?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureToggleCountOrderByAggregateInput
    _avg?: FeatureToggleAvgOrderByAggregateInput
    _max?: FeatureToggleMaxOrderByAggregateInput
    _min?: FeatureToggleMinOrderByAggregateInput
    _sum?: FeatureToggleSumOrderByAggregateInput
  }

  export type FeatureToggleScalarWhereWithAggregatesInput = {
    AND?: FeatureToggleScalarWhereWithAggregatesInput | FeatureToggleScalarWhereWithAggregatesInput[]
    OR?: FeatureToggleScalarWhereWithAggregatesInput[]
    NOT?: FeatureToggleScalarWhereWithAggregatesInput | FeatureToggleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeatureToggle"> | string
    featureKey?: StringWithAggregatesFilter<"FeatureToggle"> | string
    description?: StringWithAggregatesFilter<"FeatureToggle"> | string
    status?: EnumFeatureToggleStatusWithAggregatesFilter<"FeatureToggle"> | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntWithAggregatesFilter<"FeatureToggle"> | number
    createdById?: StringWithAggregatesFilter<"FeatureToggle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeatureToggle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureToggle"> | Date | string
  }

  export type MemberAccessOverrideWhereInput = {
    AND?: MemberAccessOverrideWhereInput | MemberAccessOverrideWhereInput[]
    OR?: MemberAccessOverrideWhereInput[]
    NOT?: MemberAccessOverrideWhereInput | MemberAccessOverrideWhereInput[]
    id?: StringFilter<"MemberAccessOverride"> | string
    userId?: StringFilter<"MemberAccessOverride"> | string
    feature?: StringFilter<"MemberAccessOverride"> | string
    enabled?: BoolFilter<"MemberAccessOverride"> | boolean
    permissions?: StringNullableListFilter<"MemberAccessOverride">
    reason?: StringFilter<"MemberAccessOverride"> | string
    grantedById?: StringFilter<"MemberAccessOverride"> | string
    grantedAt?: DateTimeFilter<"MemberAccessOverride"> | Date | string
    grantedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberAccessOverrideOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    reason?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberAccessOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_feature?: MemberAccessOverrideUserIdFeatureCompoundUniqueInput
    AND?: MemberAccessOverrideWhereInput | MemberAccessOverrideWhereInput[]
    OR?: MemberAccessOverrideWhereInput[]
    NOT?: MemberAccessOverrideWhereInput | MemberAccessOverrideWhereInput[]
    userId?: StringFilter<"MemberAccessOverride"> | string
    feature?: StringFilter<"MemberAccessOverride"> | string
    enabled?: BoolFilter<"MemberAccessOverride"> | boolean
    permissions?: StringNullableListFilter<"MemberAccessOverride">
    reason?: StringFilter<"MemberAccessOverride"> | string
    grantedById?: StringFilter<"MemberAccessOverride"> | string
    grantedAt?: DateTimeFilter<"MemberAccessOverride"> | Date | string
    grantedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_feature">

  export type MemberAccessOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    reason?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    _count?: MemberAccessOverrideCountOrderByAggregateInput
    _max?: MemberAccessOverrideMaxOrderByAggregateInput
    _min?: MemberAccessOverrideMinOrderByAggregateInput
  }

  export type MemberAccessOverrideScalarWhereWithAggregatesInput = {
    AND?: MemberAccessOverrideScalarWhereWithAggregatesInput | MemberAccessOverrideScalarWhereWithAggregatesInput[]
    OR?: MemberAccessOverrideScalarWhereWithAggregatesInput[]
    NOT?: MemberAccessOverrideScalarWhereWithAggregatesInput | MemberAccessOverrideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MemberAccessOverride"> | string
    userId?: StringWithAggregatesFilter<"MemberAccessOverride"> | string
    feature?: StringWithAggregatesFilter<"MemberAccessOverride"> | string
    enabled?: BoolWithAggregatesFilter<"MemberAccessOverride"> | boolean
    permissions?: StringNullableListFilter<"MemberAccessOverride">
    reason?: StringWithAggregatesFilter<"MemberAccessOverride"> | string
    grantedById?: StringWithAggregatesFilter<"MemberAccessOverride"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"MemberAccessOverride"> | Date | string
  }

  export type InvitationTemplateWhereInput = {
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    id?: StringFilter<"InvitationTemplate"> | string
    name?: StringFilter<"InvitationTemplate"> | string
    subject?: StringFilter<"InvitationTemplate"> | string
    bodyMarkdown?: StringFilter<"InvitationTemplate"> | string
    visibility?: EnumVisibilityFilter<"InvitationTemplate"> | $Enums.Visibility
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
  }

  export type InvitationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyMarkdown?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    name?: StringFilter<"InvitationTemplate"> | string
    subject?: StringFilter<"InvitationTemplate"> | string
    bodyMarkdown?: StringFilter<"InvitationTemplate"> | string
    visibility?: EnumVisibilityFilter<"InvitationTemplate"> | $Enums.Visibility
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
  }, "id">

  export type InvitationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyMarkdown?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    _count?: InvitationTemplateCountOrderByAggregateInput
    _max?: InvitationTemplateMaxOrderByAggregateInput
    _min?: InvitationTemplateMinOrderByAggregateInput
  }

  export type InvitationTemplateScalarWhereWithAggregatesInput = {
    AND?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    OR?: InvitationTemplateScalarWhereWithAggregatesInput[]
    NOT?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    name?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    subject?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    bodyMarkdown?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    visibility?: EnumVisibilityWithAggregatesFilter<"InvitationTemplate"> | $Enums.Visibility
    createdAt?: DateTimeWithAggregatesFilter<"InvitationTemplate"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: EnumUserRoleFilter<"Invitation"> | $Enums.UserRole
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    invitedById?: StringFilter<"Invitation"> | string
    grantedAccess?: EnumFeatureAccessKeyNullableListFilter<"Invitation">
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedById?: StringNullableFilter<"Invitation"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedById?: SortOrder
    grantedAccess?: SortOrder
    expiresAt?: SortOrder
    acceptedById?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    acceptedBy?: UserOrderByWithRelationInput
    invitedBy?: UserOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    email?: StringFilter<"Invitation"> | string
    role?: EnumUserRoleFilter<"Invitation"> | $Enums.UserRole
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    invitedById?: StringFilter<"Invitation"> | string
    grantedAccess?: EnumFeatureAccessKeyNullableListFilter<"Invitation">
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedById?: StringNullableFilter<"Invitation"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedById?: SortOrder
    grantedAccess?: SortOrder
    expiresAt?: SortOrder
    acceptedById?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    code?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    role?: EnumUserRoleWithAggregatesFilter<"Invitation"> | $Enums.UserRole
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    invitedById?: StringWithAggregatesFilter<"Invitation"> | string
    grantedAccess?: EnumFeatureAccessKeyNullableListFilter<"Invitation">
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    acceptedById?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    subtitle?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    coverImage?: StringNullableFilter<"Course"> | string | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    visibility?: EnumVisibilityFilter<"Course"> | $Enums.Visibility
    estimatedDurationMinutes?: IntFilter<"Course"> | number
    totalLessons?: IntFilter<"Course"> | number
    tags?: StringNullableListFilter<"Course">
    releaseDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    isFeatured?: BoolFilter<"Course"> | boolean
    recommendationScore?: FloatFilter<"Course"> | number
    modules?: CourseModuleListRelationFilter
    progresses?: CourseProgressListRelationFilter
    recommendations?: CourseRecommendationListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    level?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    tags?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFeatured?: SortOrder
    recommendationScore?: SortOrder
    modules?: CourseModuleOrderByRelationAggregateInput
    progresses?: CourseProgressOrderByRelationAggregateInput
    recommendations?: CourseRecommendationOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    subtitle?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    coverImage?: StringNullableFilter<"Course"> | string | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    visibility?: EnumVisibilityFilter<"Course"> | $Enums.Visibility
    estimatedDurationMinutes?: IntFilter<"Course"> | number
    totalLessons?: IntFilter<"Course"> | number
    tags?: StringNullableListFilter<"Course">
    releaseDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    isFeatured?: BoolFilter<"Course"> | boolean
    recommendationScore?: FloatFilter<"Course"> | number
    modules?: CourseModuleListRelationFilter
    progresses?: CourseProgressListRelationFilter
    recommendations?: CourseRecommendationListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    level?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    tags?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFeatured?: SortOrder
    recommendationScore?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    slug?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    subtitle?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    coverImage?: StringNullableWithAggregatesFilter<"Course"> | string | null
    level?: EnumCourseLevelWithAggregatesFilter<"Course"> | $Enums.CourseLevel
    status?: EnumCourseStatusWithAggregatesFilter<"Course"> | $Enums.CourseStatus
    visibility?: EnumVisibilityWithAggregatesFilter<"Course"> | $Enums.Visibility
    estimatedDurationMinutes?: IntWithAggregatesFilter<"Course"> | number
    totalLessons?: IntWithAggregatesFilter<"Course"> | number
    tags?: StringNullableListFilter<"Course">
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    isFeatured?: BoolWithAggregatesFilter<"Course"> | boolean
    recommendationScore?: FloatWithAggregatesFilter<"Course"> | number
  }

  export type CourseModuleWhereInput = {
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    order?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    durationMinutes?: IntFilter<"CourseModule"> | number
    dripDaysAfter?: IntNullableFilter<"CourseModule"> | number | null
    dripReleaseAt?: DateTimeNullableFilter<"CourseModule"> | Date | string | null
    dripAfterModuleId?: StringNullableFilter<"CourseModule"> | string | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    dripAfterModule?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    dependentModules?: CourseModuleListRelationFilter
    lessons?: LessonListRelationFilter
  }

  export type CourseModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrderInput | SortOrder
    dripReleaseAt?: SortOrderInput | SortOrder
    dripAfterModuleId?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    dripAfterModule?: CourseModuleOrderByWithRelationInput
    dependentModules?: CourseModuleOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type CourseModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_order?: CourseModuleCourseIdOrderCompoundUniqueInput
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    courseId?: StringFilter<"CourseModule"> | string
    order?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    durationMinutes?: IntFilter<"CourseModule"> | number
    dripDaysAfter?: IntNullableFilter<"CourseModule"> | number | null
    dripReleaseAt?: DateTimeNullableFilter<"CourseModule"> | Date | string | null
    dripAfterModuleId?: StringNullableFilter<"CourseModule"> | string | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    dripAfterModule?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    dependentModules?: CourseModuleListRelationFilter
    lessons?: LessonListRelationFilter
  }, "id" | "courseId_order">

  export type CourseModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrderInput | SortOrder
    dripReleaseAt?: SortOrderInput | SortOrder
    dripAfterModuleId?: SortOrderInput | SortOrder
    _count?: CourseModuleCountOrderByAggregateInput
    _avg?: CourseModuleAvgOrderByAggregateInput
    _max?: CourseModuleMaxOrderByAggregateInput
    _min?: CourseModuleMinOrderByAggregateInput
    _sum?: CourseModuleSumOrderByAggregateInput
  }

  export type CourseModuleScalarWhereWithAggregatesInput = {
    AND?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    OR?: CourseModuleScalarWhereWithAggregatesInput[]
    NOT?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseModule"> | string
    courseId?: StringWithAggregatesFilter<"CourseModule"> | string
    order?: IntWithAggregatesFilter<"CourseModule"> | number
    title?: StringWithAggregatesFilter<"CourseModule"> | string
    description?: StringWithAggregatesFilter<"CourseModule"> | string
    durationMinutes?: IntWithAggregatesFilter<"CourseModule"> | number
    dripDaysAfter?: IntNullableWithAggregatesFilter<"CourseModule"> | number | null
    dripReleaseAt?: DateTimeNullableWithAggregatesFilter<"CourseModule"> | Date | string | null
    dripAfterModuleId?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    moduleId?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    title?: StringFilter<"Lesson"> | string
    summary?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    content?: JsonFilter<"Lesson">
    durationMinutes?: IntFilter<"Lesson"> | number
    isPreview?: BoolFilter<"Lesson"> | boolean
    releaseAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    comments?: LessonCommentListRelationFilter
    progressAggregates?: LessonProgressAggregateListRelationFilter
    progressEvents?: LessonProgressEventListRelationFilter
    ratings?: LessonRatingListRelationFilter
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    content?: SortOrder
    durationMinutes?: SortOrder
    isPreview?: SortOrder
    releaseAt?: SortOrderInput | SortOrder
    comments?: LessonCommentOrderByRelationAggregateInput
    progressAggregates?: LessonProgressAggregateOrderByRelationAggregateInput
    progressEvents?: LessonProgressEventOrderByRelationAggregateInput
    ratings?: LessonRatingOrderByRelationAggregateInput
    module?: CourseModuleOrderByWithRelationInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduleId_order?: LessonModuleIdOrderCompoundUniqueInput
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    moduleId?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    title?: StringFilter<"Lesson"> | string
    summary?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    content?: JsonFilter<"Lesson">
    durationMinutes?: IntFilter<"Lesson"> | number
    isPreview?: BoolFilter<"Lesson"> | boolean
    releaseAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    comments?: LessonCommentListRelationFilter
    progressAggregates?: LessonProgressAggregateListRelationFilter
    progressEvents?: LessonProgressEventListRelationFilter
    ratings?: LessonRatingListRelationFilter
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }, "id" | "moduleId_order">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    content?: SortOrder
    durationMinutes?: SortOrder
    isPreview?: SortOrder
    releaseAt?: SortOrderInput | SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    moduleId?: StringWithAggregatesFilter<"Lesson"> | string
    order?: IntWithAggregatesFilter<"Lesson"> | number
    title?: StringWithAggregatesFilter<"Lesson"> | string
    summary?: StringWithAggregatesFilter<"Lesson"> | string
    type?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    content?: JsonWithAggregatesFilter<"Lesson">
    durationMinutes?: IntWithAggregatesFilter<"Lesson"> | number
    isPreview?: BoolWithAggregatesFilter<"Lesson"> | boolean
    releaseAt?: DateTimeNullableWithAggregatesFilter<"Lesson"> | Date | string | null
  }

  export type CourseProgressWhereInput = {
    AND?: CourseProgressWhereInput | CourseProgressWhereInput[]
    OR?: CourseProgressWhereInput[]
    NOT?: CourseProgressWhereInput | CourseProgressWhereInput[]
    courseId?: StringFilter<"CourseProgress"> | string
    userId?: StringFilter<"CourseProgress"> | string
    completedLessonIds?: StringNullableListFilter<"CourseProgress">
    percentage?: FloatFilter<"CourseProgress"> | number
    lastLessonId?: StringNullableFilter<"CourseProgress"> | string | null
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CourseProgressOrderByWithRelationInput = {
    courseId?: SortOrder
    userId?: SortOrder
    completedLessonIds?: SortOrder
    percentage?: SortOrder
    lastLessonId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CourseProgressWhereUniqueInput = Prisma.AtLeast<{
    courseId_userId?: CourseProgressCourseIdUserIdCompoundUniqueInput
    AND?: CourseProgressWhereInput | CourseProgressWhereInput[]
    OR?: CourseProgressWhereInput[]
    NOT?: CourseProgressWhereInput | CourseProgressWhereInput[]
    courseId?: StringFilter<"CourseProgress"> | string
    userId?: StringFilter<"CourseProgress"> | string
    completedLessonIds?: StringNullableListFilter<"CourseProgress">
    percentage?: FloatFilter<"CourseProgress"> | number
    lastLessonId?: StringNullableFilter<"CourseProgress"> | string | null
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "courseId_userId">

  export type CourseProgressOrderByWithAggregationInput = {
    courseId?: SortOrder
    userId?: SortOrder
    completedLessonIds?: SortOrder
    percentage?: SortOrder
    lastLessonId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CourseProgressCountOrderByAggregateInput
    _avg?: CourseProgressAvgOrderByAggregateInput
    _max?: CourseProgressMaxOrderByAggregateInput
    _min?: CourseProgressMinOrderByAggregateInput
    _sum?: CourseProgressSumOrderByAggregateInput
  }

  export type CourseProgressScalarWhereWithAggregatesInput = {
    AND?: CourseProgressScalarWhereWithAggregatesInput | CourseProgressScalarWhereWithAggregatesInput[]
    OR?: CourseProgressScalarWhereWithAggregatesInput[]
    NOT?: CourseProgressScalarWhereWithAggregatesInput | CourseProgressScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseProgress"> | string
    userId?: StringWithAggregatesFilter<"CourseProgress"> | string
    completedLessonIds?: StringNullableListFilter<"CourseProgress">
    percentage?: FloatWithAggregatesFilter<"CourseProgress"> | number
    lastLessonId?: StringNullableWithAggregatesFilter<"CourseProgress"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"CourseProgress"> | Date | string
  }

  export type LessonCommentWhereInput = {
    AND?: LessonCommentWhereInput | LessonCommentWhereInput[]
    OR?: LessonCommentWhereInput[]
    NOT?: LessonCommentWhereInput | LessonCommentWhereInput[]
    id?: StringFilter<"LessonComment"> | string
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    body?: StringFilter<"LessonComment"> | string
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
    pendingModeration?: BoolFilter<"LessonComment"> | boolean
    moderatedAt?: DateTimeNullableFilter<"LessonComment"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonComment"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonComment"> | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyListRelationFilter
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    moderatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LessonCommentOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingModeration?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedById?: SortOrderInput | SortOrder
    moderationStatus?: SortOrder
    replies?: LessonCommentReplyOrderByRelationAggregateInput
    lesson?: LessonOrderByWithRelationInput
    moderatedBy?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LessonCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonCommentWhereInput | LessonCommentWhereInput[]
    OR?: LessonCommentWhereInput[]
    NOT?: LessonCommentWhereInput | LessonCommentWhereInput[]
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    body?: StringFilter<"LessonComment"> | string
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
    pendingModeration?: BoolFilter<"LessonComment"> | boolean
    moderatedAt?: DateTimeNullableFilter<"LessonComment"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonComment"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonComment"> | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyListRelationFilter
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    moderatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LessonCommentOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingModeration?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedById?: SortOrderInput | SortOrder
    moderationStatus?: SortOrder
    _count?: LessonCommentCountOrderByAggregateInput
    _max?: LessonCommentMaxOrderByAggregateInput
    _min?: LessonCommentMinOrderByAggregateInput
  }

  export type LessonCommentScalarWhereWithAggregatesInput = {
    AND?: LessonCommentScalarWhereWithAggregatesInput | LessonCommentScalarWhereWithAggregatesInput[]
    OR?: LessonCommentScalarWhereWithAggregatesInput[]
    NOT?: LessonCommentScalarWhereWithAggregatesInput | LessonCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonComment"> | string
    lessonId?: StringWithAggregatesFilter<"LessonComment"> | string
    userId?: StringWithAggregatesFilter<"LessonComment"> | string
    body?: StringWithAggregatesFilter<"LessonComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LessonComment"> | Date | string
    pendingModeration?: BoolWithAggregatesFilter<"LessonComment"> | boolean
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"LessonComment"> | Date | string | null
    moderatedById?: StringNullableWithAggregatesFilter<"LessonComment"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusWithAggregatesFilter<"LessonComment"> | $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentReplyWhereInput = {
    AND?: LessonCommentReplyWhereInput | LessonCommentReplyWhereInput[]
    OR?: LessonCommentReplyWhereInput[]
    NOT?: LessonCommentReplyWhereInput | LessonCommentReplyWhereInput[]
    id?: StringFilter<"LessonCommentReply"> | string
    commentId?: StringFilter<"LessonCommentReply"> | string
    userId?: StringFilter<"LessonCommentReply"> | string
    body?: StringFilter<"LessonCommentReply"> | string
    createdAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
    moderatedAt?: DateTimeNullableFilter<"LessonCommentReply"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonCommentReply"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonCommentReply"> | $Enums.LessonCommentModerationStatus
    parentReplyId?: StringNullableFilter<"LessonCommentReply"> | string | null
    pendingModeration?: BoolFilter<"LessonCommentReply"> | boolean
    updatedAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
    comment?: XOR<LessonCommentScalarRelationFilter, LessonCommentWhereInput>
    moderatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parentReply?: XOR<LessonCommentReplyNullableScalarRelationFilter, LessonCommentReplyWhereInput> | null
    replies?: LessonCommentReplyListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LessonCommentReplyOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedById?: SortOrderInput | SortOrder
    moderationStatus?: SortOrder
    parentReplyId?: SortOrderInput | SortOrder
    pendingModeration?: SortOrder
    updatedAt?: SortOrder
    comment?: LessonCommentOrderByWithRelationInput
    moderatedBy?: UserOrderByWithRelationInput
    parentReply?: LessonCommentReplyOrderByWithRelationInput
    replies?: LessonCommentReplyOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type LessonCommentReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonCommentReplyWhereInput | LessonCommentReplyWhereInput[]
    OR?: LessonCommentReplyWhereInput[]
    NOT?: LessonCommentReplyWhereInput | LessonCommentReplyWhereInput[]
    commentId?: StringFilter<"LessonCommentReply"> | string
    userId?: StringFilter<"LessonCommentReply"> | string
    body?: StringFilter<"LessonCommentReply"> | string
    createdAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
    moderatedAt?: DateTimeNullableFilter<"LessonCommentReply"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonCommentReply"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonCommentReply"> | $Enums.LessonCommentModerationStatus
    parentReplyId?: StringNullableFilter<"LessonCommentReply"> | string | null
    pendingModeration?: BoolFilter<"LessonCommentReply"> | boolean
    updatedAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
    comment?: XOR<LessonCommentScalarRelationFilter, LessonCommentWhereInput>
    moderatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parentReply?: XOR<LessonCommentReplyNullableScalarRelationFilter, LessonCommentReplyWhereInput> | null
    replies?: LessonCommentReplyListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LessonCommentReplyOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedById?: SortOrderInput | SortOrder
    moderationStatus?: SortOrder
    parentReplyId?: SortOrderInput | SortOrder
    pendingModeration?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCommentReplyCountOrderByAggregateInput
    _max?: LessonCommentReplyMaxOrderByAggregateInput
    _min?: LessonCommentReplyMinOrderByAggregateInput
  }

  export type LessonCommentReplyScalarWhereWithAggregatesInput = {
    AND?: LessonCommentReplyScalarWhereWithAggregatesInput | LessonCommentReplyScalarWhereWithAggregatesInput[]
    OR?: LessonCommentReplyScalarWhereWithAggregatesInput[]
    NOT?: LessonCommentReplyScalarWhereWithAggregatesInput | LessonCommentReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonCommentReply"> | string
    commentId?: StringWithAggregatesFilter<"LessonCommentReply"> | string
    userId?: StringWithAggregatesFilter<"LessonCommentReply"> | string
    body?: StringWithAggregatesFilter<"LessonCommentReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LessonCommentReply"> | Date | string
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"LessonCommentReply"> | Date | string | null
    moderatedById?: StringNullableWithAggregatesFilter<"LessonCommentReply"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusWithAggregatesFilter<"LessonCommentReply"> | $Enums.LessonCommentModerationStatus
    parentReplyId?: StringNullableWithAggregatesFilter<"LessonCommentReply"> | string | null
    pendingModeration?: BoolWithAggregatesFilter<"LessonCommentReply"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"LessonCommentReply"> | Date | string
  }

  export type CourseRecommendationWhereInput = {
    AND?: CourseRecommendationWhereInput | CourseRecommendationWhereInput[]
    OR?: CourseRecommendationWhereInput[]
    NOT?: CourseRecommendationWhereInput | CourseRecommendationWhereInput[]
    id?: StringFilter<"CourseRecommendation"> | string
    courseId?: StringFilter<"CourseRecommendation"> | string
    reason?: StringFilter<"CourseRecommendation"> | string
    badge?: EnumRecommendationBadgeNullableFilter<"CourseRecommendation"> | $Enums.RecommendationBadge | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    reason?: SortOrder
    badge?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CourseRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseRecommendationWhereInput | CourseRecommendationWhereInput[]
    OR?: CourseRecommendationWhereInput[]
    NOT?: CourseRecommendationWhereInput | CourseRecommendationWhereInput[]
    courseId?: StringFilter<"CourseRecommendation"> | string
    reason?: StringFilter<"CourseRecommendation"> | string
    badge?: EnumRecommendationBadgeNullableFilter<"CourseRecommendation"> | $Enums.RecommendationBadge | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type CourseRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    reason?: SortOrder
    badge?: SortOrderInput | SortOrder
    _count?: CourseRecommendationCountOrderByAggregateInput
    _max?: CourseRecommendationMaxOrderByAggregateInput
    _min?: CourseRecommendationMinOrderByAggregateInput
  }

  export type CourseRecommendationScalarWhereWithAggregatesInput = {
    AND?: CourseRecommendationScalarWhereWithAggregatesInput | CourseRecommendationScalarWhereWithAggregatesInput[]
    OR?: CourseRecommendationScalarWhereWithAggregatesInput[]
    NOT?: CourseRecommendationScalarWhereWithAggregatesInput | CourseRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseRecommendation"> | string
    courseId?: StringWithAggregatesFilter<"CourseRecommendation"> | string
    reason?: StringWithAggregatesFilter<"CourseRecommendation"> | string
    badge?: EnumRecommendationBadgeNullableWithAggregatesFilter<"CourseRecommendation"> | $Enums.RecommendationBadge | null
  }

  export type LessonRatingWhereInput = {
    AND?: LessonRatingWhereInput | LessonRatingWhereInput[]
    OR?: LessonRatingWhereInput[]
    NOT?: LessonRatingWhereInput | LessonRatingWhereInput[]
    id?: StringFilter<"LessonRating"> | string
    lessonId?: StringFilter<"LessonRating"> | string
    userId?: StringFilter<"LessonRating"> | string
    value?: IntFilter<"LessonRating"> | number
    createdAt?: DateTimeFilter<"LessonRating"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LessonRatingOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LessonRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: LessonRatingUserIdLessonIdCompoundUniqueInput
    AND?: LessonRatingWhereInput | LessonRatingWhereInput[]
    OR?: LessonRatingWhereInput[]
    NOT?: LessonRatingWhereInput | LessonRatingWhereInput[]
    lessonId?: StringFilter<"LessonRating"> | string
    userId?: StringFilter<"LessonRating"> | string
    value?: IntFilter<"LessonRating"> | number
    createdAt?: DateTimeFilter<"LessonRating"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_lessonId">

  export type LessonRatingOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: LessonRatingCountOrderByAggregateInput
    _avg?: LessonRatingAvgOrderByAggregateInput
    _max?: LessonRatingMaxOrderByAggregateInput
    _min?: LessonRatingMinOrderByAggregateInput
    _sum?: LessonRatingSumOrderByAggregateInput
  }

  export type LessonRatingScalarWhereWithAggregatesInput = {
    AND?: LessonRatingScalarWhereWithAggregatesInput | LessonRatingScalarWhereWithAggregatesInput[]
    OR?: LessonRatingScalarWhereWithAggregatesInput[]
    NOT?: LessonRatingScalarWhereWithAggregatesInput | LessonRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonRating"> | string
    lessonId?: StringWithAggregatesFilter<"LessonRating"> | string
    userId?: StringWithAggregatesFilter<"LessonRating"> | string
    value?: IntWithAggregatesFilter<"LessonRating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LessonRating"> | Date | string
  }

  export type LessonProgressEventWhereInput = {
    AND?: LessonProgressEventWhereInput | LessonProgressEventWhereInput[]
    OR?: LessonProgressEventWhereInput[]
    NOT?: LessonProgressEventWhereInput | LessonProgressEventWhereInput[]
    id?: StringFilter<"LessonProgressEvent"> | string
    lessonId?: StringFilter<"LessonProgressEvent"> | string
    userId?: StringFilter<"LessonProgressEvent"> | string
    occurredAt?: DateTimeFilter<"LessonProgressEvent"> | Date | string
    positionSec?: IntFilter<"LessonProgressEvent"> | number
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LessonProgressEventOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
    positionSec?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LessonProgressEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonProgressEventWhereInput | LessonProgressEventWhereInput[]
    OR?: LessonProgressEventWhereInput[]
    NOT?: LessonProgressEventWhereInput | LessonProgressEventWhereInput[]
    lessonId?: StringFilter<"LessonProgressEvent"> | string
    userId?: StringFilter<"LessonProgressEvent"> | string
    occurredAt?: DateTimeFilter<"LessonProgressEvent"> | Date | string
    positionSec?: IntFilter<"LessonProgressEvent"> | number
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LessonProgressEventOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
    positionSec?: SortOrder
    _count?: LessonProgressEventCountOrderByAggregateInput
    _avg?: LessonProgressEventAvgOrderByAggregateInput
    _max?: LessonProgressEventMaxOrderByAggregateInput
    _min?: LessonProgressEventMinOrderByAggregateInput
    _sum?: LessonProgressEventSumOrderByAggregateInput
  }

  export type LessonProgressEventScalarWhereWithAggregatesInput = {
    AND?: LessonProgressEventScalarWhereWithAggregatesInput | LessonProgressEventScalarWhereWithAggregatesInput[]
    OR?: LessonProgressEventScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressEventScalarWhereWithAggregatesInput | LessonProgressEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonProgressEvent"> | string
    lessonId?: StringWithAggregatesFilter<"LessonProgressEvent"> | string
    userId?: StringWithAggregatesFilter<"LessonProgressEvent"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"LessonProgressEvent"> | Date | string
    positionSec?: IntWithAggregatesFilter<"LessonProgressEvent"> | number
  }

  export type LessonProgressAggregateWhereInput = {
    AND?: LessonProgressAggregateWhereInput | LessonProgressAggregateWhereInput[]
    OR?: LessonProgressAggregateWhereInput[]
    NOT?: LessonProgressAggregateWhereInput | LessonProgressAggregateWhereInput[]
    lessonId?: StringFilter<"LessonProgressAggregate"> | string
    userId?: StringFilter<"LessonProgressAggregate"> | string
    lastPositionSec?: IntFilter<"LessonProgressAggregate"> | number
    percentage?: FloatFilter<"LessonProgressAggregate"> | number
    updatedAt?: DateTimeFilter<"LessonProgressAggregate"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LessonProgressAggregateOrderByWithRelationInput = {
    lessonId?: SortOrder
    userId?: SortOrder
    lastPositionSec?: SortOrder
    percentage?: SortOrder
    updatedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LessonProgressAggregateWhereUniqueInput = Prisma.AtLeast<{
    lessonId_userId?: LessonProgressAggregateLessonIdUserIdCompoundUniqueInput
    AND?: LessonProgressAggregateWhereInput | LessonProgressAggregateWhereInput[]
    OR?: LessonProgressAggregateWhereInput[]
    NOT?: LessonProgressAggregateWhereInput | LessonProgressAggregateWhereInput[]
    lessonId?: StringFilter<"LessonProgressAggregate"> | string
    userId?: StringFilter<"LessonProgressAggregate"> | string
    lastPositionSec?: IntFilter<"LessonProgressAggregate"> | number
    percentage?: FloatFilter<"LessonProgressAggregate"> | number
    updatedAt?: DateTimeFilter<"LessonProgressAggregate"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "lessonId_userId">

  export type LessonProgressAggregateOrderByWithAggregationInput = {
    lessonId?: SortOrder
    userId?: SortOrder
    lastPositionSec?: SortOrder
    percentage?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonProgressAggregateCountOrderByAggregateInput
    _avg?: LessonProgressAggregateAvgOrderByAggregateInput
    _max?: LessonProgressAggregateMaxOrderByAggregateInput
    _min?: LessonProgressAggregateMinOrderByAggregateInput
    _sum?: LessonProgressAggregateSumOrderByAggregateInput
  }

  export type LessonProgressAggregateScalarWhereWithAggregatesInput = {
    AND?: LessonProgressAggregateScalarWhereWithAggregatesInput | LessonProgressAggregateScalarWhereWithAggregatesInput[]
    OR?: LessonProgressAggregateScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressAggregateScalarWhereWithAggregatesInput | LessonProgressAggregateScalarWhereWithAggregatesInput[]
    lessonId?: StringWithAggregatesFilter<"LessonProgressAggregate"> | string
    userId?: StringWithAggregatesFilter<"LessonProgressAggregate"> | string
    lastPositionSec?: IntWithAggregatesFilter<"LessonProgressAggregate"> | number
    percentage?: FloatWithAggregatesFilter<"LessonProgressAggregate"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"LessonProgressAggregate"> | Date | string
  }

  export type EvolutionApiConfigWhereInput = {
    AND?: EvolutionApiConfigWhereInput | EvolutionApiConfigWhereInput[]
    OR?: EvolutionApiConfigWhereInput[]
    NOT?: EvolutionApiConfigWhereInput | EvolutionApiConfigWhereInput[]
    id?: StringFilter<"EvolutionApiConfig"> | string
    userId?: StringFilter<"EvolutionApiConfig"> | string
    baseUrl?: StringFilter<"EvolutionApiConfig"> | string
    apiKeyEncrypted?: BytesFilter<"EvolutionApiConfig"> | Bytes
    connectedAt?: DateTimeNullableFilter<"EvolutionApiConfig"> | Date | string | null
    lastHealthCheckAt?: DateTimeNullableFilter<"EvolutionApiConfig"> | Date | string | null
    status?: EnumEvolutionConnectionStatusFilter<"EvolutionApiConfig"> | $Enums.EvolutionConnectionStatus
    errorMessage?: StringNullableFilter<"EvolutionApiConfig"> | string | null
    createdAt?: DateTimeFilter<"EvolutionApiConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EvolutionApiConfig"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EvolutionApiConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    baseUrl?: SortOrder
    apiKeyEncrypted?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    lastHealthCheckAt?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type EvolutionApiConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EvolutionApiConfigWhereInput | EvolutionApiConfigWhereInput[]
    OR?: EvolutionApiConfigWhereInput[]
    NOT?: EvolutionApiConfigWhereInput | EvolutionApiConfigWhereInput[]
    baseUrl?: StringFilter<"EvolutionApiConfig"> | string
    apiKeyEncrypted?: BytesFilter<"EvolutionApiConfig"> | Bytes
    connectedAt?: DateTimeNullableFilter<"EvolutionApiConfig"> | Date | string | null
    lastHealthCheckAt?: DateTimeNullableFilter<"EvolutionApiConfig"> | Date | string | null
    status?: EnumEvolutionConnectionStatusFilter<"EvolutionApiConfig"> | $Enums.EvolutionConnectionStatus
    errorMessage?: StringNullableFilter<"EvolutionApiConfig"> | string | null
    createdAt?: DateTimeFilter<"EvolutionApiConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EvolutionApiConfig"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type EvolutionApiConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    baseUrl?: SortOrder
    apiKeyEncrypted?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    lastHealthCheckAt?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvolutionApiConfigCountOrderByAggregateInput
    _max?: EvolutionApiConfigMaxOrderByAggregateInput
    _min?: EvolutionApiConfigMinOrderByAggregateInput
  }

  export type EvolutionApiConfigScalarWhereWithAggregatesInput = {
    AND?: EvolutionApiConfigScalarWhereWithAggregatesInput | EvolutionApiConfigScalarWhereWithAggregatesInput[]
    OR?: EvolutionApiConfigScalarWhereWithAggregatesInput[]
    NOT?: EvolutionApiConfigScalarWhereWithAggregatesInput | EvolutionApiConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvolutionApiConfig"> | string
    userId?: StringWithAggregatesFilter<"EvolutionApiConfig"> | string
    baseUrl?: StringWithAggregatesFilter<"EvolutionApiConfig"> | string
    apiKeyEncrypted?: BytesWithAggregatesFilter<"EvolutionApiConfig"> | Bytes
    connectedAt?: DateTimeNullableWithAggregatesFilter<"EvolutionApiConfig"> | Date | string | null
    lastHealthCheckAt?: DateTimeNullableWithAggregatesFilter<"EvolutionApiConfig"> | Date | string | null
    status?: EnumEvolutionConnectionStatusWithAggregatesFilter<"EvolutionApiConfig"> | $Enums.EvolutionConnectionStatus
    errorMessage?: StringNullableWithAggregatesFilter<"EvolutionApiConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvolutionApiConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvolutionApiConfig"> | Date | string
  }

  export type ContactSegmentWhereInput = {
    AND?: ContactSegmentWhereInput | ContactSegmentWhereInput[]
    OR?: ContactSegmentWhereInput[]
    NOT?: ContactSegmentWhereInput | ContactSegmentWhereInput[]
    id?: StringFilter<"ContactSegment"> | string
    userId?: StringFilter<"ContactSegment"> | string
    name?: StringFilter<"ContactSegment"> | string
    description?: StringFilter<"ContactSegment"> | string
    importSource?: EnumContactImportSourceFilter<"ContactSegment"> | $Enums.ContactImportSource
    totalContacts?: IntFilter<"ContactSegment"> | number
    createdAt?: DateTimeFilter<"ContactSegment"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactSegmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    importSource?: SortOrder
    totalContacts?: SortOrder
    createdAt?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ContactSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactSegmentWhereInput | ContactSegmentWhereInput[]
    OR?: ContactSegmentWhereInput[]
    NOT?: ContactSegmentWhereInput | ContactSegmentWhereInput[]
    userId?: StringFilter<"ContactSegment"> | string
    name?: StringFilter<"ContactSegment"> | string
    description?: StringFilter<"ContactSegment"> | string
    importSource?: EnumContactImportSourceFilter<"ContactSegment"> | $Enums.ContactImportSource
    totalContacts?: IntFilter<"ContactSegment"> | number
    createdAt?: DateTimeFilter<"ContactSegment"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ContactSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    importSource?: SortOrder
    totalContacts?: SortOrder
    createdAt?: SortOrder
    _count?: ContactSegmentCountOrderByAggregateInput
    _avg?: ContactSegmentAvgOrderByAggregateInput
    _max?: ContactSegmentMaxOrderByAggregateInput
    _min?: ContactSegmentMinOrderByAggregateInput
    _sum?: ContactSegmentSumOrderByAggregateInput
  }

  export type ContactSegmentScalarWhereWithAggregatesInput = {
    AND?: ContactSegmentScalarWhereWithAggregatesInput | ContactSegmentScalarWhereWithAggregatesInput[]
    OR?: ContactSegmentScalarWhereWithAggregatesInput[]
    NOT?: ContactSegmentScalarWhereWithAggregatesInput | ContactSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactSegment"> | string
    userId?: StringWithAggregatesFilter<"ContactSegment"> | string
    name?: StringWithAggregatesFilter<"ContactSegment"> | string
    description?: StringWithAggregatesFilter<"ContactSegment"> | string
    importSource?: EnumContactImportSourceWithAggregatesFilter<"ContactSegment"> | $Enums.ContactImportSource
    totalContacts?: IntWithAggregatesFilter<"ContactSegment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContactSegment"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    userId?: StringFilter<"MessageTemplate"> | string
    title?: StringFilter<"MessageTemplate"> | string
    body?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    userId?: StringFilter<"MessageTemplate"> | string
    title?: StringFilter<"MessageTemplate"> | string
    body?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    campaigns?: CampaignListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    userId?: StringWithAggregatesFilter<"MessageTemplate"> | string
    title?: StringWithAggregatesFilter<"MessageTemplate"> | string
    body?: StringWithAggregatesFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    evolutionConfigId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    channel?: EnumCampaignChannelFilter<"Campaign"> | $Enums.CampaignChannel
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    segmentId?: StringFilter<"Campaign"> | string
    templateId?: StringFilter<"Campaign"> | string
    externalId?: StringNullableFilter<"Campaign"> | string | null
    maxMessagesPerMinute?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    metrics?: XOR<CampaignMetricsNullableScalarRelationFilter, CampaignMetricsWhereInput> | null
    runs?: CampaignRunListRelationFilter
    timeline?: CampaignTimelinePointListRelationFilter
    evolutionConfig?: XOR<EvolutionApiConfigNullableScalarRelationFilter, EvolutionApiConfigWhereInput> | null
    segment?: XOR<ContactSegmentScalarRelationFilter, ContactSegmentWhereInput>
    template?: XOR<MessageTemplateScalarRelationFilter, MessageTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    evolutionConfigId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    segmentId?: SortOrder
    templateId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    maxMessagesPerMinute?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metrics?: CampaignMetricsOrderByWithRelationInput
    runs?: CampaignRunOrderByRelationAggregateInput
    timeline?: CampaignTimelinePointOrderByRelationAggregateInput
    evolutionConfig?: EvolutionApiConfigOrderByWithRelationInput
    segment?: ContactSegmentOrderByWithRelationInput
    template?: MessageTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    userId?: StringFilter<"Campaign"> | string
    evolutionConfigId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    channel?: EnumCampaignChannelFilter<"Campaign"> | $Enums.CampaignChannel
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    segmentId?: StringFilter<"Campaign"> | string
    templateId?: StringFilter<"Campaign"> | string
    maxMessagesPerMinute?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    metrics?: XOR<CampaignMetricsNullableScalarRelationFilter, CampaignMetricsWhereInput> | null
    runs?: CampaignRunListRelationFilter
    timeline?: CampaignTimelinePointListRelationFilter
    evolutionConfig?: XOR<EvolutionApiConfigNullableScalarRelationFilter, EvolutionApiConfigWhereInput> | null
    segment?: XOR<ContactSegmentScalarRelationFilter, ContactSegmentWhereInput>
    template?: XOR<MessageTemplateScalarRelationFilter, MessageTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "externalId">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    evolutionConfigId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    segmentId?: SortOrder
    templateId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    maxMessagesPerMinute?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    evolutionConfigId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringWithAggregatesFilter<"Campaign"> | string
    channel?: EnumCampaignChannelWithAggregatesFilter<"Campaign"> | $Enums.CampaignChannel
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    segmentId?: StringWithAggregatesFilter<"Campaign"> | string
    templateId?: StringWithAggregatesFilter<"Campaign"> | string
    externalId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    maxMessagesPerMinute?: IntWithAggregatesFilter<"Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignRunWhereInput = {
    AND?: CampaignRunWhereInput | CampaignRunWhereInput[]
    OR?: CampaignRunWhereInput[]
    NOT?: CampaignRunWhereInput | CampaignRunWhereInput[]
    id?: StringFilter<"CampaignRun"> | string
    campaignId?: StringFilter<"CampaignRun"> | string
    initiatedBy?: StringFilter<"CampaignRun"> | string
    startedAt?: DateTimeFilter<"CampaignRun"> | Date | string
    endedAt?: DateTimeNullableFilter<"CampaignRun"> | Date | string | null
    status?: EnumCampaignStatusFilter<"CampaignRun"> | $Enums.CampaignStatus
    summary?: StringNullableFilter<"CampaignRun"> | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CampaignRunOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    initiatedBy?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    initiator?: UserOrderByWithRelationInput
  }

  export type CampaignRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignRunWhereInput | CampaignRunWhereInput[]
    OR?: CampaignRunWhereInput[]
    NOT?: CampaignRunWhereInput | CampaignRunWhereInput[]
    campaignId?: StringFilter<"CampaignRun"> | string
    initiatedBy?: StringFilter<"CampaignRun"> | string
    startedAt?: DateTimeFilter<"CampaignRun"> | Date | string
    endedAt?: DateTimeNullableFilter<"CampaignRun"> | Date | string | null
    status?: EnumCampaignStatusFilter<"CampaignRun"> | $Enums.CampaignStatus
    summary?: StringNullableFilter<"CampaignRun"> | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignRunOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    initiatedBy?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    _count?: CampaignRunCountOrderByAggregateInput
    _max?: CampaignRunMaxOrderByAggregateInput
    _min?: CampaignRunMinOrderByAggregateInput
  }

  export type CampaignRunScalarWhereWithAggregatesInput = {
    AND?: CampaignRunScalarWhereWithAggregatesInput | CampaignRunScalarWhereWithAggregatesInput[]
    OR?: CampaignRunScalarWhereWithAggregatesInput[]
    NOT?: CampaignRunScalarWhereWithAggregatesInput | CampaignRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignRun"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignRun"> | string
    initiatedBy?: StringWithAggregatesFilter<"CampaignRun"> | string
    startedAt?: DateTimeWithAggregatesFilter<"CampaignRun"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"CampaignRun"> | Date | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"CampaignRun"> | $Enums.CampaignStatus
    summary?: StringNullableWithAggregatesFilter<"CampaignRun"> | string | null
  }

  export type CampaignMetricsWhereInput = {
    AND?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    OR?: CampaignMetricsWhereInput[]
    NOT?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    campaignId?: StringFilter<"CampaignMetrics"> | string
    totalMessages?: IntFilter<"CampaignMetrics"> | number
    delivered?: IntFilter<"CampaignMetrics"> | number
    failed?: IntFilter<"CampaignMetrics"> | number
    pending?: IntFilter<"CampaignMetrics"> | number
    averageDeliveryMs?: IntFilter<"CampaignMetrics"> | number
    lastUpdatedAt?: DateTimeFilter<"CampaignMetrics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignMetricsOrderByWithRelationInput = {
    campaignId?: SortOrder
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
    lastUpdatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignMetricsWhereUniqueInput = Prisma.AtLeast<{
    campaignId?: string
    AND?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    OR?: CampaignMetricsWhereInput[]
    NOT?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    totalMessages?: IntFilter<"CampaignMetrics"> | number
    delivered?: IntFilter<"CampaignMetrics"> | number
    failed?: IntFilter<"CampaignMetrics"> | number
    pending?: IntFilter<"CampaignMetrics"> | number
    averageDeliveryMs?: IntFilter<"CampaignMetrics"> | number
    lastUpdatedAt?: DateTimeFilter<"CampaignMetrics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "campaignId">

  export type CampaignMetricsOrderByWithAggregationInput = {
    campaignId?: SortOrder
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
    lastUpdatedAt?: SortOrder
    _count?: CampaignMetricsCountOrderByAggregateInput
    _avg?: CampaignMetricsAvgOrderByAggregateInput
    _max?: CampaignMetricsMaxOrderByAggregateInput
    _min?: CampaignMetricsMinOrderByAggregateInput
    _sum?: CampaignMetricsSumOrderByAggregateInput
  }

  export type CampaignMetricsScalarWhereWithAggregatesInput = {
    AND?: CampaignMetricsScalarWhereWithAggregatesInput | CampaignMetricsScalarWhereWithAggregatesInput[]
    OR?: CampaignMetricsScalarWhereWithAggregatesInput[]
    NOT?: CampaignMetricsScalarWhereWithAggregatesInput | CampaignMetricsScalarWhereWithAggregatesInput[]
    campaignId?: StringWithAggregatesFilter<"CampaignMetrics"> | string
    totalMessages?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    delivered?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    failed?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    pending?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    averageDeliveryMs?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"CampaignMetrics"> | Date | string
  }

  export type CampaignTimelinePointWhereInput = {
    AND?: CampaignTimelinePointWhereInput | CampaignTimelinePointWhereInput[]
    OR?: CampaignTimelinePointWhereInput[]
    NOT?: CampaignTimelinePointWhereInput | CampaignTimelinePointWhereInput[]
    id?: StringFilter<"CampaignTimelinePoint"> | string
    campaignId?: StringFilter<"CampaignTimelinePoint"> | string
    timestamp?: DateTimeFilter<"CampaignTimelinePoint"> | Date | string
    delivered?: IntFilter<"CampaignTimelinePoint"> | number
    failed?: IntFilter<"CampaignTimelinePoint"> | number
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignTimelinePointOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    timestamp?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignTimelinePointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_timestamp?: CampaignTimelinePointCampaignIdTimestampCompoundUniqueInput
    AND?: CampaignTimelinePointWhereInput | CampaignTimelinePointWhereInput[]
    OR?: CampaignTimelinePointWhereInput[]
    NOT?: CampaignTimelinePointWhereInput | CampaignTimelinePointWhereInput[]
    campaignId?: StringFilter<"CampaignTimelinePoint"> | string
    timestamp?: DateTimeFilter<"CampaignTimelinePoint"> | Date | string
    delivered?: IntFilter<"CampaignTimelinePoint"> | number
    failed?: IntFilter<"CampaignTimelinePoint"> | number
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId_timestamp">

  export type CampaignTimelinePointOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    timestamp?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    _count?: CampaignTimelinePointCountOrderByAggregateInput
    _avg?: CampaignTimelinePointAvgOrderByAggregateInput
    _max?: CampaignTimelinePointMaxOrderByAggregateInput
    _min?: CampaignTimelinePointMinOrderByAggregateInput
    _sum?: CampaignTimelinePointSumOrderByAggregateInput
  }

  export type CampaignTimelinePointScalarWhereWithAggregatesInput = {
    AND?: CampaignTimelinePointScalarWhereWithAggregatesInput | CampaignTimelinePointScalarWhereWithAggregatesInput[]
    OR?: CampaignTimelinePointScalarWhereWithAggregatesInput[]
    NOT?: CampaignTimelinePointScalarWhereWithAggregatesInput | CampaignTimelinePointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignTimelinePoint"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignTimelinePoint"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CampaignTimelinePoint"> | Date | string
    delivered?: IntWithAggregatesFilter<"CampaignTimelinePoint"> | number
    failed?: IntWithAggregatesFilter<"CampaignTimelinePoint"> | number
  }

  export type ResourceCategoryWhereInput = {
    AND?: ResourceCategoryWhereInput | ResourceCategoryWhereInput[]
    OR?: ResourceCategoryWhereInput[]
    NOT?: ResourceCategoryWhereInput | ResourceCategoryWhereInput[]
    id?: StringFilter<"ResourceCategory"> | string
    name?: StringFilter<"ResourceCategory"> | string
    description?: StringFilter<"ResourceCategory"> | string
    icon?: StringFilter<"ResourceCategory"> | string
    order?: IntFilter<"ResourceCategory"> | number
    createdAt?: DateTimeFilter<"ResourceCategory"> | Date | string
    resources?: ResourceListRelationFilter
  }

  export type ResourceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    resources?: ResourceOrderByRelationAggregateInput
  }

  export type ResourceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceCategoryWhereInput | ResourceCategoryWhereInput[]
    OR?: ResourceCategoryWhereInput[]
    NOT?: ResourceCategoryWhereInput | ResourceCategoryWhereInput[]
    name?: StringFilter<"ResourceCategory"> | string
    description?: StringFilter<"ResourceCategory"> | string
    icon?: StringFilter<"ResourceCategory"> | string
    order?: IntFilter<"ResourceCategory"> | number
    createdAt?: DateTimeFilter<"ResourceCategory"> | Date | string
    resources?: ResourceListRelationFilter
  }, "id">

  export type ResourceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ResourceCategoryCountOrderByAggregateInput
    _avg?: ResourceCategoryAvgOrderByAggregateInput
    _max?: ResourceCategoryMaxOrderByAggregateInput
    _min?: ResourceCategoryMinOrderByAggregateInput
    _sum?: ResourceCategorySumOrderByAggregateInput
  }

  export type ResourceCategoryScalarWhereWithAggregatesInput = {
    AND?: ResourceCategoryScalarWhereWithAggregatesInput | ResourceCategoryScalarWhereWithAggregatesInput[]
    OR?: ResourceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ResourceCategoryScalarWhereWithAggregatesInput | ResourceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResourceCategory"> | string
    name?: StringWithAggregatesFilter<"ResourceCategory"> | string
    description?: StringWithAggregatesFilter<"ResourceCategory"> | string
    icon?: StringWithAggregatesFilter<"ResourceCategory"> | string
    order?: IntWithAggregatesFilter<"ResourceCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ResourceCategory"> | Date | string
  }

  export type ResourceTagWhereInput = {
    AND?: ResourceTagWhereInput | ResourceTagWhereInput[]
    OR?: ResourceTagWhereInput[]
    NOT?: ResourceTagWhereInput | ResourceTagWhereInput[]
    id?: StringFilter<"ResourceTag"> | string
    name?: StringFilter<"ResourceTag"> | string
    tagAssignments?: ResourceTagAssignmentListRelationFilter
  }

  export type ResourceTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tagAssignments?: ResourceTagAssignmentOrderByRelationAggregateInput
  }

  export type ResourceTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ResourceTagWhereInput | ResourceTagWhereInput[]
    OR?: ResourceTagWhereInput[]
    NOT?: ResourceTagWhereInput | ResourceTagWhereInput[]
    tagAssignments?: ResourceTagAssignmentListRelationFilter
  }, "id" | "name">

  export type ResourceTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ResourceTagCountOrderByAggregateInput
    _max?: ResourceTagMaxOrderByAggregateInput
    _min?: ResourceTagMinOrderByAggregateInput
  }

  export type ResourceTagScalarWhereWithAggregatesInput = {
    AND?: ResourceTagScalarWhereWithAggregatesInput | ResourceTagScalarWhereWithAggregatesInput[]
    OR?: ResourceTagScalarWhereWithAggregatesInput[]
    NOT?: ResourceTagScalarWhereWithAggregatesInput | ResourceTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResourceTag"> | string
    name?: StringWithAggregatesFilter<"ResourceTag"> | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    slug?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    categoryId?: StringFilter<"Resource"> | string
    thumbnailUrl?: StringNullableFilter<"Resource"> | string | null
    visibility?: EnumVisibilityFilter<"Resource"> | $Enums.Visibility
    featured?: BoolFilter<"Resource"> | boolean
    downloadCount?: IntFilter<"Resource"> | number
    viewCount?: IntFilter<"Resource"> | number
    createdById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    assets?: ResourceAssetListRelationFilter
    downloads?: ResourceDownloadLogListRelationFilter
    tags?: ResourceTagAssignmentListRelationFilter
    category?: XOR<ResourceCategoryScalarRelationFilter, ResourceCategoryWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    visibility?: SortOrder
    featured?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assets?: ResourceAssetOrderByRelationAggregateInput
    downloads?: ResourceDownloadLogOrderByRelationAggregateInput
    tags?: ResourceTagAssignmentOrderByRelationAggregateInput
    category?: ResourceCategoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    categoryId?: StringFilter<"Resource"> | string
    thumbnailUrl?: StringNullableFilter<"Resource"> | string | null
    visibility?: EnumVisibilityFilter<"Resource"> | $Enums.Visibility
    featured?: BoolFilter<"Resource"> | boolean
    downloadCount?: IntFilter<"Resource"> | number
    viewCount?: IntFilter<"Resource"> | number
    createdById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    assets?: ResourceAssetListRelationFilter
    downloads?: ResourceDownloadLogListRelationFilter
    tags?: ResourceTagAssignmentListRelationFilter
    category?: XOR<ResourceCategoryScalarRelationFilter, ResourceCategoryWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    visibility?: SortOrder
    featured?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    slug?: StringWithAggregatesFilter<"Resource"> | string
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringWithAggregatesFilter<"Resource"> | string
    type?: EnumResourceTypeWithAggregatesFilter<"Resource"> | $Enums.ResourceType
    categoryId?: StringWithAggregatesFilter<"Resource"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    visibility?: EnumVisibilityWithAggregatesFilter<"Resource"> | $Enums.Visibility
    featured?: BoolWithAggregatesFilter<"Resource"> | boolean
    downloadCount?: IntWithAggregatesFilter<"Resource"> | number
    viewCount?: IntWithAggregatesFilter<"Resource"> | number
    createdById?: StringWithAggregatesFilter<"Resource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type ResourceTagAssignmentWhereInput = {
    AND?: ResourceTagAssignmentWhereInput | ResourceTagAssignmentWhereInput[]
    OR?: ResourceTagAssignmentWhereInput[]
    NOT?: ResourceTagAssignmentWhereInput | ResourceTagAssignmentWhereInput[]
    resourceId?: StringFilter<"ResourceTagAssignment"> | string
    tagId?: StringFilter<"ResourceTagAssignment"> | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    tag?: XOR<ResourceTagScalarRelationFilter, ResourceTagWhereInput>
  }

  export type ResourceTagAssignmentOrderByWithRelationInput = {
    resourceId?: SortOrder
    tagId?: SortOrder
    resource?: ResourceOrderByWithRelationInput
    tag?: ResourceTagOrderByWithRelationInput
  }

  export type ResourceTagAssignmentWhereUniqueInput = Prisma.AtLeast<{
    resourceId_tagId?: ResourceTagAssignmentResourceIdTagIdCompoundUniqueInput
    AND?: ResourceTagAssignmentWhereInput | ResourceTagAssignmentWhereInput[]
    OR?: ResourceTagAssignmentWhereInput[]
    NOT?: ResourceTagAssignmentWhereInput | ResourceTagAssignmentWhereInput[]
    resourceId?: StringFilter<"ResourceTagAssignment"> | string
    tagId?: StringFilter<"ResourceTagAssignment"> | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    tag?: XOR<ResourceTagScalarRelationFilter, ResourceTagWhereInput>
  }, "resourceId_tagId">

  export type ResourceTagAssignmentOrderByWithAggregationInput = {
    resourceId?: SortOrder
    tagId?: SortOrder
    _count?: ResourceTagAssignmentCountOrderByAggregateInput
    _max?: ResourceTagAssignmentMaxOrderByAggregateInput
    _min?: ResourceTagAssignmentMinOrderByAggregateInput
  }

  export type ResourceTagAssignmentScalarWhereWithAggregatesInput = {
    AND?: ResourceTagAssignmentScalarWhereWithAggregatesInput | ResourceTagAssignmentScalarWhereWithAggregatesInput[]
    OR?: ResourceTagAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ResourceTagAssignmentScalarWhereWithAggregatesInput | ResourceTagAssignmentScalarWhereWithAggregatesInput[]
    resourceId?: StringWithAggregatesFilter<"ResourceTagAssignment"> | string
    tagId?: StringWithAggregatesFilter<"ResourceTagAssignment"> | string
  }

  export type ResourceAssetWhereInput = {
    AND?: ResourceAssetWhereInput | ResourceAssetWhereInput[]
    OR?: ResourceAssetWhereInput[]
    NOT?: ResourceAssetWhereInput | ResourceAssetWhereInput[]
    id?: StringFilter<"ResourceAsset"> | string
    resourceId?: StringFilter<"ResourceAsset"> | string
    fileUrl?: StringFilter<"ResourceAsset"> | string
    fileName?: StringFilter<"ResourceAsset"> | string
    mimeType?: StringFilter<"ResourceAsset"> | string
    sizeBytes?: IntFilter<"ResourceAsset"> | number
    createdAt?: DateTimeFilter<"ResourceAsset"> | Date | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type ResourceAssetOrderByWithRelationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    resource?: ResourceOrderByWithRelationInput
  }

  export type ResourceAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceAssetWhereInput | ResourceAssetWhereInput[]
    OR?: ResourceAssetWhereInput[]
    NOT?: ResourceAssetWhereInput | ResourceAssetWhereInput[]
    resourceId?: StringFilter<"ResourceAsset"> | string
    fileUrl?: StringFilter<"ResourceAsset"> | string
    fileName?: StringFilter<"ResourceAsset"> | string
    mimeType?: StringFilter<"ResourceAsset"> | string
    sizeBytes?: IntFilter<"ResourceAsset"> | number
    createdAt?: DateTimeFilter<"ResourceAsset"> | Date | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "id">

  export type ResourceAssetOrderByWithAggregationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    _count?: ResourceAssetCountOrderByAggregateInput
    _avg?: ResourceAssetAvgOrderByAggregateInput
    _max?: ResourceAssetMaxOrderByAggregateInput
    _min?: ResourceAssetMinOrderByAggregateInput
    _sum?: ResourceAssetSumOrderByAggregateInput
  }

  export type ResourceAssetScalarWhereWithAggregatesInput = {
    AND?: ResourceAssetScalarWhereWithAggregatesInput | ResourceAssetScalarWhereWithAggregatesInput[]
    OR?: ResourceAssetScalarWhereWithAggregatesInput[]
    NOT?: ResourceAssetScalarWhereWithAggregatesInput | ResourceAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResourceAsset"> | string
    resourceId?: StringWithAggregatesFilter<"ResourceAsset"> | string
    fileUrl?: StringWithAggregatesFilter<"ResourceAsset"> | string
    fileName?: StringWithAggregatesFilter<"ResourceAsset"> | string
    mimeType?: StringWithAggregatesFilter<"ResourceAsset"> | string
    sizeBytes?: IntWithAggregatesFilter<"ResourceAsset"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ResourceAsset"> | Date | string
  }

  export type ResourceDownloadLogWhereInput = {
    AND?: ResourceDownloadLogWhereInput | ResourceDownloadLogWhereInput[]
    OR?: ResourceDownloadLogWhereInput[]
    NOT?: ResourceDownloadLogWhereInput | ResourceDownloadLogWhereInput[]
    id?: StringFilter<"ResourceDownloadLog"> | string
    resourceId?: StringFilter<"ResourceDownloadLog"> | string
    userId?: StringFilter<"ResourceDownloadLog"> | string
    downloadedAt?: DateTimeFilter<"ResourceDownloadLog"> | Date | string
    ipAddress?: StringFilter<"ResourceDownloadLog"> | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourceDownloadLogOrderByWithRelationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    downloadedAt?: SortOrder
    ipAddress?: SortOrder
    resource?: ResourceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResourceDownloadLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceDownloadLogWhereInput | ResourceDownloadLogWhereInput[]
    OR?: ResourceDownloadLogWhereInput[]
    NOT?: ResourceDownloadLogWhereInput | ResourceDownloadLogWhereInput[]
    resourceId?: StringFilter<"ResourceDownloadLog"> | string
    userId?: StringFilter<"ResourceDownloadLog"> | string
    downloadedAt?: DateTimeFilter<"ResourceDownloadLog"> | Date | string
    ipAddress?: StringFilter<"ResourceDownloadLog"> | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ResourceDownloadLogOrderByWithAggregationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    downloadedAt?: SortOrder
    ipAddress?: SortOrder
    _count?: ResourceDownloadLogCountOrderByAggregateInput
    _max?: ResourceDownloadLogMaxOrderByAggregateInput
    _min?: ResourceDownloadLogMinOrderByAggregateInput
  }

  export type ResourceDownloadLogScalarWhereWithAggregatesInput = {
    AND?: ResourceDownloadLogScalarWhereWithAggregatesInput | ResourceDownloadLogScalarWhereWithAggregatesInput[]
    OR?: ResourceDownloadLogScalarWhereWithAggregatesInput[]
    NOT?: ResourceDownloadLogScalarWhereWithAggregatesInput | ResourceDownloadLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResourceDownloadLog"> | string
    resourceId?: StringWithAggregatesFilter<"ResourceDownloadLog"> | string
    userId?: StringWithAggregatesFilter<"ResourceDownloadLog"> | string
    downloadedAt?: DateTimeWithAggregatesFilter<"ResourceDownloadLog"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"ResourceDownloadLog"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessCreateInput = {
    id?: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grantedBy?: UserCreateNestedOneWithoutMemberAccessGrantsInput
    user: UserCreateNestedOneWithoutMemberAccessesInput
  }

  export type MemberAccessUncheckedCreateInput = {
    id?: string
    userId: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedById?: string | null
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: UserUpdateOneWithoutMemberAccessGrantsNestedInput
    user?: UserUpdateOneRequiredWithoutMemberAccessesNestedInput
  }

  export type MemberAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedById?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessCreateManyInput = {
    id?: string
    userId: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedById?: string | null
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedById?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerCreateInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedBannersInput
  }

  export type HeroBannerUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedBannersNestedInput
  }

  export type HeroBannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerCreateManyInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleCreateInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutFeatureTogglesCreatedInput
  }

  export type FeatureToggleUncheckedCreateInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureToggleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutFeatureTogglesCreatedNestedInput
  }

  export type FeatureToggleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleCreateManyInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureToggleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideCreateInput = {
    id?: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedAt?: Date | string
    grantedBy: UserCreateNestedOneWithoutOverridesGrantedInput
    user: UserCreateNestedOneWithoutAccessOverridesInput
  }

  export type MemberAccessOverrideUncheckedCreateInput = {
    id?: string
    userId: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedById: string
    grantedAt?: Date | string
  }

  export type MemberAccessOverrideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: UserUpdateOneRequiredWithoutOverridesGrantedNestedInput
    user?: UserUpdateOneRequiredWithoutAccessOverridesNestedInput
  }

  export type MemberAccessOverrideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideCreateManyInput = {
    id?: string
    userId: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedById: string
    grantedAt?: Date | string
  }

  export type MemberAccessOverrideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    bodyMarkdown: string
    visibility: $Enums.Visibility
    createdAt?: Date | string
  }

  export type InvitationTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    bodyMarkdown: string
    visibility: $Enums.Visibility
    createdAt?: Date | string
  }

  export type InvitationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    bodyMarkdown?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    bodyMarkdown?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    bodyMarkdown: string
    visibility: $Enums.Visibility
    createdAt?: Date | string
  }

  export type InvitationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    bodyMarkdown?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    bodyMarkdown?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    acceptedBy?: UserCreateNestedOneWithoutInvitationsAcceptedInput
    invitedBy: UserCreateNestedOneWithoutInvitationsSentInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    invitedById: string
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedById?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedBy?: UserUpdateOneWithoutInvitationsAcceptedNestedInput
    invitedBy?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    invitedById?: StringFieldUpdateOperationsInput | string
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    invitedById: string
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedById?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    invitedById?: StringFieldUpdateOperationsInput | string
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationCreateNestedManyWithoutCourseInput
    author?: UserCreateNestedOneWithoutCoursesAuthoredInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressUncheckedCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUpdateManyWithoutCourseNestedInput
    author?: UserUpdateOneWithoutCoursesAuthoredNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
  }

  export type CourseModuleCreateInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    course: CourseCreateNestedOneWithoutModulesInput
    dripAfterModule?: CourseModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: CourseModuleCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
    dependentModules?: CourseModuleUncheckedCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    dripAfterModule?: CourseModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: CourseModuleUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
    dependentModules?: CourseModuleUncheckedUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleCreateManyInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
  }

  export type CourseModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonCreateInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingCreateNestedManyWithoutLessonInput
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUpdateManyWithoutLessonNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseProgressCreateInput = {
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutProgressesInput
    user: UserCreateNestedOneWithoutCourseProgressesInput
  }

  export type CourseProgressUncheckedCreateInput = {
    courseId: string
    userId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateInput = {
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutProgressesNestedInput
    user?: UserUpdateOneRequiredWithoutCourseProgressesNestedInput
  }

  export type CourseProgressUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressCreateManyInput = {
    courseId: string
    userId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateManyMutationInput = {
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentCreateInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyCreateNestedManyWithoutCommentInput
    lesson: LessonCreateNestedOneWithoutCommentsInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
  }

  export type LessonCommentUncheckedCreateInput = {
    id?: string
    lessonId: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type LessonCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUpdateManyWithoutCommentNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
  }

  export type LessonCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LessonCommentCreateManyInput = {
    id?: string
    lessonId: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentReplyCreateInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    comment: LessonCommentCreateNestedOneWithoutRepliesInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput
    parentReply?: LessonCommentReplyCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentReplyCreateNestedManyWithoutParentReplyInput
    user: UserCreateNestedOneWithoutLessonCommentRepliesInput
  }

  export type LessonCommentReplyUncheckedCreateInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: LessonCommentUpdateOneRequiredWithoutRepliesNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput
    parentReply?: LessonCommentReplyUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentReplyUpdateManyWithoutParentReplyNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyCreateManyInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRecommendationCreateInput = {
    id?: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
    course: CourseCreateNestedOneWithoutRecommendationsInput
  }

  export type CourseRecommendationUncheckedCreateInput = {
    id?: string
    courseId: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
    course?: CourseUpdateOneRequiredWithoutRecommendationsNestedInput
  }

  export type CourseRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationCreateManyInput = {
    id?: string
    courseId: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type LessonRatingCreateInput = {
    id?: string
    value: number
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutRatingsInput
    user: UserCreateNestedOneWithoutLessonRatingInput
  }

  export type LessonRatingUncheckedCreateInput = {
    id?: string
    lessonId: string
    userId: string
    value: number
    createdAt?: Date | string
  }

  export type LessonRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonRatingNestedInput
  }

  export type LessonRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonRatingCreateManyInput = {
    id?: string
    lessonId: string
    userId: string
    value: number
    createdAt?: Date | string
  }

  export type LessonRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressEventCreateInput = {
    id?: string
    occurredAt: Date | string
    positionSec: number
    lesson: LessonCreateNestedOneWithoutProgressEventsInput
    user: UserCreateNestedOneWithoutLessonProgressEventInput
  }

  export type LessonProgressEventUncheckedCreateInput = {
    id?: string
    lessonId: string
    userId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonProgressEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
    lesson?: LessonUpdateOneRequiredWithoutProgressEventsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonProgressEventNestedInput
  }

  export type LessonProgressEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressEventCreateManyInput = {
    id?: string
    lessonId: string
    userId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonProgressEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressAggregateCreateInput = {
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutProgressAggregatesInput
    user: UserCreateNestedOneWithoutLessonProgressAggregateInput
  }

  export type LessonProgressAggregateUncheckedCreateInput = {
    lessonId: string
    userId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressAggregateUpdateInput = {
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutProgressAggregatesNestedInput
    user?: UserUpdateOneRequiredWithoutLessonProgressAggregateNestedInput
  }

  export type LessonProgressAggregateUncheckedUpdateInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressAggregateCreateManyInput = {
    lessonId: string
    userId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressAggregateUpdateManyMutationInput = {
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressAggregateUncheckedUpdateManyInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvolutionApiConfigCreateInput = {
    id?: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutEvolutionConfigInput
    user: UserCreateNestedOneWithoutEvolutionConfigInput
  }

  export type EvolutionApiConfigUncheckedCreateInput = {
    id?: string
    userId: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutEvolutionConfigInput
  }

  export type EvolutionApiConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutEvolutionConfigNestedInput
    user?: UserUpdateOneRequiredWithoutEvolutionConfigNestedInput
  }

  export type EvolutionApiConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutEvolutionConfigNestedInput
  }

  export type EvolutionApiConfigCreateManyInput = {
    id?: string
    userId: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvolutionApiConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvolutionApiConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSegmentCreateInput = {
    id?: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutSegmentInput
    user: UserCreateNestedOneWithoutContactSegmentsInput
  }

  export type ContactSegmentUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type ContactSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutSegmentNestedInput
    user?: UserUpdateOneRequiredWithoutContactSegmentsNestedInput
  }

  export type ContactSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type ContactSegmentCreateManyInput = {
    id?: string
    userId: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
  }

  export type ContactSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
    user: UserCreateNestedOneWithoutMessageTemplatesInput
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
    user?: UserUpdateOneRequiredWithoutMessageTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    userId: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRunCreateInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
    campaign: CampaignCreateNestedOneWithoutRunsInput
    initiator: UserCreateNestedOneWithoutCampaignRunsInitiatedInput
  }

  export type CampaignRunUncheckedCreateInput = {
    id?: string
    campaignId: string
    initiatedBy: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: CampaignUpdateOneRequiredWithoutRunsNestedInput
    initiator?: UserUpdateOneRequiredWithoutCampaignRunsInitiatedNestedInput
  }

  export type CampaignRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignRunCreateManyInput = {
    id?: string
    campaignId: string
    initiatedBy: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMetricsCreateInput = {
    totalMessages?: number
    delivered?: number
    failed?: number
    pending?: number
    averageDeliveryMs?: number
    lastUpdatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMetricsInput
  }

  export type CampaignMetricsUncheckedCreateInput = {
    campaignId: string
    totalMessages?: number
    delivered?: number
    failed?: number
    pending?: number
    averageDeliveryMs?: number
    lastUpdatedAt?: Date | string
  }

  export type CampaignMetricsUpdateInput = {
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type CampaignMetricsUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMetricsCreateManyInput = {
    campaignId: string
    totalMessages?: number
    delivered?: number
    failed?: number
    pending?: number
    averageDeliveryMs?: number
    lastUpdatedAt?: Date | string
  }

  export type CampaignMetricsUpdateManyMutationInput = {
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMetricsUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelinePointCreateInput = {
    id?: string
    timestamp: Date | string
    delivered?: number
    failed?: number
    campaign: CampaignCreateNestedOneWithoutTimelineInput
  }

  export type CampaignTimelinePointUncheckedCreateInput = {
    id?: string
    campaignId: string
    timestamp: Date | string
    delivered?: number
    failed?: number
  }

  export type CampaignTimelinePointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    campaign?: CampaignUpdateOneRequiredWithoutTimelineNestedInput
  }

  export type CampaignTimelinePointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignTimelinePointCreateManyInput = {
    id?: string
    campaignId: string
    timestamp: Date | string
    delivered?: number
    failed?: number
  }

  export type CampaignTimelinePointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignTimelinePointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceCategoryCreateInput = {
    id?: string
    name: string
    description: string
    icon: string
    order: number
    createdAt?: Date | string
    resources?: ResourceCreateNestedManyWithoutCategoryInput
  }

  export type ResourceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    icon: string
    order: number
    createdAt?: Date | string
    resources?: ResourceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ResourceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: ResourceUpdateManyWithoutCategoryNestedInput
  }

  export type ResourceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: ResourceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ResourceCategoryCreateManyInput = {
    id?: string
    name: string
    description: string
    icon: string
    order: number
    createdAt?: Date | string
  }

  export type ResourceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceTagCreateInput = {
    id?: string
    name: string
    tagAssignments?: ResourceTagAssignmentCreateNestedManyWithoutTagInput
  }

  export type ResourceTagUncheckedCreateInput = {
    id?: string
    name: string
    tagAssignments?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutTagInput
  }

  export type ResourceTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagAssignments?: ResourceTagAssignmentUpdateManyWithoutTagNestedInput
  }

  export type ResourceTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagAssignments?: ResourceTagAssignmentUncheckedUpdateManyWithoutTagNestedInput
  }

  export type ResourceTagCreateManyInput = {
    id?: string
    name: string
  }

  export type ResourceTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentCreateNestedManyWithoutResourceInput
    category: ResourceCategoryCreateNestedOneWithoutResourcesInput
    author: UserCreateNestedOneWithoutResourcesAuthoredInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetUncheckedCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUpdateManyWithoutResourceNestedInput
    category?: ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput
    author?: UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceTagAssignmentCreateInput = {
    resource: ResourceCreateNestedOneWithoutTagsInput
    tag: ResourceTagCreateNestedOneWithoutTagAssignmentsInput
  }

  export type ResourceTagAssignmentUncheckedCreateInput = {
    resourceId: string
    tagId: string
  }

  export type ResourceTagAssignmentUpdateInput = {
    resource?: ResourceUpdateOneRequiredWithoutTagsNestedInput
    tag?: ResourceTagUpdateOneRequiredWithoutTagAssignmentsNestedInput
  }

  export type ResourceTagAssignmentUncheckedUpdateInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagAssignmentCreateManyInput = {
    resourceId: string
    tagId: string
  }

  export type ResourceTagAssignmentUpdateManyMutationInput = {

  }

  export type ResourceTagAssignmentUncheckedUpdateManyInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceAssetCreateInput = {
    id?: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    resource: ResourceCreateNestedOneWithoutAssetsInput
  }

  export type ResourceAssetUncheckedCreateInput = {
    id?: string
    resourceId: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ResourceAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type ResourceAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceAssetCreateManyInput = {
    id?: string
    resourceId: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ResourceAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceDownloadLogCreateInput = {
    id?: string
    downloadedAt?: Date | string
    ipAddress: string
    resource: ResourceCreateNestedOneWithoutDownloadsInput
    user: UserCreateNestedOneWithoutResourceDownloadLogsInput
  }

  export type ResourceDownloadLogUncheckedCreateInput = {
    id?: string
    resourceId: string
    userId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceDownloadLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    resource?: ResourceUpdateOneRequiredWithoutDownloadsNestedInput
    user?: UserUpdateOneRequiredWithoutResourceDownloadLogsNestedInput
  }

  export type ResourceDownloadLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceDownloadLogCreateManyInput = {
    id?: string
    resourceId: string
    userId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceDownloadLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceDownloadLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourseProgressListRelationFilter = {
    every?: CourseProgressWhereInput
    some?: CourseProgressWhereInput
    none?: CourseProgressWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LessonCommentReplyListRelationFilter = {
    every?: LessonCommentReplyWhereInput
    some?: LessonCommentReplyWhereInput
    none?: LessonCommentReplyWhereInput
  }

  export type LessonCommentListRelationFilter = {
    every?: LessonCommentWhereInput
    some?: LessonCommentWhereInput
    none?: LessonCommentWhereInput
  }

  export type LessonProgressAggregateListRelationFilter = {
    every?: LessonProgressAggregateWhereInput
    some?: LessonProgressAggregateWhereInput
    none?: LessonProgressAggregateWhereInput
  }

  export type LessonProgressEventListRelationFilter = {
    every?: LessonProgressEventWhereInput
    some?: LessonProgressEventWhereInput
    none?: LessonProgressEventWhereInput
  }

  export type LessonRatingListRelationFilter = {
    every?: LessonRatingWhereInput
    some?: LessonRatingWhereInput
    none?: LessonRatingWhereInput
  }

  export type FeatureToggleListRelationFilter = {
    every?: FeatureToggleWhereInput
    some?: FeatureToggleWhereInput
    none?: FeatureToggleWhereInput
  }

  export type HeroBannerListRelationFilter = {
    every?: HeroBannerWhereInput
    some?: HeroBannerWhereInput
    none?: HeroBannerWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type MemberAccessOverrideListRelationFilter = {
    every?: MemberAccessOverrideWhereInput
    some?: MemberAccessOverrideWhereInput
    none?: MemberAccessOverrideWhereInput
  }

  export type MemberAccessListRelationFilter = {
    every?: MemberAccessWhereInput
    some?: MemberAccessWhereInput
    none?: MemberAccessWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ResourceDownloadLogListRelationFilter = {
    every?: ResourceDownloadLogWhereInput
    some?: ResourceDownloadLogWhereInput
    none?: ResourceDownloadLogWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type CampaignRunListRelationFilter = {
    every?: CampaignRunWhereInput
    some?: CampaignRunWhereInput
    none?: CampaignRunWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type ContactSegmentListRelationFilter = {
    every?: ContactSegmentWhereInput
    some?: ContactSegmentWhereInput
    none?: ContactSegmentWhereInput
  }

  export type EvolutionApiConfigNullableScalarRelationFilter = {
    is?: EvolutionApiConfigWhereInput | null
    isNot?: EvolutionApiConfigWhereInput | null
  }

  export type MessageTemplateListRelationFilter = {
    every?: MessageTemplateWhereInput
    some?: MessageTemplateWhereInput
    none?: MessageTemplateWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCommentReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressAggregateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureToggleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HeroBannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberAccessOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceDownloadLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    profileDisplayName?: SortOrder
    profileAvatarUrl?: SortOrder
    profileBio?: SortOrder
    profileTimezone?: SortOrder
    profileBadges?: SortOrder
    profileSocialLinks?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    profileDisplayName?: SortOrder
    profileAvatarUrl?: SortOrder
    profileBio?: SortOrder
    profileTimezone?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    profileDisplayName?: SortOrder
    profileAvatarUrl?: SortOrder
    profileBio?: SortOrder
    profileTimezone?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    device?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    device?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    device?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeatureAccessKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureAccessKey | EnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureAccessKeyFilter<$PrismaModel> | $Enums.FeatureAccessKey
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MemberAccessUserIdFeatureCompoundUniqueInput = {
    userId: string
    feature: $Enums.FeatureAccessKey
  }

  export type MemberAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFeatureAccessKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureAccessKey | EnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureAccessKeyWithAggregatesFilter<$PrismaModel> | $Enums.FeatureAccessKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureAccessKeyFilter<$PrismaModel>
    _max?: NestedEnumFeatureAccessKeyFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumBannerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerStatus | EnumBannerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBannerStatusFilter<$PrismaModel> | $Enums.BannerStatus
  }

  export type HeroBannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    primaryCtaLabel?: SortOrder
    primaryCtaHref?: SortOrder
    primaryCtaExternal?: SortOrder
    secondaryCtaLabel?: SortOrder
    secondaryCtaHref?: SortOrder
    secondaryCtaExternal?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HeroBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    primaryCtaLabel?: SortOrder
    primaryCtaHref?: SortOrder
    primaryCtaExternal?: SortOrder
    secondaryCtaLabel?: SortOrder
    secondaryCtaHref?: SortOrder
    secondaryCtaExternal?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    primaryCtaLabel?: SortOrder
    primaryCtaHref?: SortOrder
    primaryCtaExternal?: SortOrder
    secondaryCtaLabel?: SortOrder
    secondaryCtaHref?: SortOrder
    secondaryCtaExternal?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBannerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerStatus | EnumBannerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBannerStatusWithAggregatesFilter<$PrismaModel> | $Enums.BannerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBannerStatusFilter<$PrismaModel>
    _max?: NestedEnumBannerStatusFilter<$PrismaModel>
  }

  export type EnumFeatureToggleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureToggleStatus | EnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureToggleStatusFilter<$PrismaModel> | $Enums.FeatureToggleStatus
  }

  export type FeatureToggleCountOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    description?: SortOrder
    status?: SortOrder
    rolloutPercentage?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureToggleAvgOrderByAggregateInput = {
    rolloutPercentage?: SortOrder
  }

  export type FeatureToggleMaxOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    description?: SortOrder
    status?: SortOrder
    rolloutPercentage?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureToggleMinOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    description?: SortOrder
    status?: SortOrder
    rolloutPercentage?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureToggleSumOrderByAggregateInput = {
    rolloutPercentage?: SortOrder
  }

  export type EnumFeatureToggleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureToggleStatus | EnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureToggleStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeatureToggleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureToggleStatusFilter<$PrismaModel>
    _max?: NestedEnumFeatureToggleStatusFilter<$PrismaModel>
  }

  export type MemberAccessOverrideUserIdFeatureCompoundUniqueInput = {
    userId: string
    feature: string
  }

  export type MemberAccessOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    permissions?: SortOrder
    reason?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type MemberAccessOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    reason?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type MemberAccessOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    enabled?: SortOrder
    reason?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type InvitationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyMarkdown?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyMarkdown?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyMarkdown?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type EnumFeatureAccessKeyNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel> | null
    has?: $Enums.FeatureAccessKey | EnumFeatureAccessKeyFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    hasSome?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedById?: SortOrder
    grantedAccess?: SortOrder
    expiresAt?: SortOrder
    acceptedById?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedById?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedById?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type EnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CourseModuleListRelationFilter = {
    every?: CourseModuleWhereInput
    some?: CourseModuleWhereInput
    none?: CourseModuleWhereInput
  }

  export type CourseRecommendationListRelationFilter = {
    every?: CourseRecommendationWhereInput
    some?: CourseRecommendationWhereInput
    none?: CourseRecommendationWhereInput
  }

  export type CourseModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    level?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    tags?: SortOrder
    releaseDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFeatured?: SortOrder
    recommendationScore?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    recommendationScore?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    level?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    releaseDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFeatured?: SortOrder
    recommendationScore?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    level?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    releaseDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFeatured?: SortOrder
    recommendationScore?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    estimatedDurationMinutes?: SortOrder
    totalLessons?: SortOrder
    recommendationScore?: SortOrder
  }

  export type EnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type EnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseModuleNullableScalarRelationFilter = {
    is?: CourseModuleWhereInput | null
    isNot?: CourseModuleWhereInput | null
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseModuleCourseIdOrderCompoundUniqueInput = {
    courseId: string
    order: number
  }

  export type CourseModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrder
    dripReleaseAt?: SortOrder
    dripAfterModuleId?: SortOrder
  }

  export type CourseModuleAvgOrderByAggregateInput = {
    order?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrder
  }

  export type CourseModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrder
    dripReleaseAt?: SortOrder
    dripAfterModuleId?: SortOrder
  }

  export type CourseModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrder
    dripReleaseAt?: SortOrder
    dripAfterModuleId?: SortOrder
  }

  export type CourseModuleSumOrderByAggregateInput = {
    order?: SortOrder
    durationMinutes?: SortOrder
    dripDaysAfter?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type CourseModuleScalarRelationFilter = {
    is?: CourseModuleWhereInput
    isNot?: CourseModuleWhereInput
  }

  export type LessonModuleIdOrderCompoundUniqueInput = {
    moduleId: string
    order: number
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    content?: SortOrder
    durationMinutes?: SortOrder
    isPreview?: SortOrder
    releaseAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    order?: SortOrder
    durationMinutes?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    durationMinutes?: SortOrder
    isPreview?: SortOrder
    releaseAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    durationMinutes?: SortOrder
    isPreview?: SortOrder
    releaseAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    order?: SortOrder
    durationMinutes?: SortOrder
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type CourseProgressCourseIdUserIdCompoundUniqueInput = {
    courseId: string
    userId: string
  }

  export type CourseProgressCountOrderByAggregateInput = {
    courseId?: SortOrder
    userId?: SortOrder
    completedLessonIds?: SortOrder
    percentage?: SortOrder
    lastLessonId?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type CourseProgressMaxOrderByAggregateInput = {
    courseId?: SortOrder
    userId?: SortOrder
    percentage?: SortOrder
    lastLessonId?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressMinOrderByAggregateInput = {
    courseId?: SortOrder
    userId?: SortOrder
    percentage?: SortOrder
    lastLessonId?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type EnumLessonCommentModerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonCommentModerationStatus | EnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel> | $Enums.LessonCommentModerationStatus
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonCommentCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingModeration?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
  }

  export type LessonCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingModeration?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
  }

  export type LessonCommentMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingModeration?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
  }

  export type EnumLessonCommentModerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonCommentModerationStatus | EnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonCommentModerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonCommentModerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel>
  }

  export type LessonCommentScalarRelationFilter = {
    is?: LessonCommentWhereInput
    isNot?: LessonCommentWhereInput
  }

  export type LessonCommentReplyNullableScalarRelationFilter = {
    is?: LessonCommentReplyWhereInput | null
    isNot?: LessonCommentReplyWhereInput | null
  }

  export type LessonCommentReplyCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
    parentReplyId?: SortOrder
    pendingModeration?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonCommentReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
    parentReplyId?: SortOrder
    pendingModeration?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonCommentReplyMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    moderatedAt?: SortOrder
    moderatedById?: SortOrder
    moderationStatus?: SortOrder
    parentReplyId?: SortOrder
    pendingModeration?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRecommendationBadgeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationBadge | EnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel> | $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    reason?: SortOrder
    badge?: SortOrder
  }

  export type CourseRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    reason?: SortOrder
    badge?: SortOrder
  }

  export type CourseRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    reason?: SortOrder
    badge?: SortOrder
  }

  export type EnumRecommendationBadgeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationBadge | EnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecommendationBadgeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationBadge | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel>
  }

  export type LessonRatingUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type LessonRatingCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonRatingAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LessonRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonRatingMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonRatingSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LessonProgressEventCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
    positionSec?: SortOrder
  }

  export type LessonProgressEventAvgOrderByAggregateInput = {
    positionSec?: SortOrder
  }

  export type LessonProgressEventMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
    positionSec?: SortOrder
  }

  export type LessonProgressEventMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    occurredAt?: SortOrder
    positionSec?: SortOrder
  }

  export type LessonProgressEventSumOrderByAggregateInput = {
    positionSec?: SortOrder
  }

  export type LessonProgressAggregateLessonIdUserIdCompoundUniqueInput = {
    lessonId: string
    userId: string
  }

  export type LessonProgressAggregateCountOrderByAggregateInput = {
    lessonId?: SortOrder
    userId?: SortOrder
    lastPositionSec?: SortOrder
    percentage?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonProgressAggregateAvgOrderByAggregateInput = {
    lastPositionSec?: SortOrder
    percentage?: SortOrder
  }

  export type LessonProgressAggregateMaxOrderByAggregateInput = {
    lessonId?: SortOrder
    userId?: SortOrder
    lastPositionSec?: SortOrder
    percentage?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonProgressAggregateMinOrderByAggregateInput = {
    lessonId?: SortOrder
    userId?: SortOrder
    lastPositionSec?: SortOrder
    percentage?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonProgressAggregateSumOrderByAggregateInput = {
    lastPositionSec?: SortOrder
    percentage?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type EnumEvolutionConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EvolutionConnectionStatus | EnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel> | $Enums.EvolutionConnectionStatus
  }

  export type EvolutionApiConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseUrl?: SortOrder
    apiKeyEncrypted?: SortOrder
    connectedAt?: SortOrder
    lastHealthCheckAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvolutionApiConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseUrl?: SortOrder
    apiKeyEncrypted?: SortOrder
    connectedAt?: SortOrder
    lastHealthCheckAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvolutionApiConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseUrl?: SortOrder
    apiKeyEncrypted?: SortOrder
    connectedAt?: SortOrder
    lastHealthCheckAt?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EnumEvolutionConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvolutionConnectionStatus | EnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvolutionConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.EvolutionConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel>
  }

  export type EnumContactImportSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactImportSource | EnumContactImportSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumContactImportSourceFilter<$PrismaModel> | $Enums.ContactImportSource
  }

  export type ContactSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    importSource?: SortOrder
    totalContacts?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSegmentAvgOrderByAggregateInput = {
    totalContacts?: SortOrder
  }

  export type ContactSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    importSource?: SortOrder
    totalContacts?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    importSource?: SortOrder
    totalContacts?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSegmentSumOrderByAggregateInput = {
    totalContacts?: SortOrder
  }

  export type EnumContactImportSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactImportSource | EnumContactImportSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumContactImportSourceWithAggregatesFilter<$PrismaModel> | $Enums.ContactImportSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactImportSourceFilter<$PrismaModel>
    _max?: NestedEnumContactImportSourceFilter<$PrismaModel>
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCampaignChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignChannel | EnumCampaignChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignChannelFilter<$PrismaModel> | $Enums.CampaignChannel
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignMetricsNullableScalarRelationFilter = {
    is?: CampaignMetricsWhereInput | null
    isNot?: CampaignMetricsWhereInput | null
  }

  export type CampaignTimelinePointListRelationFilter = {
    every?: CampaignTimelinePointWhereInput
    some?: CampaignTimelinePointWhereInput
    none?: CampaignTimelinePointWhereInput
  }

  export type ContactSegmentScalarRelationFilter = {
    is?: ContactSegmentWhereInput
    isNot?: ContactSegmentWhereInput
  }

  export type MessageTemplateScalarRelationFilter = {
    is?: MessageTemplateWhereInput
    isNot?: MessageTemplateWhereInput
  }

  export type CampaignTimelinePointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    evolutionConfigId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    segmentId?: SortOrder
    templateId?: SortOrder
    externalId?: SortOrder
    maxMessagesPerMinute?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    maxMessagesPerMinute?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    evolutionConfigId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    segmentId?: SortOrder
    templateId?: SortOrder
    externalId?: SortOrder
    maxMessagesPerMinute?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    evolutionConfigId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    segmentId?: SortOrder
    templateId?: SortOrder
    externalId?: SortOrder
    maxMessagesPerMinute?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    maxMessagesPerMinute?: SortOrder
  }

  export type EnumCampaignChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignChannel | EnumCampaignChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignChannelWithAggregatesFilter<$PrismaModel> | $Enums.CampaignChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignChannelFilter<$PrismaModel>
    _max?: NestedEnumCampaignChannelFilter<$PrismaModel>
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignRunCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    initiatedBy?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    summary?: SortOrder
  }

  export type CampaignRunMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    initiatedBy?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    summary?: SortOrder
  }

  export type CampaignRunMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    initiatedBy?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    summary?: SortOrder
  }

  export type CampaignMetricsCountOrderByAggregateInput = {
    campaignId?: SortOrder
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type CampaignMetricsAvgOrderByAggregateInput = {
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
  }

  export type CampaignMetricsMaxOrderByAggregateInput = {
    campaignId?: SortOrder
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type CampaignMetricsMinOrderByAggregateInput = {
    campaignId?: SortOrder
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
    lastUpdatedAt?: SortOrder
  }

  export type CampaignMetricsSumOrderByAggregateInput = {
    totalMessages?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
    pending?: SortOrder
    averageDeliveryMs?: SortOrder
  }

  export type CampaignTimelinePointCampaignIdTimestampCompoundUniqueInput = {
    campaignId: string
    timestamp: Date | string
  }

  export type CampaignTimelinePointCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    timestamp?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
  }

  export type CampaignTimelinePointAvgOrderByAggregateInput = {
    delivered?: SortOrder
    failed?: SortOrder
  }

  export type CampaignTimelinePointMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    timestamp?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
  }

  export type CampaignTimelinePointMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    timestamp?: SortOrder
    delivered?: SortOrder
    failed?: SortOrder
  }

  export type CampaignTimelinePointSumOrderByAggregateInput = {
    delivered?: SortOrder
    failed?: SortOrder
  }

  export type ResourceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ResourceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ResourceTagAssignmentListRelationFilter = {
    every?: ResourceTagAssignmentWhereInput
    some?: ResourceTagAssignmentWhereInput
    none?: ResourceTagAssignmentWhereInput
  }

  export type ResourceTagAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ResourceTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ResourceTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type ResourceAssetListRelationFilter = {
    every?: ResourceAssetWhereInput
    some?: ResourceAssetWhereInput
    none?: ResourceAssetWhereInput
  }

  export type ResourceCategoryScalarRelationFilter = {
    is?: ResourceCategoryWhereInput
    isNot?: ResourceCategoryWhereInput
  }

  export type ResourceAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    thumbnailUrl?: SortOrder
    visibility?: SortOrder
    featured?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    downloadCount?: SortOrder
    viewCount?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    thumbnailUrl?: SortOrder
    visibility?: SortOrder
    featured?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    thumbnailUrl?: SortOrder
    visibility?: SortOrder
    featured?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    downloadCount?: SortOrder
    viewCount?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type ResourceScalarRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type ResourceTagScalarRelationFilter = {
    is?: ResourceTagWhereInput
    isNot?: ResourceTagWhereInput
  }

  export type ResourceTagAssignmentResourceIdTagIdCompoundUniqueInput = {
    resourceId: string
    tagId: string
  }

  export type ResourceTagAssignmentCountOrderByAggregateInput = {
    resourceId?: SortOrder
    tagId?: SortOrder
  }

  export type ResourceTagAssignmentMaxOrderByAggregateInput = {
    resourceId?: SortOrder
    tagId?: SortOrder
  }

  export type ResourceTagAssignmentMinOrderByAggregateInput = {
    resourceId?: SortOrder
    tagId?: SortOrder
  }

  export type ResourceAssetCountOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceAssetAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type ResourceAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceAssetMinOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceAssetSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type ResourceDownloadLogCountOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    downloadedAt?: SortOrder
    ipAddress?: SortOrder
  }

  export type ResourceDownloadLogMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    downloadedAt?: SortOrder
    ipAddress?: SortOrder
  }

  export type ResourceDownloadLogMinOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    downloadedAt?: SortOrder
    ipAddress?: SortOrder
  }

  export type UserCreateprofileBadgesInput = {
    set: string[]
  }

  export type CourseProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonCommentReplyCreateNestedManyWithoutModeratedByInput = {
    create?: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput> | LessonCommentReplyCreateWithoutModeratedByInput[] | LessonCommentReplyUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutModeratedByInput | LessonCommentReplyCreateOrConnectWithoutModeratedByInput[]
    createMany?: LessonCommentReplyCreateManyModeratedByInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCommentReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput> | LessonCommentReplyCreateWithoutUserInput[] | LessonCommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutUserInput | LessonCommentReplyCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentReplyCreateManyUserInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCommentCreateNestedManyWithoutModeratedByInput = {
    create?: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput> | LessonCommentCreateWithoutModeratedByInput[] | LessonCommentUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutModeratedByInput | LessonCommentCreateOrConnectWithoutModeratedByInput[]
    createMany?: LessonCommentCreateManyModeratedByInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonProgressAggregateCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput> | LessonProgressAggregateCreateWithoutUserInput[] | LessonProgressAggregateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutUserInput | LessonProgressAggregateCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressAggregateCreateManyUserInputEnvelope
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
  }

  export type LessonProgressEventCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput> | LessonProgressEventCreateWithoutUserInput[] | LessonProgressEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutUserInput | LessonProgressEventCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressEventCreateManyUserInputEnvelope
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
  }

  export type LessonRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput> | LessonRatingCreateWithoutUserInput[] | LessonRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutUserInput | LessonRatingCreateOrConnectWithoutUserInput[]
    createMany?: LessonRatingCreateManyUserInputEnvelope
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
  }

  export type FeatureToggleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput> | FeatureToggleCreateWithoutCreatedByInput[] | FeatureToggleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeatureToggleCreateOrConnectWithoutCreatedByInput | FeatureToggleCreateOrConnectWithoutCreatedByInput[]
    createMany?: FeatureToggleCreateManyCreatedByInputEnvelope
    connect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
  }

  export type HeroBannerCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput> | HeroBannerCreateWithoutCreatedByInput[] | HeroBannerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: HeroBannerCreateOrConnectWithoutCreatedByInput | HeroBannerCreateOrConnectWithoutCreatedByInput[]
    createMany?: HeroBannerCreateManyCreatedByInputEnvelope
    connect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutAcceptedByInput = {
    create?: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput> | InvitationCreateWithoutAcceptedByInput[] | InvitationUncheckedCreateWithoutAcceptedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAcceptedByInput | InvitationCreateOrConnectWithoutAcceptedByInput[]
    createMany?: InvitationCreateManyAcceptedByInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput> | InvitationCreateWithoutInvitedByInput[] | InvitationUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInvitedByInput | InvitationCreateOrConnectWithoutInvitedByInput[]
    createMany?: InvitationCreateManyInvitedByInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberAccessOverrideCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput> | MemberAccessOverrideCreateWithoutGrantedByInput[] | MemberAccessOverrideUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutGrantedByInput | MemberAccessOverrideCreateOrConnectWithoutGrantedByInput[]
    createMany?: MemberAccessOverrideCreateManyGrantedByInputEnvelope
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
  }

  export type MemberAccessOverrideCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput> | MemberAccessOverrideCreateWithoutUserInput[] | MemberAccessOverrideUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutUserInput | MemberAccessOverrideCreateOrConnectWithoutUserInput[]
    createMany?: MemberAccessOverrideCreateManyUserInputEnvelope
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
  }

  export type MemberAccessCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput> | MemberAccessCreateWithoutGrantedByInput[] | MemberAccessUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutGrantedByInput | MemberAccessCreateOrConnectWithoutGrantedByInput[]
    createMany?: MemberAccessCreateManyGrantedByInputEnvelope
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
  }

  export type MemberAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput> | MemberAccessCreateWithoutUserInput[] | MemberAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutUserInput | MemberAccessCreateOrConnectWithoutUserInput[]
    createMany?: MemberAccessCreateManyUserInputEnvelope
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ResourceDownloadLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput> | ResourceDownloadLogCreateWithoutUserInput[] | ResourceDownloadLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutUserInput | ResourceDownloadLogCreateOrConnectWithoutUserInput[]
    createMany?: ResourceDownloadLogCreateManyUserInputEnvelope
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type CampaignRunCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput> | CampaignRunCreateWithoutInitiatorInput[] | CampaignRunUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutInitiatorInput | CampaignRunCreateOrConnectWithoutInitiatorInput[]
    createMany?: CampaignRunCreateManyInitiatorInputEnvelope
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ContactSegmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput> | ContactSegmentCreateWithoutUserInput[] | ContactSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutUserInput | ContactSegmentCreateOrConnectWithoutUserInput[]
    createMany?: ContactSegmentCreateManyUserInputEnvelope
    connect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
  }

  export type EvolutionApiConfigCreateNestedOneWithoutUserInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutUserInput
    connect?: EvolutionApiConfigWhereUniqueInput
  }

  export type MessageTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type CourseProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput = {
    create?: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput> | LessonCommentReplyCreateWithoutModeratedByInput[] | LessonCommentReplyUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutModeratedByInput | LessonCommentReplyCreateOrConnectWithoutModeratedByInput[]
    createMany?: LessonCommentReplyCreateManyModeratedByInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput> | LessonCommentReplyCreateWithoutUserInput[] | LessonCommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutUserInput | LessonCommentReplyCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentReplyCreateManyUserInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput = {
    create?: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput> | LessonCommentCreateWithoutModeratedByInput[] | LessonCommentUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutModeratedByInput | LessonCommentCreateOrConnectWithoutModeratedByInput[]
    createMany?: LessonCommentCreateManyModeratedByInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput> | LessonProgressAggregateCreateWithoutUserInput[] | LessonProgressAggregateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutUserInput | LessonProgressAggregateCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressAggregateCreateManyUserInputEnvelope
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
  }

  export type LessonProgressEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput> | LessonProgressEventCreateWithoutUserInput[] | LessonProgressEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutUserInput | LessonProgressEventCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressEventCreateManyUserInputEnvelope
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
  }

  export type LessonRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput> | LessonRatingCreateWithoutUserInput[] | LessonRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutUserInput | LessonRatingCreateOrConnectWithoutUserInput[]
    createMany?: LessonRatingCreateManyUserInputEnvelope
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
  }

  export type FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput> | FeatureToggleCreateWithoutCreatedByInput[] | FeatureToggleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeatureToggleCreateOrConnectWithoutCreatedByInput | FeatureToggleCreateOrConnectWithoutCreatedByInput[]
    createMany?: FeatureToggleCreateManyCreatedByInputEnvelope
    connect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
  }

  export type HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput> | HeroBannerCreateWithoutCreatedByInput[] | HeroBannerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: HeroBannerCreateOrConnectWithoutCreatedByInput | HeroBannerCreateOrConnectWithoutCreatedByInput[]
    createMany?: HeroBannerCreateManyCreatedByInputEnvelope
    connect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutAcceptedByInput = {
    create?: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput> | InvitationCreateWithoutAcceptedByInput[] | InvitationUncheckedCreateWithoutAcceptedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAcceptedByInput | InvitationCreateOrConnectWithoutAcceptedByInput[]
    createMany?: InvitationCreateManyAcceptedByInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput> | InvitationCreateWithoutInvitedByInput[] | InvitationUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInvitedByInput | InvitationCreateOrConnectWithoutInvitedByInput[]
    createMany?: InvitationCreateManyInvitedByInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput> | MemberAccessOverrideCreateWithoutGrantedByInput[] | MemberAccessOverrideUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutGrantedByInput | MemberAccessOverrideCreateOrConnectWithoutGrantedByInput[]
    createMany?: MemberAccessOverrideCreateManyGrantedByInputEnvelope
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
  }

  export type MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput> | MemberAccessOverrideCreateWithoutUserInput[] | MemberAccessOverrideUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutUserInput | MemberAccessOverrideCreateOrConnectWithoutUserInput[]
    createMany?: MemberAccessOverrideCreateManyUserInputEnvelope
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
  }

  export type MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput> | MemberAccessCreateWithoutGrantedByInput[] | MemberAccessUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutGrantedByInput | MemberAccessCreateOrConnectWithoutGrantedByInput[]
    createMany?: MemberAccessCreateManyGrantedByInputEnvelope
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
  }

  export type MemberAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput> | MemberAccessCreateWithoutUserInput[] | MemberAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutUserInput | MemberAccessCreateOrConnectWithoutUserInput[]
    createMany?: MemberAccessCreateManyUserInputEnvelope
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput> | ResourceDownloadLogCreateWithoutUserInput[] | ResourceDownloadLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutUserInput | ResourceDownloadLogCreateOrConnectWithoutUserInput[]
    createMany?: ResourceDownloadLogCreateManyUserInputEnvelope
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput> | CampaignRunCreateWithoutInitiatorInput[] | CampaignRunUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutInitiatorInput | CampaignRunCreateOrConnectWithoutInitiatorInput[]
    createMany?: CampaignRunCreateManyInitiatorInputEnvelope
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ContactSegmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput> | ContactSegmentCreateWithoutUserInput[] | ContactSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutUserInput | ContactSegmentCreateOrConnectWithoutUserInput[]
    createMany?: ContactSegmentCreateManyUserInputEnvelope
    connect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
  }

  export type EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutUserInput
    connect?: EvolutionApiConfigWhereUniqueInput
  }

  export type MessageTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateprofileBadgesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutUserInput | CourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutUserInput | CourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutUserInput | CourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAuthorInput | CourseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAuthorInput | CourseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAuthorInput | CourseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonCommentReplyUpdateManyWithoutModeratedByNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput> | LessonCommentReplyCreateWithoutModeratedByInput[] | LessonCommentReplyUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutModeratedByInput | LessonCommentReplyCreateOrConnectWithoutModeratedByInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutModeratedByInput | LessonCommentReplyUpsertWithWhereUniqueWithoutModeratedByInput[]
    createMany?: LessonCommentReplyCreateManyModeratedByInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutModeratedByInput | LessonCommentReplyUpdateWithWhereUniqueWithoutModeratedByInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutModeratedByInput | LessonCommentReplyUpdateManyWithWhereWithoutModeratedByInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonCommentReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput> | LessonCommentReplyCreateWithoutUserInput[] | LessonCommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutUserInput | LessonCommentReplyCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutUserInput | LessonCommentReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentReplyCreateManyUserInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutUserInput | LessonCommentReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutUserInput | LessonCommentReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonCommentUpdateManyWithoutModeratedByNestedInput = {
    create?: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput> | LessonCommentCreateWithoutModeratedByInput[] | LessonCommentUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutModeratedByInput | LessonCommentCreateOrConnectWithoutModeratedByInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutModeratedByInput | LessonCommentUpsertWithWhereUniqueWithoutModeratedByInput[]
    createMany?: LessonCommentCreateManyModeratedByInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutModeratedByInput | LessonCommentUpdateWithWhereUniqueWithoutModeratedByInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutModeratedByInput | LessonCommentUpdateManyWithWhereWithoutModeratedByInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutUserInput | LessonCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutUserInput | LessonCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutUserInput | LessonCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonProgressAggregateUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput> | LessonProgressAggregateCreateWithoutUserInput[] | LessonProgressAggregateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutUserInput | LessonProgressAggregateCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressAggregateUpsertWithWhereUniqueWithoutUserInput | LessonProgressAggregateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressAggregateCreateManyUserInputEnvelope
    set?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    disconnect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    delete?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    update?: LessonProgressAggregateUpdateWithWhereUniqueWithoutUserInput | LessonProgressAggregateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressAggregateUpdateManyWithWhereWithoutUserInput | LessonProgressAggregateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
  }

  export type LessonProgressEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput> | LessonProgressEventCreateWithoutUserInput[] | LessonProgressEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutUserInput | LessonProgressEventCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressEventUpsertWithWhereUniqueWithoutUserInput | LessonProgressEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressEventCreateManyUserInputEnvelope
    set?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    disconnect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    delete?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    update?: LessonProgressEventUpdateWithWhereUniqueWithoutUserInput | LessonProgressEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressEventUpdateManyWithWhereWithoutUserInput | LessonProgressEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
  }

  export type LessonRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput> | LessonRatingCreateWithoutUserInput[] | LessonRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutUserInput | LessonRatingCreateOrConnectWithoutUserInput[]
    upsert?: LessonRatingUpsertWithWhereUniqueWithoutUserInput | LessonRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonRatingCreateManyUserInputEnvelope
    set?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    disconnect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    delete?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    update?: LessonRatingUpdateWithWhereUniqueWithoutUserInput | LessonRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonRatingUpdateManyWithWhereWithoutUserInput | LessonRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
  }

  export type FeatureToggleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput> | FeatureToggleCreateWithoutCreatedByInput[] | FeatureToggleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeatureToggleCreateOrConnectWithoutCreatedByInput | FeatureToggleCreateOrConnectWithoutCreatedByInput[]
    upsert?: FeatureToggleUpsertWithWhereUniqueWithoutCreatedByInput | FeatureToggleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FeatureToggleCreateManyCreatedByInputEnvelope
    set?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    disconnect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    delete?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    connect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    update?: FeatureToggleUpdateWithWhereUniqueWithoutCreatedByInput | FeatureToggleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FeatureToggleUpdateManyWithWhereWithoutCreatedByInput | FeatureToggleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FeatureToggleScalarWhereInput | FeatureToggleScalarWhereInput[]
  }

  export type HeroBannerUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput> | HeroBannerCreateWithoutCreatedByInput[] | HeroBannerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: HeroBannerCreateOrConnectWithoutCreatedByInput | HeroBannerCreateOrConnectWithoutCreatedByInput[]
    upsert?: HeroBannerUpsertWithWhereUniqueWithoutCreatedByInput | HeroBannerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: HeroBannerCreateManyCreatedByInputEnvelope
    set?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    disconnect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    delete?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    connect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    update?: HeroBannerUpdateWithWhereUniqueWithoutCreatedByInput | HeroBannerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: HeroBannerUpdateManyWithWhereWithoutCreatedByInput | HeroBannerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: HeroBannerScalarWhereInput | HeroBannerScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutAcceptedByNestedInput = {
    create?: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput> | InvitationCreateWithoutAcceptedByInput[] | InvitationUncheckedCreateWithoutAcceptedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAcceptedByInput | InvitationCreateOrConnectWithoutAcceptedByInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAcceptedByInput | InvitationUpsertWithWhereUniqueWithoutAcceptedByInput[]
    createMany?: InvitationCreateManyAcceptedByInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAcceptedByInput | InvitationUpdateWithWhereUniqueWithoutAcceptedByInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAcceptedByInput | InvitationUpdateManyWithWhereWithoutAcceptedByInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput> | InvitationCreateWithoutInvitedByInput[] | InvitationUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInvitedByInput | InvitationCreateOrConnectWithoutInvitedByInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInvitedByInput | InvitationUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: InvitationCreateManyInvitedByInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInvitedByInput | InvitationUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInvitedByInput | InvitationUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput> | MemberAccessOverrideCreateWithoutGrantedByInput[] | MemberAccessOverrideUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutGrantedByInput | MemberAccessOverrideCreateOrConnectWithoutGrantedByInput[]
    upsert?: MemberAccessOverrideUpsertWithWhereUniqueWithoutGrantedByInput | MemberAccessOverrideUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: MemberAccessOverrideCreateManyGrantedByInputEnvelope
    set?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    disconnect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    delete?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    update?: MemberAccessOverrideUpdateWithWhereUniqueWithoutGrantedByInput | MemberAccessOverrideUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: MemberAccessOverrideUpdateManyWithWhereWithoutGrantedByInput | MemberAccessOverrideUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
  }

  export type MemberAccessOverrideUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput> | MemberAccessOverrideCreateWithoutUserInput[] | MemberAccessOverrideUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutUserInput | MemberAccessOverrideCreateOrConnectWithoutUserInput[]
    upsert?: MemberAccessOverrideUpsertWithWhereUniqueWithoutUserInput | MemberAccessOverrideUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberAccessOverrideCreateManyUserInputEnvelope
    set?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    disconnect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    delete?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    update?: MemberAccessOverrideUpdateWithWhereUniqueWithoutUserInput | MemberAccessOverrideUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberAccessOverrideUpdateManyWithWhereWithoutUserInput | MemberAccessOverrideUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
  }

  export type MemberAccessUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput> | MemberAccessCreateWithoutGrantedByInput[] | MemberAccessUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutGrantedByInput | MemberAccessCreateOrConnectWithoutGrantedByInput[]
    upsert?: MemberAccessUpsertWithWhereUniqueWithoutGrantedByInput | MemberAccessUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: MemberAccessCreateManyGrantedByInputEnvelope
    set?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    disconnect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    delete?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    update?: MemberAccessUpdateWithWhereUniqueWithoutGrantedByInput | MemberAccessUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: MemberAccessUpdateManyWithWhereWithoutGrantedByInput | MemberAccessUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
  }

  export type MemberAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput> | MemberAccessCreateWithoutUserInput[] | MemberAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutUserInput | MemberAccessCreateOrConnectWithoutUserInput[]
    upsert?: MemberAccessUpsertWithWhereUniqueWithoutUserInput | MemberAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberAccessCreateManyUserInputEnvelope
    set?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    disconnect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    delete?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    update?: MemberAccessUpdateWithWhereUniqueWithoutUserInput | MemberAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberAccessUpdateManyWithWhereWithoutUserInput | MemberAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ResourceDownloadLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput> | ResourceDownloadLogCreateWithoutUserInput[] | ResourceDownloadLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutUserInput | ResourceDownloadLogCreateOrConnectWithoutUserInput[]
    upsert?: ResourceDownloadLogUpsertWithWhereUniqueWithoutUserInput | ResourceDownloadLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceDownloadLogCreateManyUserInputEnvelope
    set?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    disconnect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    delete?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    update?: ResourceDownloadLogUpdateWithWhereUniqueWithoutUserInput | ResourceDownloadLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceDownloadLogUpdateManyWithWhereWithoutUserInput | ResourceDownloadLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutAuthorInput | ResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutAuthorInput | ResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutAuthorInput | ResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type CampaignRunUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput> | CampaignRunCreateWithoutInitiatorInput[] | CampaignRunUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutInitiatorInput | CampaignRunCreateOrConnectWithoutInitiatorInput[]
    upsert?: CampaignRunUpsertWithWhereUniqueWithoutInitiatorInput | CampaignRunUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: CampaignRunCreateManyInitiatorInputEnvelope
    set?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    disconnect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    delete?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    update?: CampaignRunUpdateWithWhereUniqueWithoutInitiatorInput | CampaignRunUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: CampaignRunUpdateManyWithWhereWithoutInitiatorInput | CampaignRunUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ContactSegmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput> | ContactSegmentCreateWithoutUserInput[] | ContactSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutUserInput | ContactSegmentCreateOrConnectWithoutUserInput[]
    upsert?: ContactSegmentUpsertWithWhereUniqueWithoutUserInput | ContactSegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactSegmentCreateManyUserInputEnvelope
    set?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    disconnect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    delete?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    connect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    update?: ContactSegmentUpdateWithWhereUniqueWithoutUserInput | ContactSegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactSegmentUpdateManyWithWhereWithoutUserInput | ContactSegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactSegmentScalarWhereInput | ContactSegmentScalarWhereInput[]
  }

  export type EvolutionApiConfigUpdateOneWithoutUserNestedInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutUserInput
    upsert?: EvolutionApiConfigUpsertWithoutUserInput
    disconnect?: EvolutionApiConfigWhereInput | boolean
    delete?: EvolutionApiConfigWhereInput | boolean
    connect?: EvolutionApiConfigWhereUniqueInput
    update?: XOR<XOR<EvolutionApiConfigUpdateToOneWithWhereWithoutUserInput, EvolutionApiConfigUpdateWithoutUserInput>, EvolutionApiConfigUncheckedUpdateWithoutUserInput>
  }

  export type MessageTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutUserInput | MessageTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutUserInput | MessageTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutUserInput | MessageTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type CourseProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutUserInput | CourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutUserInput | CourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutUserInput | CourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAuthorInput | CourseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAuthorInput | CourseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAuthorInput | CourseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput> | LessonCommentReplyCreateWithoutModeratedByInput[] | LessonCommentReplyUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutModeratedByInput | LessonCommentReplyCreateOrConnectWithoutModeratedByInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutModeratedByInput | LessonCommentReplyUpsertWithWhereUniqueWithoutModeratedByInput[]
    createMany?: LessonCommentReplyCreateManyModeratedByInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutModeratedByInput | LessonCommentReplyUpdateWithWhereUniqueWithoutModeratedByInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutModeratedByInput | LessonCommentReplyUpdateManyWithWhereWithoutModeratedByInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput> | LessonCommentReplyCreateWithoutUserInput[] | LessonCommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutUserInput | LessonCommentReplyCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutUserInput | LessonCommentReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentReplyCreateManyUserInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutUserInput | LessonCommentReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutUserInput | LessonCommentReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput = {
    create?: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput> | LessonCommentCreateWithoutModeratedByInput[] | LessonCommentUncheckedCreateWithoutModeratedByInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutModeratedByInput | LessonCommentCreateOrConnectWithoutModeratedByInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutModeratedByInput | LessonCommentUpsertWithWhereUniqueWithoutModeratedByInput[]
    createMany?: LessonCommentCreateManyModeratedByInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutModeratedByInput | LessonCommentUpdateWithWhereUniqueWithoutModeratedByInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutModeratedByInput | LessonCommentUpdateManyWithWhereWithoutModeratedByInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutUserInput | LessonCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutUserInput | LessonCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutUserInput | LessonCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput> | LessonProgressAggregateCreateWithoutUserInput[] | LessonProgressAggregateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutUserInput | LessonProgressAggregateCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressAggregateUpsertWithWhereUniqueWithoutUserInput | LessonProgressAggregateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressAggregateCreateManyUserInputEnvelope
    set?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    disconnect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    delete?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    update?: LessonProgressAggregateUpdateWithWhereUniqueWithoutUserInput | LessonProgressAggregateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressAggregateUpdateManyWithWhereWithoutUserInput | LessonProgressAggregateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
  }

  export type LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput> | LessonProgressEventCreateWithoutUserInput[] | LessonProgressEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutUserInput | LessonProgressEventCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressEventUpsertWithWhereUniqueWithoutUserInput | LessonProgressEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressEventCreateManyUserInputEnvelope
    set?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    disconnect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    delete?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    update?: LessonProgressEventUpdateWithWhereUniqueWithoutUserInput | LessonProgressEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressEventUpdateManyWithWhereWithoutUserInput | LessonProgressEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
  }

  export type LessonRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput> | LessonRatingCreateWithoutUserInput[] | LessonRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutUserInput | LessonRatingCreateOrConnectWithoutUserInput[]
    upsert?: LessonRatingUpsertWithWhereUniqueWithoutUserInput | LessonRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonRatingCreateManyUserInputEnvelope
    set?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    disconnect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    delete?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    update?: LessonRatingUpdateWithWhereUniqueWithoutUserInput | LessonRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonRatingUpdateManyWithWhereWithoutUserInput | LessonRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
  }

  export type FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput> | FeatureToggleCreateWithoutCreatedByInput[] | FeatureToggleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeatureToggleCreateOrConnectWithoutCreatedByInput | FeatureToggleCreateOrConnectWithoutCreatedByInput[]
    upsert?: FeatureToggleUpsertWithWhereUniqueWithoutCreatedByInput | FeatureToggleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FeatureToggleCreateManyCreatedByInputEnvelope
    set?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    disconnect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    delete?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    connect?: FeatureToggleWhereUniqueInput | FeatureToggleWhereUniqueInput[]
    update?: FeatureToggleUpdateWithWhereUniqueWithoutCreatedByInput | FeatureToggleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FeatureToggleUpdateManyWithWhereWithoutCreatedByInput | FeatureToggleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FeatureToggleScalarWhereInput | FeatureToggleScalarWhereInput[]
  }

  export type HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput> | HeroBannerCreateWithoutCreatedByInput[] | HeroBannerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: HeroBannerCreateOrConnectWithoutCreatedByInput | HeroBannerCreateOrConnectWithoutCreatedByInput[]
    upsert?: HeroBannerUpsertWithWhereUniqueWithoutCreatedByInput | HeroBannerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: HeroBannerCreateManyCreatedByInputEnvelope
    set?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    disconnect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    delete?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    connect?: HeroBannerWhereUniqueInput | HeroBannerWhereUniqueInput[]
    update?: HeroBannerUpdateWithWhereUniqueWithoutCreatedByInput | HeroBannerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: HeroBannerUpdateManyWithWhereWithoutCreatedByInput | HeroBannerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: HeroBannerScalarWhereInput | HeroBannerScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput = {
    create?: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput> | InvitationCreateWithoutAcceptedByInput[] | InvitationUncheckedCreateWithoutAcceptedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAcceptedByInput | InvitationCreateOrConnectWithoutAcceptedByInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAcceptedByInput | InvitationUpsertWithWhereUniqueWithoutAcceptedByInput[]
    createMany?: InvitationCreateManyAcceptedByInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAcceptedByInput | InvitationUpdateWithWhereUniqueWithoutAcceptedByInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAcceptedByInput | InvitationUpdateManyWithWhereWithoutAcceptedByInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput> | InvitationCreateWithoutInvitedByInput[] | InvitationUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInvitedByInput | InvitationCreateOrConnectWithoutInvitedByInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInvitedByInput | InvitationUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: InvitationCreateManyInvitedByInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInvitedByInput | InvitationUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInvitedByInput | InvitationUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput> | MemberAccessOverrideCreateWithoutGrantedByInput[] | MemberAccessOverrideUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutGrantedByInput | MemberAccessOverrideCreateOrConnectWithoutGrantedByInput[]
    upsert?: MemberAccessOverrideUpsertWithWhereUniqueWithoutGrantedByInput | MemberAccessOverrideUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: MemberAccessOverrideCreateManyGrantedByInputEnvelope
    set?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    disconnect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    delete?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    update?: MemberAccessOverrideUpdateWithWhereUniqueWithoutGrantedByInput | MemberAccessOverrideUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: MemberAccessOverrideUpdateManyWithWhereWithoutGrantedByInput | MemberAccessOverrideUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
  }

  export type MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput> | MemberAccessOverrideCreateWithoutUserInput[] | MemberAccessOverrideUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessOverrideCreateOrConnectWithoutUserInput | MemberAccessOverrideCreateOrConnectWithoutUserInput[]
    upsert?: MemberAccessOverrideUpsertWithWhereUniqueWithoutUserInput | MemberAccessOverrideUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberAccessOverrideCreateManyUserInputEnvelope
    set?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    disconnect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    delete?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    connect?: MemberAccessOverrideWhereUniqueInput | MemberAccessOverrideWhereUniqueInput[]
    update?: MemberAccessOverrideUpdateWithWhereUniqueWithoutUserInput | MemberAccessOverrideUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberAccessOverrideUpdateManyWithWhereWithoutUserInput | MemberAccessOverrideUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
  }

  export type MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput> | MemberAccessCreateWithoutGrantedByInput[] | MemberAccessUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutGrantedByInput | MemberAccessCreateOrConnectWithoutGrantedByInput[]
    upsert?: MemberAccessUpsertWithWhereUniqueWithoutGrantedByInput | MemberAccessUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: MemberAccessCreateManyGrantedByInputEnvelope
    set?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    disconnect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    delete?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    update?: MemberAccessUpdateWithWhereUniqueWithoutGrantedByInput | MemberAccessUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: MemberAccessUpdateManyWithWhereWithoutGrantedByInput | MemberAccessUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
  }

  export type MemberAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput> | MemberAccessCreateWithoutUserInput[] | MemberAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberAccessCreateOrConnectWithoutUserInput | MemberAccessCreateOrConnectWithoutUserInput[]
    upsert?: MemberAccessUpsertWithWhereUniqueWithoutUserInput | MemberAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberAccessCreateManyUserInputEnvelope
    set?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    disconnect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    delete?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    connect?: MemberAccessWhereUniqueInput | MemberAccessWhereUniqueInput[]
    update?: MemberAccessUpdateWithWhereUniqueWithoutUserInput | MemberAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberAccessUpdateManyWithWhereWithoutUserInput | MemberAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput> | ResourceDownloadLogCreateWithoutUserInput[] | ResourceDownloadLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutUserInput | ResourceDownloadLogCreateOrConnectWithoutUserInput[]
    upsert?: ResourceDownloadLogUpsertWithWhereUniqueWithoutUserInput | ResourceDownloadLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceDownloadLogCreateManyUserInputEnvelope
    set?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    disconnect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    delete?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    update?: ResourceDownloadLogUpdateWithWhereUniqueWithoutUserInput | ResourceDownloadLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceDownloadLogUpdateManyWithWhereWithoutUserInput | ResourceDownloadLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutAuthorInput | ResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutAuthorInput | ResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutAuthorInput | ResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput> | CampaignRunCreateWithoutInitiatorInput[] | CampaignRunUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutInitiatorInput | CampaignRunCreateOrConnectWithoutInitiatorInput[]
    upsert?: CampaignRunUpsertWithWhereUniqueWithoutInitiatorInput | CampaignRunUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: CampaignRunCreateManyInitiatorInputEnvelope
    set?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    disconnect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    delete?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    update?: CampaignRunUpdateWithWhereUniqueWithoutInitiatorInput | CampaignRunUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: CampaignRunUpdateManyWithWhereWithoutInitiatorInput | CampaignRunUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ContactSegmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput> | ContactSegmentCreateWithoutUserInput[] | ContactSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutUserInput | ContactSegmentCreateOrConnectWithoutUserInput[]
    upsert?: ContactSegmentUpsertWithWhereUniqueWithoutUserInput | ContactSegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactSegmentCreateManyUserInputEnvelope
    set?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    disconnect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    delete?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    connect?: ContactSegmentWhereUniqueInput | ContactSegmentWhereUniqueInput[]
    update?: ContactSegmentUpdateWithWhereUniqueWithoutUserInput | ContactSegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactSegmentUpdateManyWithWhereWithoutUserInput | ContactSegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactSegmentScalarWhereInput | ContactSegmentScalarWhereInput[]
  }

  export type EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutUserInput
    upsert?: EvolutionApiConfigUpsertWithoutUserInput
    disconnect?: EvolutionApiConfigWhereInput | boolean
    delete?: EvolutionApiConfigWhereInput | boolean
    connect?: EvolutionApiConfigWhereUniqueInput
    update?: XOR<XOR<EvolutionApiConfigUpdateToOneWithWhereWithoutUserInput, EvolutionApiConfigUpdateWithoutUserInput>, EvolutionApiConfigUncheckedUpdateWithoutUserInput>
  }

  export type MessageTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutUserInput | MessageTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutUserInput | MessageTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutUserInput | MessageTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type MemberAccessCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMemberAccessGrantsInput = {
    create?: XOR<UserCreateWithoutMemberAccessGrantsInput, UserUncheckedCreateWithoutMemberAccessGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberAccessGrantsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemberAccessesInput = {
    create?: XOR<UserCreateWithoutMemberAccessesInput, UserUncheckedCreateWithoutMemberAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberAccessesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeatureAccessKeyFieldUpdateOperationsInput = {
    set?: $Enums.FeatureAccessKey
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MemberAccessUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutMemberAccessGrantsNestedInput = {
    create?: XOR<UserCreateWithoutMemberAccessGrantsInput, UserUncheckedCreateWithoutMemberAccessGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberAccessGrantsInput
    upsert?: UserUpsertWithoutMemberAccessGrantsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberAccessGrantsInput, UserUpdateWithoutMemberAccessGrantsInput>, UserUncheckedUpdateWithoutMemberAccessGrantsInput>
  }

  export type UserUpdateOneRequiredWithoutMemberAccessesNestedInput = {
    create?: XOR<UserCreateWithoutMemberAccessesInput, UserUncheckedCreateWithoutMemberAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberAccessesInput
    upsert?: UserUpsertWithoutMemberAccessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberAccessesInput, UserUpdateWithoutMemberAccessesInput>, UserUncheckedUpdateWithoutMemberAccessesInput>
  }

  export type UserCreateNestedOneWithoutCreatedBannersInput = {
    create?: XOR<UserCreateWithoutCreatedBannersInput, UserUncheckedCreateWithoutCreatedBannersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBannersInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBannerStatusFieldUpdateOperationsInput = {
    set?: $Enums.BannerStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedBannersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBannersInput, UserUncheckedCreateWithoutCreatedBannersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBannersInput
    upsert?: UserUpsertWithoutCreatedBannersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBannersInput, UserUpdateWithoutCreatedBannersInput>, UserUncheckedUpdateWithoutCreatedBannersInput>
  }

  export type UserCreateNestedOneWithoutFeatureTogglesCreatedInput = {
    create?: XOR<UserCreateWithoutFeatureTogglesCreatedInput, UserUncheckedCreateWithoutFeatureTogglesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureTogglesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeatureToggleStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeatureToggleStatus
  }

  export type UserUpdateOneRequiredWithoutFeatureTogglesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutFeatureTogglesCreatedInput, UserUncheckedCreateWithoutFeatureTogglesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureTogglesCreatedInput
    upsert?: UserUpsertWithoutFeatureTogglesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeatureTogglesCreatedInput, UserUpdateWithoutFeatureTogglesCreatedInput>, UserUncheckedUpdateWithoutFeatureTogglesCreatedInput>
  }

  export type MemberAccessOverrideCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOverridesGrantedInput = {
    create?: XOR<UserCreateWithoutOverridesGrantedInput, UserUncheckedCreateWithoutOverridesGrantedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOverridesGrantedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccessOverridesInput = {
    create?: XOR<UserCreateWithoutAccessOverridesInput, UserUncheckedCreateWithoutAccessOverridesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessOverridesInput
    connect?: UserWhereUniqueInput
  }

  export type MemberAccessOverrideUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutOverridesGrantedNestedInput = {
    create?: XOR<UserCreateWithoutOverridesGrantedInput, UserUncheckedCreateWithoutOverridesGrantedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOverridesGrantedInput
    upsert?: UserUpsertWithoutOverridesGrantedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOverridesGrantedInput, UserUpdateWithoutOverridesGrantedInput>, UserUncheckedUpdateWithoutOverridesGrantedInput>
  }

  export type UserUpdateOneRequiredWithoutAccessOverridesNestedInput = {
    create?: XOR<UserCreateWithoutAccessOverridesInput, UserUncheckedCreateWithoutAccessOverridesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessOverridesInput
    upsert?: UserUpsertWithoutAccessOverridesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccessOverridesInput, UserUpdateWithoutAccessOverridesInput>, UserUncheckedUpdateWithoutAccessOverridesInput>
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type InvitationCreategrantedAccessInput = {
    set: $Enums.FeatureAccessKey[]
  }

  export type UserCreateNestedOneWithoutInvitationsAcceptedInput = {
    create?: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsAcceptedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type InvitationUpdategrantedAccessInput = {
    set?: $Enums.FeatureAccessKey[]
    push?: $Enums.FeatureAccessKey | $Enums.FeatureAccessKey[]
  }

  export type UserUpdateOneWithoutInvitationsAcceptedNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsAcceptedInput
    upsert?: UserUpsertWithoutInvitationsAcceptedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsAcceptedInput, UserUpdateWithoutInvitationsAcceptedInput>, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    upsert?: UserUpsertWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsSentInput, UserUpdateWithoutInvitationsSentInput>, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type CourseCreatetagsInput = {
    set: string[]
  }

  export type CourseModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type CourseProgressCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput> | CourseProgressCreateWithoutCourseInput[] | CourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutCourseInput | CourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: CourseProgressCreateManyCourseInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseRecommendationCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput> | CourseRecommendationCreateWithoutCourseInput[] | CourseRecommendationUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRecommendationCreateOrConnectWithoutCourseInput | CourseRecommendationCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRecommendationCreateManyCourseInputEnvelope
    connect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCoursesAuthoredInput = {
    create?: XOR<UserCreateWithoutCoursesAuthoredInput, UserUncheckedCreateWithoutCoursesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesAuthoredInput
    connect?: UserWhereUniqueInput
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type CourseProgressUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput> | CourseProgressCreateWithoutCourseInput[] | CourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutCourseInput | CourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: CourseProgressCreateManyCourseInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseRecommendationUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput> | CourseRecommendationCreateWithoutCourseInput[] | CourseRecommendationUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRecommendationCreateOrConnectWithoutCourseInput | CourseRecommendationCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRecommendationCreateManyCourseInputEnvelope
    connect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
  }

  export type EnumCourseLevelFieldUpdateOperationsInput = {
    set?: $Enums.CourseLevel
  }

  export type EnumCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatus
  }

  export type CourseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type CourseProgressUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput> | CourseProgressCreateWithoutCourseInput[] | CourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutCourseInput | CourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutCourseInput | CourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseProgressCreateManyCourseInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutCourseInput | CourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutCourseInput | CourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseRecommendationUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput> | CourseRecommendationCreateWithoutCourseInput[] | CourseRecommendationUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRecommendationCreateOrConnectWithoutCourseInput | CourseRecommendationCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRecommendationUpsertWithWhereUniqueWithoutCourseInput | CourseRecommendationUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRecommendationCreateManyCourseInputEnvelope
    set?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    disconnect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    delete?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    connect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    update?: CourseRecommendationUpdateWithWhereUniqueWithoutCourseInput | CourseRecommendationUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRecommendationUpdateManyWithWhereWithoutCourseInput | CourseRecommendationUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRecommendationScalarWhereInput | CourseRecommendationScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCoursesAuthoredNestedInput = {
    create?: XOR<UserCreateWithoutCoursesAuthoredInput, UserUncheckedCreateWithoutCoursesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesAuthoredInput
    upsert?: UserUpsertWithoutCoursesAuthoredInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesAuthoredInput, UserUpdateWithoutCoursesAuthoredInput>, UserUncheckedUpdateWithoutCoursesAuthoredInput>
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type CourseProgressUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput> | CourseProgressCreateWithoutCourseInput[] | CourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutCourseInput | CourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutCourseInput | CourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseProgressCreateManyCourseInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutCourseInput | CourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutCourseInput | CourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseRecommendationUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput> | CourseRecommendationCreateWithoutCourseInput[] | CourseRecommendationUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRecommendationCreateOrConnectWithoutCourseInput | CourseRecommendationCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRecommendationUpsertWithWhereUniqueWithoutCourseInput | CourseRecommendationUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRecommendationCreateManyCourseInputEnvelope
    set?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    disconnect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    delete?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    connect?: CourseRecommendationWhereUniqueInput | CourseRecommendationWhereUniqueInput[]
    update?: CourseRecommendationUpdateWithWhereUniqueWithoutCourseInput | CourseRecommendationUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRecommendationUpdateManyWithWhereWithoutCourseInput | CourseRecommendationUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRecommendationScalarWhereInput | CourseRecommendationScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseModuleCreateNestedOneWithoutDependentModulesInput = {
    create?: XOR<CourseModuleCreateWithoutDependentModulesInput, CourseModuleUncheckedCreateWithoutDependentModulesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDependentModulesInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type CourseModuleCreateNestedManyWithoutDripAfterModuleInput = {
    create?: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput> | CourseModuleCreateWithoutDripAfterModuleInput[] | CourseModuleUncheckedCreateWithoutDripAfterModuleInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDripAfterModuleInput | CourseModuleCreateOrConnectWithoutDripAfterModuleInput[]
    createMany?: CourseModuleCreateManyDripAfterModuleInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutDripAfterModuleInput = {
    create?: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput> | CourseModuleCreateWithoutDripAfterModuleInput[] | CourseModuleUncheckedCreateWithoutDripAfterModuleInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDripAfterModuleInput | CourseModuleCreateOrConnectWithoutDripAfterModuleInput[]
    createMany?: CourseModuleCreateManyDripAfterModuleInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseModuleUpdateOneWithoutDependentModulesNestedInput = {
    create?: XOR<CourseModuleCreateWithoutDependentModulesInput, CourseModuleUncheckedCreateWithoutDependentModulesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDependentModulesInput
    upsert?: CourseModuleUpsertWithoutDependentModulesInput
    disconnect?: CourseModuleWhereInput | boolean
    delete?: CourseModuleWhereInput | boolean
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutDependentModulesInput, CourseModuleUpdateWithoutDependentModulesInput>, CourseModuleUncheckedUpdateWithoutDependentModulesInput>
  }

  export type CourseModuleUpdateManyWithoutDripAfterModuleNestedInput = {
    create?: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput> | CourseModuleCreateWithoutDripAfterModuleInput[] | CourseModuleUncheckedCreateWithoutDripAfterModuleInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDripAfterModuleInput | CourseModuleCreateOrConnectWithoutDripAfterModuleInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutDripAfterModuleInput | CourseModuleUpsertWithWhereUniqueWithoutDripAfterModuleInput[]
    createMany?: CourseModuleCreateManyDripAfterModuleInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutDripAfterModuleInput | CourseModuleUpdateWithWhereUniqueWithoutDripAfterModuleInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutDripAfterModuleInput | CourseModuleUpdateManyWithWhereWithoutDripAfterModuleInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type CourseModuleUncheckedUpdateManyWithoutDripAfterModuleNestedInput = {
    create?: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput> | CourseModuleCreateWithoutDripAfterModuleInput[] | CourseModuleUncheckedCreateWithoutDripAfterModuleInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutDripAfterModuleInput | CourseModuleCreateOrConnectWithoutDripAfterModuleInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutDripAfterModuleInput | CourseModuleUpsertWithWhereUniqueWithoutDripAfterModuleInput[]
    createMany?: CourseModuleCreateManyDripAfterModuleInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutDripAfterModuleInput | CourseModuleUpdateWithWhereUniqueWithoutDripAfterModuleInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutDripAfterModuleInput | CourseModuleUpdateManyWithWhereWithoutDripAfterModuleInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonCommentCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonProgressAggregateCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput> | LessonProgressAggregateCreateWithoutLessonInput[] | LessonProgressAggregateUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutLessonInput | LessonProgressAggregateCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressAggregateCreateManyLessonInputEnvelope
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
  }

  export type LessonProgressEventCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput> | LessonProgressEventCreateWithoutLessonInput[] | LessonProgressEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutLessonInput | LessonProgressEventCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressEventCreateManyLessonInputEnvelope
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
  }

  export type LessonRatingCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput> | LessonRatingCreateWithoutLessonInput[] | LessonRatingUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutLessonInput | LessonRatingCreateOrConnectWithoutLessonInput[]
    createMany?: LessonRatingCreateManyLessonInputEnvelope
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
  }

  export type CourseModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutLessonsInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput> | LessonProgressAggregateCreateWithoutLessonInput[] | LessonProgressAggregateUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutLessonInput | LessonProgressAggregateCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressAggregateCreateManyLessonInputEnvelope
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
  }

  export type LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput> | LessonProgressEventCreateWithoutLessonInput[] | LessonProgressEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutLessonInput | LessonProgressEventCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressEventCreateManyLessonInputEnvelope
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
  }

  export type LessonRatingUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput> | LessonRatingCreateWithoutLessonInput[] | LessonRatingUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutLessonInput | LessonRatingCreateOrConnectWithoutLessonInput[]
    createMany?: LessonRatingCreateManyLessonInputEnvelope
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type LessonCommentUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutLessonInput | LessonCommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutLessonInput | LessonCommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutLessonInput | LessonCommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonProgressAggregateUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput> | LessonProgressAggregateCreateWithoutLessonInput[] | LessonProgressAggregateUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutLessonInput | LessonProgressAggregateCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressAggregateUpsertWithWhereUniqueWithoutLessonInput | LessonProgressAggregateUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressAggregateCreateManyLessonInputEnvelope
    set?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    disconnect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    delete?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    update?: LessonProgressAggregateUpdateWithWhereUniqueWithoutLessonInput | LessonProgressAggregateUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressAggregateUpdateManyWithWhereWithoutLessonInput | LessonProgressAggregateUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
  }

  export type LessonProgressEventUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput> | LessonProgressEventCreateWithoutLessonInput[] | LessonProgressEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutLessonInput | LessonProgressEventCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressEventUpsertWithWhereUniqueWithoutLessonInput | LessonProgressEventUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressEventCreateManyLessonInputEnvelope
    set?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    disconnect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    delete?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    update?: LessonProgressEventUpdateWithWhereUniqueWithoutLessonInput | LessonProgressEventUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressEventUpdateManyWithWhereWithoutLessonInput | LessonProgressEventUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
  }

  export type LessonRatingUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput> | LessonRatingCreateWithoutLessonInput[] | LessonRatingUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutLessonInput | LessonRatingCreateOrConnectWithoutLessonInput[]
    upsert?: LessonRatingUpsertWithWhereUniqueWithoutLessonInput | LessonRatingUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonRatingCreateManyLessonInputEnvelope
    set?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    disconnect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    delete?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    update?: LessonRatingUpdateWithWhereUniqueWithoutLessonInput | LessonRatingUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonRatingUpdateManyWithWhereWithoutLessonInput | LessonRatingUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
  }

  export type CourseModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutLessonsInput
    upsert?: CourseModuleUpsertWithoutLessonsInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutLessonsInput, CourseModuleUpdateWithoutLessonsInput>, CourseModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonCommentUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutLessonInput | LessonCommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutLessonInput | LessonCommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutLessonInput | LessonCommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput> | LessonProgressAggregateCreateWithoutLessonInput[] | LessonProgressAggregateUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressAggregateCreateOrConnectWithoutLessonInput | LessonProgressAggregateCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressAggregateUpsertWithWhereUniqueWithoutLessonInput | LessonProgressAggregateUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressAggregateCreateManyLessonInputEnvelope
    set?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    disconnect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    delete?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    connect?: LessonProgressAggregateWhereUniqueInput | LessonProgressAggregateWhereUniqueInput[]
    update?: LessonProgressAggregateUpdateWithWhereUniqueWithoutLessonInput | LessonProgressAggregateUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressAggregateUpdateManyWithWhereWithoutLessonInput | LessonProgressAggregateUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
  }

  export type LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput> | LessonProgressEventCreateWithoutLessonInput[] | LessonProgressEventUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressEventCreateOrConnectWithoutLessonInput | LessonProgressEventCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressEventUpsertWithWhereUniqueWithoutLessonInput | LessonProgressEventUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressEventCreateManyLessonInputEnvelope
    set?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    disconnect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    delete?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    connect?: LessonProgressEventWhereUniqueInput | LessonProgressEventWhereUniqueInput[]
    update?: LessonProgressEventUpdateWithWhereUniqueWithoutLessonInput | LessonProgressEventUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressEventUpdateManyWithWhereWithoutLessonInput | LessonProgressEventUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
  }

  export type LessonRatingUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput> | LessonRatingCreateWithoutLessonInput[] | LessonRatingUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonRatingCreateOrConnectWithoutLessonInput | LessonRatingCreateOrConnectWithoutLessonInput[]
    upsert?: LessonRatingUpsertWithWhereUniqueWithoutLessonInput | LessonRatingUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonRatingCreateManyLessonInputEnvelope
    set?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    disconnect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    delete?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    connect?: LessonRatingWhereUniqueInput | LessonRatingWhereUniqueInput[]
    update?: LessonRatingUpdateWithWhereUniqueWithoutLessonInput | LessonRatingUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonRatingUpdateManyWithWhereWithoutLessonInput | LessonRatingUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
  }

  export type CourseProgressCreatecompletedLessonIdsInput = {
    set: string[]
  }

  export type CourseCreateNestedOneWithoutProgressesInput = {
    create?: XOR<CourseCreateWithoutProgressesInput, CourseUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressesInput
    connect?: CourseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCourseProgressesInput = {
    create?: XOR<UserCreateWithoutCourseProgressesInput, UserUncheckedCreateWithoutCourseProgressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProgressesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseProgressUpdatecompletedLessonIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdateOneRequiredWithoutProgressesNestedInput = {
    create?: XOR<CourseCreateWithoutProgressesInput, CourseUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressesInput
    upsert?: CourseUpsertWithoutProgressesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutProgressesInput, CourseUpdateWithoutProgressesInput>, CourseUncheckedUpdateWithoutProgressesInput>
  }

  export type UserUpdateOneRequiredWithoutCourseProgressesNestedInput = {
    create?: XOR<UserCreateWithoutCourseProgressesInput, UserUncheckedCreateWithoutCourseProgressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProgressesInput
    upsert?: UserUpsertWithoutCourseProgressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseProgressesInput, UserUpdateWithoutCourseProgressesInput>, UserUncheckedUpdateWithoutCourseProgressesInput>
  }

  export type LessonCommentReplyCreateNestedManyWithoutCommentInput = {
    create?: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput> | LessonCommentReplyCreateWithoutCommentInput[] | LessonCommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutCommentInput | LessonCommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: LessonCommentReplyCreateManyCommentInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModeratedLessonCommentsInput = {
    create?: XOR<UserCreateWithoutModeratedLessonCommentsInput, UserUncheckedCreateWithoutModeratedLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedLessonCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonCommentsInput = {
    create?: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCommentReplyUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput> | LessonCommentReplyCreateWithoutCommentInput[] | LessonCommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutCommentInput | LessonCommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: LessonCommentReplyCreateManyCommentInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type EnumLessonCommentModerationStatusFieldUpdateOperationsInput = {
    set?: $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentReplyUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput> | LessonCommentReplyCreateWithoutCommentInput[] | LessonCommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutCommentInput | LessonCommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutCommentInput | LessonCommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LessonCommentReplyCreateManyCommentInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutCommentInput | LessonCommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutCommentInput | LessonCommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    upsert?: LessonUpsertWithoutCommentsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCommentsInput, LessonUpdateWithoutCommentsInput>, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutModeratedLessonCommentsNestedInput = {
    create?: XOR<UserCreateWithoutModeratedLessonCommentsInput, UserUncheckedCreateWithoutModeratedLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedLessonCommentsInput
    upsert?: UserUpsertWithoutModeratedLessonCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModeratedLessonCommentsInput, UserUpdateWithoutModeratedLessonCommentsInput>, UserUncheckedUpdateWithoutModeratedLessonCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutLessonCommentsNestedInput = {
    create?: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentsInput
    upsert?: UserUpsertWithoutLessonCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonCommentsInput, UserUpdateWithoutLessonCommentsInput>, UserUncheckedUpdateWithoutLessonCommentsInput>
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput> | LessonCommentReplyCreateWithoutCommentInput[] | LessonCommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutCommentInput | LessonCommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutCommentInput | LessonCommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LessonCommentReplyCreateManyCommentInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutCommentInput | LessonCommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutCommentInput | LessonCommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type LessonCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentCreateOrConnectWithoutRepliesInput
    connect?: LessonCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput = {
    create?: XOR<UserCreateWithoutModeratedLessonCommentRepliesInput, UserUncheckedCreateWithoutModeratedLessonCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedLessonCommentRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCommentReplyCreateNestedOneWithoutRepliesInput = {
    create?: XOR<LessonCommentReplyCreateWithoutRepliesInput, LessonCommentReplyUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutRepliesInput
    connect?: LessonCommentReplyWhereUniqueInput
  }

  export type LessonCommentReplyCreateNestedManyWithoutParentReplyInput = {
    create?: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput> | LessonCommentReplyCreateWithoutParentReplyInput[] | LessonCommentReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutParentReplyInput | LessonCommentReplyCreateOrConnectWithoutParentReplyInput[]
    createMany?: LessonCommentReplyCreateManyParentReplyInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutLessonCommentRepliesInput = {
    create?: XOR<UserCreateWithoutLessonCommentRepliesInput, UserUncheckedCreateWithoutLessonCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput = {
    create?: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput> | LessonCommentReplyCreateWithoutParentReplyInput[] | LessonCommentReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutParentReplyInput | LessonCommentReplyCreateOrConnectWithoutParentReplyInput[]
    createMany?: LessonCommentReplyCreateManyParentReplyInputEnvelope
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
  }

  export type LessonCommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentCreateOrConnectWithoutRepliesInput
    upsert?: LessonCommentUpsertWithoutRepliesInput
    connect?: LessonCommentWhereUniqueInput
    update?: XOR<XOR<LessonCommentUpdateToOneWithWhereWithoutRepliesInput, LessonCommentUpdateWithoutRepliesInput>, LessonCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput = {
    create?: XOR<UserCreateWithoutModeratedLessonCommentRepliesInput, UserUncheckedCreateWithoutModeratedLessonCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedLessonCommentRepliesInput
    upsert?: UserUpsertWithoutModeratedLessonCommentRepliesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModeratedLessonCommentRepliesInput, UserUpdateWithoutModeratedLessonCommentRepliesInput>, UserUncheckedUpdateWithoutModeratedLessonCommentRepliesInput>
  }

  export type LessonCommentReplyUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutRepliesInput, LessonCommentReplyUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutRepliesInput
    upsert?: LessonCommentReplyUpsertWithoutRepliesInput
    disconnect?: LessonCommentReplyWhereInput | boolean
    delete?: LessonCommentReplyWhereInput | boolean
    connect?: LessonCommentReplyWhereUniqueInput
    update?: XOR<XOR<LessonCommentReplyUpdateToOneWithWhereWithoutRepliesInput, LessonCommentReplyUpdateWithoutRepliesInput>, LessonCommentReplyUncheckedUpdateWithoutRepliesInput>
  }

  export type LessonCommentReplyUpdateManyWithoutParentReplyNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput> | LessonCommentReplyCreateWithoutParentReplyInput[] | LessonCommentReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutParentReplyInput | LessonCommentReplyCreateOrConnectWithoutParentReplyInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutParentReplyInput | LessonCommentReplyUpsertWithWhereUniqueWithoutParentReplyInput[]
    createMany?: LessonCommentReplyCreateManyParentReplyInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutParentReplyInput | LessonCommentReplyUpdateWithWhereUniqueWithoutParentReplyInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutParentReplyInput | LessonCommentReplyUpdateManyWithWhereWithoutParentReplyInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput = {
    create?: XOR<UserCreateWithoutLessonCommentRepliesInput, UserUncheckedCreateWithoutLessonCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentRepliesInput
    upsert?: UserUpsertWithoutLessonCommentRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonCommentRepliesInput, UserUpdateWithoutLessonCommentRepliesInput>, UserUncheckedUpdateWithoutLessonCommentRepliesInput>
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput = {
    create?: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput> | LessonCommentReplyCreateWithoutParentReplyInput[] | LessonCommentReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: LessonCommentReplyCreateOrConnectWithoutParentReplyInput | LessonCommentReplyCreateOrConnectWithoutParentReplyInput[]
    upsert?: LessonCommentReplyUpsertWithWhereUniqueWithoutParentReplyInput | LessonCommentReplyUpsertWithWhereUniqueWithoutParentReplyInput[]
    createMany?: LessonCommentReplyCreateManyParentReplyInputEnvelope
    set?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    disconnect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    delete?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    connect?: LessonCommentReplyWhereUniqueInput | LessonCommentReplyWhereUniqueInput[]
    update?: LessonCommentReplyUpdateWithWhereUniqueWithoutParentReplyInput | LessonCommentReplyUpdateWithWhereUniqueWithoutParentReplyInput[]
    updateMany?: LessonCommentReplyUpdateManyWithWhereWithoutParentReplyInput | LessonCommentReplyUpdateManyWithWhereWithoutParentReplyInput[]
    deleteMany?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutRecommendationsInput = {
    create?: XOR<CourseCreateWithoutRecommendationsInput, CourseUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRecommendationsInput
    connect?: CourseWhereUniqueInput
  }

  export type NullableEnumRecommendationBadgeFieldUpdateOperationsInput = {
    set?: $Enums.RecommendationBadge | null
  }

  export type CourseUpdateOneRequiredWithoutRecommendationsNestedInput = {
    create?: XOR<CourseCreateWithoutRecommendationsInput, CourseUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRecommendationsInput
    upsert?: CourseUpsertWithoutRecommendationsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutRecommendationsInput, CourseUpdateWithoutRecommendationsInput>, CourseUncheckedUpdateWithoutRecommendationsInput>
  }

  export type LessonCreateNestedOneWithoutRatingsInput = {
    create?: XOR<LessonCreateWithoutRatingsInput, LessonUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutRatingsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonRatingInput = {
    create?: XOR<UserCreateWithoutLessonRatingInput, UserUncheckedCreateWithoutLessonRatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonRatingInput
    connect?: UserWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<LessonCreateWithoutRatingsInput, LessonUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutRatingsInput
    upsert?: LessonUpsertWithoutRatingsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutRatingsInput, LessonUpdateWithoutRatingsInput>, LessonUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutLessonRatingNestedInput = {
    create?: XOR<UserCreateWithoutLessonRatingInput, UserUncheckedCreateWithoutLessonRatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonRatingInput
    upsert?: UserUpsertWithoutLessonRatingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonRatingInput, UserUpdateWithoutLessonRatingInput>, UserUncheckedUpdateWithoutLessonRatingInput>
  }

  export type LessonCreateNestedOneWithoutProgressEventsInput = {
    create?: XOR<LessonCreateWithoutProgressEventsInput, LessonUncheckedCreateWithoutProgressEventsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressEventsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonProgressEventInput = {
    create?: XOR<UserCreateWithoutLessonProgressEventInput, UserUncheckedCreateWithoutLessonProgressEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressEventInput
    connect?: UserWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutProgressEventsNestedInput = {
    create?: XOR<LessonCreateWithoutProgressEventsInput, LessonUncheckedCreateWithoutProgressEventsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressEventsInput
    upsert?: LessonUpsertWithoutProgressEventsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressEventsInput, LessonUpdateWithoutProgressEventsInput>, LessonUncheckedUpdateWithoutProgressEventsInput>
  }

  export type UserUpdateOneRequiredWithoutLessonProgressEventNestedInput = {
    create?: XOR<UserCreateWithoutLessonProgressEventInput, UserUncheckedCreateWithoutLessonProgressEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressEventInput
    upsert?: UserUpsertWithoutLessonProgressEventInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonProgressEventInput, UserUpdateWithoutLessonProgressEventInput>, UserUncheckedUpdateWithoutLessonProgressEventInput>
  }

  export type LessonCreateNestedOneWithoutProgressAggregatesInput = {
    create?: XOR<LessonCreateWithoutProgressAggregatesInput, LessonUncheckedCreateWithoutProgressAggregatesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressAggregatesInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonProgressAggregateInput = {
    create?: XOR<UserCreateWithoutLessonProgressAggregateInput, UserUncheckedCreateWithoutLessonProgressAggregateInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressAggregateInput
    connect?: UserWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutProgressAggregatesNestedInput = {
    create?: XOR<LessonCreateWithoutProgressAggregatesInput, LessonUncheckedCreateWithoutProgressAggregatesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressAggregatesInput
    upsert?: LessonUpsertWithoutProgressAggregatesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressAggregatesInput, LessonUpdateWithoutProgressAggregatesInput>, LessonUncheckedUpdateWithoutProgressAggregatesInput>
  }

  export type UserUpdateOneRequiredWithoutLessonProgressAggregateNestedInput = {
    create?: XOR<UserCreateWithoutLessonProgressAggregateInput, UserUncheckedCreateWithoutLessonProgressAggregateInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressAggregateInput
    upsert?: UserUpsertWithoutLessonProgressAggregateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonProgressAggregateInput, UserUpdateWithoutLessonProgressAggregateInput>, UserUncheckedUpdateWithoutLessonProgressAggregateInput>
  }

  export type CampaignCreateNestedManyWithoutEvolutionConfigInput = {
    create?: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput> | CampaignCreateWithoutEvolutionConfigInput[] | CampaignUncheckedCreateWithoutEvolutionConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutEvolutionConfigInput | CampaignCreateOrConnectWithoutEvolutionConfigInput[]
    createMany?: CampaignCreateManyEvolutionConfigInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEvolutionConfigInput = {
    create?: XOR<UserCreateWithoutEvolutionConfigInput, UserUncheckedCreateWithoutEvolutionConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvolutionConfigInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutEvolutionConfigInput = {
    create?: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput> | CampaignCreateWithoutEvolutionConfigInput[] | CampaignUncheckedCreateWithoutEvolutionConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutEvolutionConfigInput | CampaignCreateOrConnectWithoutEvolutionConfigInput[]
    createMany?: CampaignCreateManyEvolutionConfigInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type EnumEvolutionConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.EvolutionConnectionStatus
  }

  export type CampaignUpdateManyWithoutEvolutionConfigNestedInput = {
    create?: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput> | CampaignCreateWithoutEvolutionConfigInput[] | CampaignUncheckedCreateWithoutEvolutionConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutEvolutionConfigInput | CampaignCreateOrConnectWithoutEvolutionConfigInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutEvolutionConfigInput | CampaignUpsertWithWhereUniqueWithoutEvolutionConfigInput[]
    createMany?: CampaignCreateManyEvolutionConfigInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutEvolutionConfigInput | CampaignUpdateWithWhereUniqueWithoutEvolutionConfigInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutEvolutionConfigInput | CampaignUpdateManyWithWhereWithoutEvolutionConfigInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEvolutionConfigNestedInput = {
    create?: XOR<UserCreateWithoutEvolutionConfigInput, UserUncheckedCreateWithoutEvolutionConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvolutionConfigInput
    upsert?: UserUpsertWithoutEvolutionConfigInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvolutionConfigInput, UserUpdateWithoutEvolutionConfigInput>, UserUncheckedUpdateWithoutEvolutionConfigInput>
  }

  export type CampaignUncheckedUpdateManyWithoutEvolutionConfigNestedInput = {
    create?: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput> | CampaignCreateWithoutEvolutionConfigInput[] | CampaignUncheckedCreateWithoutEvolutionConfigInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutEvolutionConfigInput | CampaignCreateOrConnectWithoutEvolutionConfigInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutEvolutionConfigInput | CampaignUpsertWithWhereUniqueWithoutEvolutionConfigInput[]
    createMany?: CampaignCreateManyEvolutionConfigInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutEvolutionConfigInput | CampaignUpdateWithWhereUniqueWithoutEvolutionConfigInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutEvolutionConfigInput | CampaignUpdateManyWithWhereWithoutEvolutionConfigInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignCreateNestedManyWithoutSegmentInput = {
    create?: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput> | CampaignCreateWithoutSegmentInput[] | CampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSegmentInput | CampaignCreateOrConnectWithoutSegmentInput[]
    createMany?: CampaignCreateManySegmentInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutContactSegmentsInput = {
    create?: XOR<UserCreateWithoutContactSegmentsInput, UserUncheckedCreateWithoutContactSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactSegmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput> | CampaignCreateWithoutSegmentInput[] | CampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSegmentInput | CampaignCreateOrConnectWithoutSegmentInput[]
    createMany?: CampaignCreateManySegmentInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type EnumContactImportSourceFieldUpdateOperationsInput = {
    set?: $Enums.ContactImportSource
  }

  export type CampaignUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput> | CampaignCreateWithoutSegmentInput[] | CampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSegmentInput | CampaignCreateOrConnectWithoutSegmentInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSegmentInput | CampaignUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: CampaignCreateManySegmentInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSegmentInput | CampaignUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSegmentInput | CampaignUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutContactSegmentsNestedInput = {
    create?: XOR<UserCreateWithoutContactSegmentsInput, UserUncheckedCreateWithoutContactSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactSegmentsInput
    upsert?: UserUpsertWithoutContactSegmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactSegmentsInput, UserUpdateWithoutContactSegmentsInput>, UserUncheckedUpdateWithoutContactSegmentsInput>
  }

  export type CampaignUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput> | CampaignCreateWithoutSegmentInput[] | CampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSegmentInput | CampaignCreateOrConnectWithoutSegmentInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSegmentInput | CampaignUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: CampaignCreateManySegmentInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSegmentInput | CampaignUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSegmentInput | CampaignUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type MessageTemplateCreatevariablesInput = {
    set: string[]
  }

  export type CampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMessageTemplatesInput = {
    create?: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type MessageTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutMessageTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageTemplatesInput
    upsert?: UserUpsertWithoutMessageTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageTemplatesInput, UserUpdateWithoutMessageTemplatesInput>, UserUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMetricsCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput
    connect?: CampaignMetricsWhereUniqueInput
  }

  export type CampaignRunCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput> | CampaignRunCreateWithoutCampaignInput[] | CampaignRunUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutCampaignInput | CampaignRunCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRunCreateManyCampaignInputEnvelope
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
  }

  export type CampaignTimelinePointCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput> | CampaignTimelinePointCreateWithoutCampaignInput[] | CampaignTimelinePointUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelinePointCreateOrConnectWithoutCampaignInput | CampaignTimelinePointCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTimelinePointCreateManyCampaignInputEnvelope
    connect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
  }

  export type EvolutionApiConfigCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutCampaignsInput, EvolutionApiConfigUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutCampaignsInput
    connect?: EvolutionApiConfigWhereUniqueInput
  }

  export type ContactSegmentCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ContactSegmentCreateWithoutCampaignsInput, ContactSegmentUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutCampaignsInput
    connect?: ContactSegmentWhereUniqueInput
  }

  export type MessageTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<MessageTemplateCreateWithoutCampaignsInput, MessageTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCampaignsInput
    connect?: MessageTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput
    connect?: CampaignMetricsWhereUniqueInput
  }

  export type CampaignRunUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput> | CampaignRunCreateWithoutCampaignInput[] | CampaignRunUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutCampaignInput | CampaignRunCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRunCreateManyCampaignInputEnvelope
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
  }

  export type CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput> | CampaignTimelinePointCreateWithoutCampaignInput[] | CampaignTimelinePointUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelinePointCreateOrConnectWithoutCampaignInput | CampaignTimelinePointCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTimelinePointCreateManyCampaignInputEnvelope
    connect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
  }

  export type EnumCampaignChannelFieldUpdateOperationsInput = {
    set?: $Enums.CampaignChannel
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type CampaignMetricsUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignMetricsUpsertWithoutCampaignInput
    disconnect?: CampaignMetricsWhereInput | boolean
    delete?: CampaignMetricsWhereInput | boolean
    connect?: CampaignMetricsWhereUniqueInput
    update?: XOR<XOR<CampaignMetricsUpdateToOneWithWhereWithoutCampaignInput, CampaignMetricsUpdateWithoutCampaignInput>, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignRunUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput> | CampaignRunCreateWithoutCampaignInput[] | CampaignRunUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutCampaignInput | CampaignRunCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRunUpsertWithWhereUniqueWithoutCampaignInput | CampaignRunUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRunCreateManyCampaignInputEnvelope
    set?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    disconnect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    delete?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    update?: CampaignRunUpdateWithWhereUniqueWithoutCampaignInput | CampaignRunUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRunUpdateManyWithWhereWithoutCampaignInput | CampaignRunUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
  }

  export type CampaignTimelinePointUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput> | CampaignTimelinePointCreateWithoutCampaignInput[] | CampaignTimelinePointUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelinePointCreateOrConnectWithoutCampaignInput | CampaignTimelinePointCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTimelinePointUpsertWithWhereUniqueWithoutCampaignInput | CampaignTimelinePointUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTimelinePointCreateManyCampaignInputEnvelope
    set?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    disconnect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    delete?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    connect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    update?: CampaignTimelinePointUpdateWithWhereUniqueWithoutCampaignInput | CampaignTimelinePointUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTimelinePointUpdateManyWithWhereWithoutCampaignInput | CampaignTimelinePointUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTimelinePointScalarWhereInput | CampaignTimelinePointScalarWhereInput[]
  }

  export type EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<EvolutionApiConfigCreateWithoutCampaignsInput, EvolutionApiConfigUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EvolutionApiConfigCreateOrConnectWithoutCampaignsInput
    upsert?: EvolutionApiConfigUpsertWithoutCampaignsInput
    disconnect?: EvolutionApiConfigWhereInput | boolean
    delete?: EvolutionApiConfigWhereInput | boolean
    connect?: EvolutionApiConfigWhereUniqueInput
    update?: XOR<XOR<EvolutionApiConfigUpdateToOneWithWhereWithoutCampaignsInput, EvolutionApiConfigUpdateWithoutCampaignsInput>, EvolutionApiConfigUncheckedUpdateWithoutCampaignsInput>
  }

  export type ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ContactSegmentCreateWithoutCampaignsInput, ContactSegmentUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ContactSegmentCreateOrConnectWithoutCampaignsInput
    upsert?: ContactSegmentUpsertWithoutCampaignsInput
    connect?: ContactSegmentWhereUniqueInput
    update?: XOR<XOR<ContactSegmentUpdateToOneWithWhereWithoutCampaignsInput, ContactSegmentUpdateWithoutCampaignsInput>, ContactSegmentUncheckedUpdateWithoutCampaignsInput>
  }

  export type MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutCampaignsInput, MessageTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: MessageTemplateUpsertWithoutCampaignsInput
    connect?: MessageTemplateWhereUniqueInput
    update?: XOR<XOR<MessageTemplateUpdateToOneWithWhereWithoutCampaignsInput, MessageTemplateUpdateWithoutCampaignsInput>, MessageTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignMetricsUpsertWithoutCampaignInput
    disconnect?: CampaignMetricsWhereInput | boolean
    delete?: CampaignMetricsWhereInput | boolean
    connect?: CampaignMetricsWhereUniqueInput
    update?: XOR<XOR<CampaignMetricsUpdateToOneWithWhereWithoutCampaignInput, CampaignMetricsUpdateWithoutCampaignInput>, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput> | CampaignRunCreateWithoutCampaignInput[] | CampaignRunUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRunCreateOrConnectWithoutCampaignInput | CampaignRunCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRunUpsertWithWhereUniqueWithoutCampaignInput | CampaignRunUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRunCreateManyCampaignInputEnvelope
    set?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    disconnect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    delete?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    connect?: CampaignRunWhereUniqueInput | CampaignRunWhereUniqueInput[]
    update?: CampaignRunUpdateWithWhereUniqueWithoutCampaignInput | CampaignRunUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRunUpdateManyWithWhereWithoutCampaignInput | CampaignRunUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
  }

  export type CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput> | CampaignTimelinePointCreateWithoutCampaignInput[] | CampaignTimelinePointUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelinePointCreateOrConnectWithoutCampaignInput | CampaignTimelinePointCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTimelinePointUpsertWithWhereUniqueWithoutCampaignInput | CampaignTimelinePointUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTimelinePointCreateManyCampaignInputEnvelope
    set?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    disconnect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    delete?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    connect?: CampaignTimelinePointWhereUniqueInput | CampaignTimelinePointWhereUniqueInput[]
    update?: CampaignTimelinePointUpdateWithWhereUniqueWithoutCampaignInput | CampaignTimelinePointUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTimelinePointUpdateManyWithWhereWithoutCampaignInput | CampaignTimelinePointUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTimelinePointScalarWhereInput | CampaignTimelinePointScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutRunsInput = {
    create?: XOR<CampaignCreateWithoutRunsInput, CampaignUncheckedCreateWithoutRunsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRunsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignRunsInitiatedInput = {
    create?: XOR<UserCreateWithoutCampaignRunsInitiatedInput, UserUncheckedCreateWithoutCampaignRunsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignRunsInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<CampaignCreateWithoutRunsInput, CampaignUncheckedCreateWithoutRunsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRunsInput
    upsert?: CampaignUpsertWithoutRunsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRunsInput, CampaignUpdateWithoutRunsInput>, CampaignUncheckedUpdateWithoutRunsInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignRunsInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutCampaignRunsInitiatedInput, UserUncheckedCreateWithoutCampaignRunsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignRunsInitiatedInput
    upsert?: UserUpsertWithoutCampaignRunsInitiatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignRunsInitiatedInput, UserUpdateWithoutCampaignRunsInitiatedInput>, UserUncheckedUpdateWithoutCampaignRunsInitiatedInput>
  }

  export type CampaignCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    upsert?: CampaignUpsertWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMetricsInput, CampaignUpdateWithoutMetricsInput>, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type CampaignCreateNestedOneWithoutTimelineInput = {
    create?: XOR<CampaignCreateWithoutTimelineInput, CampaignUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTimelineInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutTimelineNestedInput = {
    create?: XOR<CampaignCreateWithoutTimelineInput, CampaignUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTimelineInput
    upsert?: CampaignUpsertWithoutTimelineInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTimelineInput, CampaignUpdateWithoutTimelineInput>, CampaignUncheckedUpdateWithoutTimelineInput>
  }

  export type ResourceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput> | ResourceCreateWithoutCategoryInput[] | ResourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutCategoryInput | ResourceCreateOrConnectWithoutCategoryInput[]
    createMany?: ResourceCreateManyCategoryInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput> | ResourceCreateWithoutCategoryInput[] | ResourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutCategoryInput | ResourceCreateOrConnectWithoutCategoryInput[]
    createMany?: ResourceCreateManyCategoryInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ResourceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput> | ResourceCreateWithoutCategoryInput[] | ResourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutCategoryInput | ResourceCreateOrConnectWithoutCategoryInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutCategoryInput | ResourceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResourceCreateManyCategoryInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutCategoryInput | ResourceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutCategoryInput | ResourceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput> | ResourceCreateWithoutCategoryInput[] | ResourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutCategoryInput | ResourceCreateOrConnectWithoutCategoryInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutCategoryInput | ResourceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResourceCreateManyCategoryInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutCategoryInput | ResourceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutCategoryInput | ResourceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ResourceTagAssignmentCreateNestedManyWithoutTagInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput> | ResourceTagAssignmentCreateWithoutTagInput[] | ResourceTagAssignmentUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutTagInput | ResourceTagAssignmentCreateOrConnectWithoutTagInput[]
    createMany?: ResourceTagAssignmentCreateManyTagInputEnvelope
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
  }

  export type ResourceTagAssignmentUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput> | ResourceTagAssignmentCreateWithoutTagInput[] | ResourceTagAssignmentUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutTagInput | ResourceTagAssignmentCreateOrConnectWithoutTagInput[]
    createMany?: ResourceTagAssignmentCreateManyTagInputEnvelope
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
  }

  export type ResourceTagAssignmentUpdateManyWithoutTagNestedInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput> | ResourceTagAssignmentCreateWithoutTagInput[] | ResourceTagAssignmentUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutTagInput | ResourceTagAssignmentCreateOrConnectWithoutTagInput[]
    upsert?: ResourceTagAssignmentUpsertWithWhereUniqueWithoutTagInput | ResourceTagAssignmentUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ResourceTagAssignmentCreateManyTagInputEnvelope
    set?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    disconnect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    delete?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    update?: ResourceTagAssignmentUpdateWithWhereUniqueWithoutTagInput | ResourceTagAssignmentUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ResourceTagAssignmentUpdateManyWithWhereWithoutTagInput | ResourceTagAssignmentUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
  }

  export type ResourceTagAssignmentUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput> | ResourceTagAssignmentCreateWithoutTagInput[] | ResourceTagAssignmentUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutTagInput | ResourceTagAssignmentCreateOrConnectWithoutTagInput[]
    upsert?: ResourceTagAssignmentUpsertWithWhereUniqueWithoutTagInput | ResourceTagAssignmentUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ResourceTagAssignmentCreateManyTagInputEnvelope
    set?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    disconnect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    delete?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    update?: ResourceTagAssignmentUpdateWithWhereUniqueWithoutTagInput | ResourceTagAssignmentUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ResourceTagAssignmentUpdateManyWithWhereWithoutTagInput | ResourceTagAssignmentUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
  }

  export type ResourceAssetCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput> | ResourceAssetCreateWithoutResourceInput[] | ResourceAssetUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceAssetCreateOrConnectWithoutResourceInput | ResourceAssetCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceAssetCreateManyResourceInputEnvelope
    connect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
  }

  export type ResourceDownloadLogCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput> | ResourceDownloadLogCreateWithoutResourceInput[] | ResourceDownloadLogUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutResourceInput | ResourceDownloadLogCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceDownloadLogCreateManyResourceInputEnvelope
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
  }

  export type ResourceTagAssignmentCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput> | ResourceTagAssignmentCreateWithoutResourceInput[] | ResourceTagAssignmentUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutResourceInput | ResourceTagAssignmentCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceTagAssignmentCreateManyResourceInputEnvelope
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
  }

  export type ResourceCategoryCreateNestedOneWithoutResourcesInput = {
    create?: XOR<ResourceCategoryCreateWithoutResourcesInput, ResourceCategoryUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ResourceCategoryCreateOrConnectWithoutResourcesInput
    connect?: ResourceCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResourcesAuthoredInput = {
    create?: XOR<UserCreateWithoutResourcesAuthoredInput, UserUncheckedCreateWithoutResourcesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesAuthoredInput
    connect?: UserWhereUniqueInput
  }

  export type ResourceAssetUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput> | ResourceAssetCreateWithoutResourceInput[] | ResourceAssetUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceAssetCreateOrConnectWithoutResourceInput | ResourceAssetCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceAssetCreateManyResourceInputEnvelope
    connect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
  }

  export type ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput> | ResourceDownloadLogCreateWithoutResourceInput[] | ResourceDownloadLogUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutResourceInput | ResourceDownloadLogCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceDownloadLogCreateManyResourceInputEnvelope
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
  }

  export type ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput> | ResourceTagAssignmentCreateWithoutResourceInput[] | ResourceTagAssignmentUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutResourceInput | ResourceTagAssignmentCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceTagAssignmentCreateManyResourceInputEnvelope
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type ResourceAssetUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput> | ResourceAssetCreateWithoutResourceInput[] | ResourceAssetUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceAssetCreateOrConnectWithoutResourceInput | ResourceAssetCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceAssetUpsertWithWhereUniqueWithoutResourceInput | ResourceAssetUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceAssetCreateManyResourceInputEnvelope
    set?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    disconnect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    delete?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    connect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    update?: ResourceAssetUpdateWithWhereUniqueWithoutResourceInput | ResourceAssetUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceAssetUpdateManyWithWhereWithoutResourceInput | ResourceAssetUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceAssetScalarWhereInput | ResourceAssetScalarWhereInput[]
  }

  export type ResourceDownloadLogUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput> | ResourceDownloadLogCreateWithoutResourceInput[] | ResourceDownloadLogUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutResourceInput | ResourceDownloadLogCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceDownloadLogUpsertWithWhereUniqueWithoutResourceInput | ResourceDownloadLogUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceDownloadLogCreateManyResourceInputEnvelope
    set?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    disconnect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    delete?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    update?: ResourceDownloadLogUpdateWithWhereUniqueWithoutResourceInput | ResourceDownloadLogUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceDownloadLogUpdateManyWithWhereWithoutResourceInput | ResourceDownloadLogUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
  }

  export type ResourceTagAssignmentUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput> | ResourceTagAssignmentCreateWithoutResourceInput[] | ResourceTagAssignmentUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutResourceInput | ResourceTagAssignmentCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceTagAssignmentUpsertWithWhereUniqueWithoutResourceInput | ResourceTagAssignmentUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceTagAssignmentCreateManyResourceInputEnvelope
    set?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    disconnect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    delete?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    update?: ResourceTagAssignmentUpdateWithWhereUniqueWithoutResourceInput | ResourceTagAssignmentUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceTagAssignmentUpdateManyWithWhereWithoutResourceInput | ResourceTagAssignmentUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
  }

  export type ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<ResourceCategoryCreateWithoutResourcesInput, ResourceCategoryUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ResourceCategoryCreateOrConnectWithoutResourcesInput
    upsert?: ResourceCategoryUpsertWithoutResourcesInput
    connect?: ResourceCategoryWhereUniqueInput
    update?: XOR<XOR<ResourceCategoryUpdateToOneWithWhereWithoutResourcesInput, ResourceCategoryUpdateWithoutResourcesInput>, ResourceCategoryUncheckedUpdateWithoutResourcesInput>
  }

  export type UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput = {
    create?: XOR<UserCreateWithoutResourcesAuthoredInput, UserUncheckedCreateWithoutResourcesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesAuthoredInput
    upsert?: UserUpsertWithoutResourcesAuthoredInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesAuthoredInput, UserUpdateWithoutResourcesAuthoredInput>, UserUncheckedUpdateWithoutResourcesAuthoredInput>
  }

  export type ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput> | ResourceAssetCreateWithoutResourceInput[] | ResourceAssetUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceAssetCreateOrConnectWithoutResourceInput | ResourceAssetCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceAssetUpsertWithWhereUniqueWithoutResourceInput | ResourceAssetUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceAssetCreateManyResourceInputEnvelope
    set?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    disconnect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    delete?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    connect?: ResourceAssetWhereUniqueInput | ResourceAssetWhereUniqueInput[]
    update?: ResourceAssetUpdateWithWhereUniqueWithoutResourceInput | ResourceAssetUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceAssetUpdateManyWithWhereWithoutResourceInput | ResourceAssetUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceAssetScalarWhereInput | ResourceAssetScalarWhereInput[]
  }

  export type ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput> | ResourceDownloadLogCreateWithoutResourceInput[] | ResourceDownloadLogUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceDownloadLogCreateOrConnectWithoutResourceInput | ResourceDownloadLogCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceDownloadLogUpsertWithWhereUniqueWithoutResourceInput | ResourceDownloadLogUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceDownloadLogCreateManyResourceInputEnvelope
    set?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    disconnect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    delete?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    connect?: ResourceDownloadLogWhereUniqueInput | ResourceDownloadLogWhereUniqueInput[]
    update?: ResourceDownloadLogUpdateWithWhereUniqueWithoutResourceInput | ResourceDownloadLogUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceDownloadLogUpdateManyWithWhereWithoutResourceInput | ResourceDownloadLogUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
  }

  export type ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput> | ResourceTagAssignmentCreateWithoutResourceInput[] | ResourceTagAssignmentUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceTagAssignmentCreateOrConnectWithoutResourceInput | ResourceTagAssignmentCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceTagAssignmentUpsertWithWhereUniqueWithoutResourceInput | ResourceTagAssignmentUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceTagAssignmentCreateManyResourceInputEnvelope
    set?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    disconnect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    delete?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    connect?: ResourceTagAssignmentWhereUniqueInput | ResourceTagAssignmentWhereUniqueInput[]
    update?: ResourceTagAssignmentUpdateWithWhereUniqueWithoutResourceInput | ResourceTagAssignmentUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceTagAssignmentUpdateManyWithWhereWithoutResourceInput | ResourceTagAssignmentUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
  }

  export type ResourceCreateNestedOneWithoutTagsInput = {
    create?: XOR<ResourceCreateWithoutTagsInput, ResourceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTagsInput
    connect?: ResourceWhereUniqueInput
  }

  export type ResourceTagCreateNestedOneWithoutTagAssignmentsInput = {
    create?: XOR<ResourceTagCreateWithoutTagAssignmentsInput, ResourceTagUncheckedCreateWithoutTagAssignmentsInput>
    connectOrCreate?: ResourceTagCreateOrConnectWithoutTagAssignmentsInput
    connect?: ResourceTagWhereUniqueInput
  }

  export type ResourceUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ResourceCreateWithoutTagsInput, ResourceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTagsInput
    upsert?: ResourceUpsertWithoutTagsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutTagsInput, ResourceUpdateWithoutTagsInput>, ResourceUncheckedUpdateWithoutTagsInput>
  }

  export type ResourceTagUpdateOneRequiredWithoutTagAssignmentsNestedInput = {
    create?: XOR<ResourceTagCreateWithoutTagAssignmentsInput, ResourceTagUncheckedCreateWithoutTagAssignmentsInput>
    connectOrCreate?: ResourceTagCreateOrConnectWithoutTagAssignmentsInput
    upsert?: ResourceTagUpsertWithoutTagAssignmentsInput
    connect?: ResourceTagWhereUniqueInput
    update?: XOR<XOR<ResourceTagUpdateToOneWithWhereWithoutTagAssignmentsInput, ResourceTagUpdateWithoutTagAssignmentsInput>, ResourceTagUncheckedUpdateWithoutTagAssignmentsInput>
  }

  export type ResourceCreateNestedOneWithoutAssetsInput = {
    create?: XOR<ResourceCreateWithoutAssetsInput, ResourceUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAssetsInput
    connect?: ResourceWhereUniqueInput
  }

  export type ResourceUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<ResourceCreateWithoutAssetsInput, ResourceUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAssetsInput
    upsert?: ResourceUpsertWithoutAssetsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutAssetsInput, ResourceUpdateWithoutAssetsInput>, ResourceUncheckedUpdateWithoutAssetsInput>
  }

  export type ResourceCreateNestedOneWithoutDownloadsInput = {
    create?: XOR<ResourceCreateWithoutDownloadsInput, ResourceUncheckedCreateWithoutDownloadsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutDownloadsInput
    connect?: ResourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResourceDownloadLogsInput = {
    create?: XOR<UserCreateWithoutResourceDownloadLogsInput, UserUncheckedCreateWithoutResourceDownloadLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourceDownloadLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ResourceUpdateOneRequiredWithoutDownloadsNestedInput = {
    create?: XOR<ResourceCreateWithoutDownloadsInput, ResourceUncheckedCreateWithoutDownloadsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutDownloadsInput
    upsert?: ResourceUpsertWithoutDownloadsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutDownloadsInput, ResourceUpdateWithoutDownloadsInput>, ResourceUncheckedUpdateWithoutDownloadsInput>
  }

  export type UserUpdateOneRequiredWithoutResourceDownloadLogsNestedInput = {
    create?: XOR<UserCreateWithoutResourceDownloadLogsInput, UserUncheckedCreateWithoutResourceDownloadLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourceDownloadLogsInput
    upsert?: UserUpsertWithoutResourceDownloadLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourceDownloadLogsInput, UserUpdateWithoutResourceDownloadLogsInput>, UserUncheckedUpdateWithoutResourceDownloadLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumFeatureAccessKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureAccessKey | EnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureAccessKeyFilter<$PrismaModel> | $Enums.FeatureAccessKey
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumFeatureAccessKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureAccessKey | EnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureAccessKey[] | ListEnumFeatureAccessKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureAccessKeyWithAggregatesFilter<$PrismaModel> | $Enums.FeatureAccessKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureAccessKeyFilter<$PrismaModel>
    _max?: NestedEnumFeatureAccessKeyFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumBannerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerStatus | EnumBannerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBannerStatusFilter<$PrismaModel> | $Enums.BannerStatus
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBannerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerStatus | EnumBannerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BannerStatus[] | ListEnumBannerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBannerStatusWithAggregatesFilter<$PrismaModel> | $Enums.BannerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBannerStatusFilter<$PrismaModel>
    _max?: NestedEnumBannerStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeatureToggleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureToggleStatus | EnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureToggleStatusFilter<$PrismaModel> | $Enums.FeatureToggleStatus
  }

  export type NestedEnumFeatureToggleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureToggleStatus | EnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureToggleStatus[] | ListEnumFeatureToggleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureToggleStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeatureToggleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureToggleStatusFilter<$PrismaModel>
    _max?: NestedEnumFeatureToggleStatusFilter<$PrismaModel>
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type NestedEnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type NestedEnumLessonCommentModerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonCommentModerationStatus | EnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel> | $Enums.LessonCommentModerationStatus
  }

  export type NestedEnumLessonCommentModerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonCommentModerationStatus | EnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonCommentModerationStatus[] | ListEnumLessonCommentModerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonCommentModerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonCommentModerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonCommentModerationStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecommendationBadgeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationBadge | EnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel> | $Enums.RecommendationBadge | null
  }

  export type NestedEnumRecommendationBadgeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationBadge | EnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecommendationBadge[] | ListEnumRecommendationBadgeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecommendationBadgeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationBadge | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecommendationBadgeNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedEnumEvolutionConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EvolutionConnectionStatus | EnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel> | $Enums.EvolutionConnectionStatus
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumEvolutionConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvolutionConnectionStatus | EnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvolutionConnectionStatus[] | ListEnumEvolutionConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvolutionConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.EvolutionConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumEvolutionConnectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumContactImportSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactImportSource | EnumContactImportSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumContactImportSourceFilter<$PrismaModel> | $Enums.ContactImportSource
  }

  export type NestedEnumContactImportSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactImportSource | EnumContactImportSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactImportSource[] | ListEnumContactImportSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumContactImportSourceWithAggregatesFilter<$PrismaModel> | $Enums.ContactImportSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactImportSourceFilter<$PrismaModel>
    _max?: NestedEnumContactImportSourceFilter<$PrismaModel>
  }

  export type NestedEnumCampaignChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignChannel | EnumCampaignChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignChannelFilter<$PrismaModel> | $Enums.CampaignChannel
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignChannel | EnumCampaignChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignChannel[] | ListEnumCampaignChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignChannelWithAggregatesFilter<$PrismaModel> | $Enums.CampaignChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignChannelFilter<$PrismaModel>
    _max?: NestedEnumCampaignChannelFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type CourseProgressCreateWithoutUserInput = {
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutProgressesInput
  }

  export type CourseProgressUncheckedCreateWithoutUserInput = {
    courseId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseProgressCreateOrConnectWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    create: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput>
  }

  export type CourseProgressCreateManyUserInputEnvelope = {
    data: CourseProgressCreateManyUserInput | CourseProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressUncheckedCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput>
  }

  export type CourseCreateManyAuthorInputEnvelope = {
    data: CourseCreateManyAuthorInput | CourseCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentReplyCreateWithoutModeratedByInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    comment: LessonCommentCreateNestedOneWithoutRepliesInput
    parentReply?: LessonCommentReplyCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentReplyCreateNestedManyWithoutParentReplyInput
    user: UserCreateNestedOneWithoutLessonCommentRepliesInput
  }

  export type LessonCommentReplyUncheckedCreateWithoutModeratedByInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyCreateOrConnectWithoutModeratedByInput = {
    where: LessonCommentReplyWhereUniqueInput
    create: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput>
  }

  export type LessonCommentReplyCreateManyModeratedByInputEnvelope = {
    data: LessonCommentReplyCreateManyModeratedByInput | LessonCommentReplyCreateManyModeratedByInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentReplyCreateWithoutUserInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    comment: LessonCommentCreateNestedOneWithoutRepliesInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput
    parentReply?: LessonCommentReplyCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentReplyCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyUncheckedCreateWithoutUserInput = {
    id?: string
    commentId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyCreateOrConnectWithoutUserInput = {
    where: LessonCommentReplyWhereUniqueInput
    create: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentReplyCreateManyUserInputEnvelope = {
    data: LessonCommentReplyCreateManyUserInput | LessonCommentReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentCreateWithoutModeratedByInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyCreateNestedManyWithoutCommentInput
    lesson: LessonCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
  }

  export type LessonCommentUncheckedCreateWithoutModeratedByInput = {
    id?: string
    lessonId: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type LessonCommentCreateOrConnectWithoutModeratedByInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput>
  }

  export type LessonCommentCreateManyModeratedByInputEnvelope = {
    data: LessonCommentCreateManyModeratedByInput | LessonCommentCreateManyModeratedByInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentCreateWithoutUserInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyCreateNestedManyWithoutCommentInput
    lesson: LessonCreateNestedOneWithoutCommentsInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentsInput
  }

  export type LessonCommentUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type LessonCommentCreateOrConnectWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentCreateManyUserInputEnvelope = {
    data: LessonCommentCreateManyUserInput | LessonCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressAggregateCreateWithoutUserInput = {
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutProgressAggregatesInput
  }

  export type LessonProgressAggregateUncheckedCreateWithoutUserInput = {
    lessonId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressAggregateCreateOrConnectWithoutUserInput = {
    where: LessonProgressAggregateWhereUniqueInput
    create: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressAggregateCreateManyUserInputEnvelope = {
    data: LessonProgressAggregateCreateManyUserInput | LessonProgressAggregateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressEventCreateWithoutUserInput = {
    id?: string
    occurredAt: Date | string
    positionSec: number
    lesson: LessonCreateNestedOneWithoutProgressEventsInput
  }

  export type LessonProgressEventUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonProgressEventCreateOrConnectWithoutUserInput = {
    where: LessonProgressEventWhereUniqueInput
    create: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressEventCreateManyUserInputEnvelope = {
    data: LessonProgressEventCreateManyUserInput | LessonProgressEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonRatingCreateWithoutUserInput = {
    id?: string
    value: number
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutRatingsInput
  }

  export type LessonRatingUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    value: number
    createdAt?: Date | string
  }

  export type LessonRatingCreateOrConnectWithoutUserInput = {
    where: LessonRatingWhereUniqueInput
    create: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput>
  }

  export type LessonRatingCreateManyUserInputEnvelope = {
    data: LessonRatingCreateManyUserInput | LessonRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeatureToggleCreateWithoutCreatedByInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureToggleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureToggleCreateOrConnectWithoutCreatedByInput = {
    where: FeatureToggleWhereUniqueInput
    create: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput>
  }

  export type FeatureToggleCreateManyCreatedByInputEnvelope = {
    data: FeatureToggleCreateManyCreatedByInput | FeatureToggleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type HeroBannerCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerCreateOrConnectWithoutCreatedByInput = {
    where: HeroBannerWhereUniqueInput
    create: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput>
  }

  export type HeroBannerCreateManyCreatedByInputEnvelope = {
    data: HeroBannerCreateManyCreatedByInput | HeroBannerCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutAcceptedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    invitedBy: UserCreateNestedOneWithoutInvitationsSentInput
  }

  export type InvitationUncheckedCreateWithoutAcceptedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    invitedById: string
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutAcceptedByInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput>
  }

  export type InvitationCreateManyAcceptedByInputEnvelope = {
    data: InvitationCreateManyAcceptedByInput | InvitationCreateManyAcceptedByInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutInvitedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    acceptedBy?: UserCreateNestedOneWithoutInvitationsAcceptedInput
  }

  export type InvitationUncheckedCreateWithoutInvitedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedById?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
  }

  export type InvitationCreateManyInvitedByInputEnvelope = {
    data: InvitationCreateManyInvitedByInput | InvitationCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type MemberAccessOverrideCreateWithoutGrantedByInput = {
    id?: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedAt?: Date | string
    user: UserCreateNestedOneWithoutAccessOverridesInput
  }

  export type MemberAccessOverrideUncheckedCreateWithoutGrantedByInput = {
    id?: string
    userId: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedAt?: Date | string
  }

  export type MemberAccessOverrideCreateOrConnectWithoutGrantedByInput = {
    where: MemberAccessOverrideWhereUniqueInput
    create: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput>
  }

  export type MemberAccessOverrideCreateManyGrantedByInputEnvelope = {
    data: MemberAccessOverrideCreateManyGrantedByInput | MemberAccessOverrideCreateManyGrantedByInput[]
    skipDuplicates?: boolean
  }

  export type MemberAccessOverrideCreateWithoutUserInput = {
    id?: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedAt?: Date | string
    grantedBy: UserCreateNestedOneWithoutOverridesGrantedInput
  }

  export type MemberAccessOverrideUncheckedCreateWithoutUserInput = {
    id?: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedById: string
    grantedAt?: Date | string
  }

  export type MemberAccessOverrideCreateOrConnectWithoutUserInput = {
    where: MemberAccessOverrideWhereUniqueInput
    create: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput>
  }

  export type MemberAccessOverrideCreateManyUserInputEnvelope = {
    data: MemberAccessOverrideCreateManyUserInput | MemberAccessOverrideCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberAccessCreateWithoutGrantedByInput = {
    id?: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberAccessesInput
  }

  export type MemberAccessUncheckedCreateWithoutGrantedByInput = {
    id?: string
    userId: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAccessCreateOrConnectWithoutGrantedByInput = {
    where: MemberAccessWhereUniqueInput
    create: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput>
  }

  export type MemberAccessCreateManyGrantedByInputEnvelope = {
    data: MemberAccessCreateManyGrantedByInput | MemberAccessCreateManyGrantedByInput[]
    skipDuplicates?: boolean
  }

  export type MemberAccessCreateWithoutUserInput = {
    id?: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grantedBy?: UserCreateNestedOneWithoutMemberAccessGrantsInput
  }

  export type MemberAccessUncheckedCreateWithoutUserInput = {
    id?: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedById?: string | null
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAccessCreateOrConnectWithoutUserInput = {
    where: MemberAccessWhereUniqueInput
    create: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput>
  }

  export type MemberAccessCreateManyUserInputEnvelope = {
    data: MemberAccessCreateManyUserInput | MemberAccessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceDownloadLogCreateWithoutUserInput = {
    id?: string
    downloadedAt?: Date | string
    ipAddress: string
    resource: ResourceCreateNestedOneWithoutDownloadsInput
  }

  export type ResourceDownloadLogUncheckedCreateWithoutUserInput = {
    id?: string
    resourceId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceDownloadLogCreateOrConnectWithoutUserInput = {
    where: ResourceDownloadLogWhereUniqueInput
    create: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput>
  }

  export type ResourceDownloadLogCreateManyUserInputEnvelope = {
    data: ResourceDownloadLogCreateManyUserInput | ResourceDownloadLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentCreateNestedManyWithoutResourceInput
    category: ResourceCategoryCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetUncheckedCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ResourceCreateManyAuthorInputEnvelope = {
    data: ResourceCreateManyAuthorInput | ResourceCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CampaignRunCreateWithoutInitiatorInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
    campaign: CampaignCreateNestedOneWithoutRunsInput
  }

  export type CampaignRunUncheckedCreateWithoutInitiatorInput = {
    id?: string
    campaignId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignRunCreateOrConnectWithoutInitiatorInput = {
    where: CampaignRunWhereUniqueInput
    create: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput>
  }

  export type CampaignRunCreateManyInitiatorInputEnvelope = {
    data: CampaignRunCreateManyInitiatorInput | CampaignRunCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactSegmentCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutSegmentInput
  }

  export type ContactSegmentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type ContactSegmentCreateOrConnectWithoutUserInput = {
    where: ContactSegmentWhereUniqueInput
    create: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput>
  }

  export type ContactSegmentCreateManyUserInputEnvelope = {
    data: ContactSegmentCreateManyUserInput | ContactSegmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EvolutionApiConfigCreateWithoutUserInput = {
    id?: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutEvolutionConfigInput
  }

  export type EvolutionApiConfigUncheckedCreateWithoutUserInput = {
    id?: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutEvolutionConfigInput
  }

  export type EvolutionApiConfigCreateOrConnectWithoutUserInput = {
    where: EvolutionApiConfigWhereUniqueInput
    create: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
  }

  export type MessageTemplateCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type MessageTemplateCreateOrConnectWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput>
  }

  export type MessageTemplateCreateManyUserInputEnvelope = {
    data: MessageTemplateCreateManyUserInput | MessageTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    update: XOR<CourseProgressUpdateWithoutUserInput, CourseProgressUncheckedUpdateWithoutUserInput>
    create: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput>
  }

  export type CourseProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    data: XOR<CourseProgressUpdateWithoutUserInput, CourseProgressUncheckedUpdateWithoutUserInput>
  }

  export type CourseProgressUpdateManyWithWhereWithoutUserInput = {
    where: CourseProgressScalarWhereInput
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseProgressScalarWhereInput = {
    AND?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
    OR?: CourseProgressScalarWhereInput[]
    NOT?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
    courseId?: StringFilter<"CourseProgress"> | string
    userId?: StringFilter<"CourseProgress"> | string
    completedLessonIds?: StringNullableListFilter<"CourseProgress">
    percentage?: FloatFilter<"CourseProgress"> | number
    lastLessonId?: StringNullableFilter<"CourseProgress"> | string | null
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutAuthorInput, CourseUncheckedUpdateWithoutAuthorInput>
    create: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutAuthorInput, CourseUncheckedUpdateWithoutAuthorInput>
  }

  export type CourseUpdateManyWithWhereWithoutAuthorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    subtitle?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    coverImage?: StringNullableFilter<"Course"> | string | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    visibility?: EnumVisibilityFilter<"Course"> | $Enums.Visibility
    estimatedDurationMinutes?: IntFilter<"Course"> | number
    totalLessons?: IntFilter<"Course"> | number
    tags?: StringNullableListFilter<"Course">
    releaseDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    isFeatured?: BoolFilter<"Course"> | boolean
    recommendationScore?: FloatFilter<"Course"> | number
  }

  export type LessonCommentReplyUpsertWithWhereUniqueWithoutModeratedByInput = {
    where: LessonCommentReplyWhereUniqueInput
    update: XOR<LessonCommentReplyUpdateWithoutModeratedByInput, LessonCommentReplyUncheckedUpdateWithoutModeratedByInput>
    create: XOR<LessonCommentReplyCreateWithoutModeratedByInput, LessonCommentReplyUncheckedCreateWithoutModeratedByInput>
  }

  export type LessonCommentReplyUpdateWithWhereUniqueWithoutModeratedByInput = {
    where: LessonCommentReplyWhereUniqueInput
    data: XOR<LessonCommentReplyUpdateWithoutModeratedByInput, LessonCommentReplyUncheckedUpdateWithoutModeratedByInput>
  }

  export type LessonCommentReplyUpdateManyWithWhereWithoutModeratedByInput = {
    where: LessonCommentReplyScalarWhereInput
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyWithoutModeratedByInput>
  }

  export type LessonCommentReplyScalarWhereInput = {
    AND?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
    OR?: LessonCommentReplyScalarWhereInput[]
    NOT?: LessonCommentReplyScalarWhereInput | LessonCommentReplyScalarWhereInput[]
    id?: StringFilter<"LessonCommentReply"> | string
    commentId?: StringFilter<"LessonCommentReply"> | string
    userId?: StringFilter<"LessonCommentReply"> | string
    body?: StringFilter<"LessonCommentReply"> | string
    createdAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
    moderatedAt?: DateTimeNullableFilter<"LessonCommentReply"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonCommentReply"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonCommentReply"> | $Enums.LessonCommentModerationStatus
    parentReplyId?: StringNullableFilter<"LessonCommentReply"> | string | null
    pendingModeration?: BoolFilter<"LessonCommentReply"> | boolean
    updatedAt?: DateTimeFilter<"LessonCommentReply"> | Date | string
  }

  export type LessonCommentReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonCommentReplyWhereUniqueInput
    update: XOR<LessonCommentReplyUpdateWithoutUserInput, LessonCommentReplyUncheckedUpdateWithoutUserInput>
    create: XOR<LessonCommentReplyCreateWithoutUserInput, LessonCommentReplyUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonCommentReplyWhereUniqueInput
    data: XOR<LessonCommentReplyUpdateWithoutUserInput, LessonCommentReplyUncheckedUpdateWithoutUserInput>
  }

  export type LessonCommentReplyUpdateManyWithWhereWithoutUserInput = {
    where: LessonCommentReplyScalarWhereInput
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutModeratedByInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutModeratedByInput, LessonCommentUncheckedUpdateWithoutModeratedByInput>
    create: XOR<LessonCommentCreateWithoutModeratedByInput, LessonCommentUncheckedCreateWithoutModeratedByInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutModeratedByInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutModeratedByInput, LessonCommentUncheckedUpdateWithoutModeratedByInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutModeratedByInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutModeratedByInput>
  }

  export type LessonCommentScalarWhereInput = {
    AND?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
    OR?: LessonCommentScalarWhereInput[]
    NOT?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
    id?: StringFilter<"LessonComment"> | string
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    body?: StringFilter<"LessonComment"> | string
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
    pendingModeration?: BoolFilter<"LessonComment"> | boolean
    moderatedAt?: DateTimeNullableFilter<"LessonComment"> | Date | string | null
    moderatedById?: StringNullableFilter<"LessonComment"> | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFilter<"LessonComment"> | $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutUserInput, LessonCommentUncheckedUpdateWithoutUserInput>
    create: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutUserInput, LessonCommentUncheckedUpdateWithoutUserInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutUserInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressAggregateUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonProgressAggregateWhereUniqueInput
    update: XOR<LessonProgressAggregateUpdateWithoutUserInput, LessonProgressAggregateUncheckedUpdateWithoutUserInput>
    create: XOR<LessonProgressAggregateCreateWithoutUserInput, LessonProgressAggregateUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressAggregateUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonProgressAggregateWhereUniqueInput
    data: XOR<LessonProgressAggregateUpdateWithoutUserInput, LessonProgressAggregateUncheckedUpdateWithoutUserInput>
  }

  export type LessonProgressAggregateUpdateManyWithWhereWithoutUserInput = {
    where: LessonProgressAggregateScalarWhereInput
    data: XOR<LessonProgressAggregateUpdateManyMutationInput, LessonProgressAggregateUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressAggregateScalarWhereInput = {
    AND?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
    OR?: LessonProgressAggregateScalarWhereInput[]
    NOT?: LessonProgressAggregateScalarWhereInput | LessonProgressAggregateScalarWhereInput[]
    lessonId?: StringFilter<"LessonProgressAggregate"> | string
    userId?: StringFilter<"LessonProgressAggregate"> | string
    lastPositionSec?: IntFilter<"LessonProgressAggregate"> | number
    percentage?: FloatFilter<"LessonProgressAggregate"> | number
    updatedAt?: DateTimeFilter<"LessonProgressAggregate"> | Date | string
  }

  export type LessonProgressEventUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonProgressEventWhereUniqueInput
    update: XOR<LessonProgressEventUpdateWithoutUserInput, LessonProgressEventUncheckedUpdateWithoutUserInput>
    create: XOR<LessonProgressEventCreateWithoutUserInput, LessonProgressEventUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressEventUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonProgressEventWhereUniqueInput
    data: XOR<LessonProgressEventUpdateWithoutUserInput, LessonProgressEventUncheckedUpdateWithoutUserInput>
  }

  export type LessonProgressEventUpdateManyWithWhereWithoutUserInput = {
    where: LessonProgressEventScalarWhereInput
    data: XOR<LessonProgressEventUpdateManyMutationInput, LessonProgressEventUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressEventScalarWhereInput = {
    AND?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
    OR?: LessonProgressEventScalarWhereInput[]
    NOT?: LessonProgressEventScalarWhereInput | LessonProgressEventScalarWhereInput[]
    id?: StringFilter<"LessonProgressEvent"> | string
    lessonId?: StringFilter<"LessonProgressEvent"> | string
    userId?: StringFilter<"LessonProgressEvent"> | string
    occurredAt?: DateTimeFilter<"LessonProgressEvent"> | Date | string
    positionSec?: IntFilter<"LessonProgressEvent"> | number
  }

  export type LessonRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonRatingWhereUniqueInput
    update: XOR<LessonRatingUpdateWithoutUserInput, LessonRatingUncheckedUpdateWithoutUserInput>
    create: XOR<LessonRatingCreateWithoutUserInput, LessonRatingUncheckedCreateWithoutUserInput>
  }

  export type LessonRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonRatingWhereUniqueInput
    data: XOR<LessonRatingUpdateWithoutUserInput, LessonRatingUncheckedUpdateWithoutUserInput>
  }

  export type LessonRatingUpdateManyWithWhereWithoutUserInput = {
    where: LessonRatingScalarWhereInput
    data: XOR<LessonRatingUpdateManyMutationInput, LessonRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonRatingScalarWhereInput = {
    AND?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
    OR?: LessonRatingScalarWhereInput[]
    NOT?: LessonRatingScalarWhereInput | LessonRatingScalarWhereInput[]
    id?: StringFilter<"LessonRating"> | string
    lessonId?: StringFilter<"LessonRating"> | string
    userId?: StringFilter<"LessonRating"> | string
    value?: IntFilter<"LessonRating"> | number
    createdAt?: DateTimeFilter<"LessonRating"> | Date | string
  }

  export type FeatureToggleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: FeatureToggleWhereUniqueInput
    update: XOR<FeatureToggleUpdateWithoutCreatedByInput, FeatureToggleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<FeatureToggleCreateWithoutCreatedByInput, FeatureToggleUncheckedCreateWithoutCreatedByInput>
  }

  export type FeatureToggleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: FeatureToggleWhereUniqueInput
    data: XOR<FeatureToggleUpdateWithoutCreatedByInput, FeatureToggleUncheckedUpdateWithoutCreatedByInput>
  }

  export type FeatureToggleUpdateManyWithWhereWithoutCreatedByInput = {
    where: FeatureToggleScalarWhereInput
    data: XOR<FeatureToggleUpdateManyMutationInput, FeatureToggleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type FeatureToggleScalarWhereInput = {
    AND?: FeatureToggleScalarWhereInput | FeatureToggleScalarWhereInput[]
    OR?: FeatureToggleScalarWhereInput[]
    NOT?: FeatureToggleScalarWhereInput | FeatureToggleScalarWhereInput[]
    id?: StringFilter<"FeatureToggle"> | string
    featureKey?: StringFilter<"FeatureToggle"> | string
    description?: StringFilter<"FeatureToggle"> | string
    status?: EnumFeatureToggleStatusFilter<"FeatureToggle"> | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFilter<"FeatureToggle"> | number
    createdById?: StringFilter<"FeatureToggle"> | string
    createdAt?: DateTimeFilter<"FeatureToggle"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureToggle"> | Date | string
  }

  export type HeroBannerUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: HeroBannerWhereUniqueInput
    update: XOR<HeroBannerUpdateWithoutCreatedByInput, HeroBannerUncheckedUpdateWithoutCreatedByInput>
    create: XOR<HeroBannerCreateWithoutCreatedByInput, HeroBannerUncheckedCreateWithoutCreatedByInput>
  }

  export type HeroBannerUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: HeroBannerWhereUniqueInput
    data: XOR<HeroBannerUpdateWithoutCreatedByInput, HeroBannerUncheckedUpdateWithoutCreatedByInput>
  }

  export type HeroBannerUpdateManyWithWhereWithoutCreatedByInput = {
    where: HeroBannerScalarWhereInput
    data: XOR<HeroBannerUpdateManyMutationInput, HeroBannerUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type HeroBannerScalarWhereInput = {
    AND?: HeroBannerScalarWhereInput | HeroBannerScalarWhereInput[]
    OR?: HeroBannerScalarWhereInput[]
    NOT?: HeroBannerScalarWhereInput | HeroBannerScalarWhereInput[]
    id?: StringFilter<"HeroBanner"> | string
    title?: StringFilter<"HeroBanner"> | string
    description?: StringFilter<"HeroBanner"> | string
    primaryCtaLabel?: StringFilter<"HeroBanner"> | string
    primaryCtaHref?: StringFilter<"HeroBanner"> | string
    primaryCtaExternal?: BoolFilter<"HeroBanner"> | boolean
    secondaryCtaLabel?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaHref?: StringNullableFilter<"HeroBanner"> | string | null
    secondaryCtaExternal?: BoolNullableFilter<"HeroBanner"> | boolean | null
    imageUrl?: StringFilter<"HeroBanner"> | string
    order?: IntFilter<"HeroBanner"> | number
    status?: EnumBannerStatusFilter<"HeroBanner"> | $Enums.BannerStatus
    startsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"HeroBanner"> | Date | string | null
    createdById?: StringFilter<"HeroBanner"> | string
    createdAt?: DateTimeFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBanner"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutAcceptedByInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutAcceptedByInput, InvitationUncheckedUpdateWithoutAcceptedByInput>
    create: XOR<InvitationCreateWithoutAcceptedByInput, InvitationUncheckedCreateWithoutAcceptedByInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutAcceptedByInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutAcceptedByInput, InvitationUncheckedUpdateWithoutAcceptedByInput>
  }

  export type InvitationUpdateManyWithWhereWithoutAcceptedByInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutAcceptedByInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: EnumUserRoleFilter<"Invitation"> | $Enums.UserRole
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    invitedById?: StringFilter<"Invitation"> | string
    grantedAccess?: EnumFeatureAccessKeyNullableListFilter<"Invitation">
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedById?: StringNullableFilter<"Invitation"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutInvitedByInput, InvitationUncheckedUpdateWithoutInvitedByInput>
    create: XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutInvitedByInput, InvitationUncheckedUpdateWithoutInvitedByInput>
  }

  export type InvitationUpdateManyWithWhereWithoutInvitedByInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type MemberAccessOverrideUpsertWithWhereUniqueWithoutGrantedByInput = {
    where: MemberAccessOverrideWhereUniqueInput
    update: XOR<MemberAccessOverrideUpdateWithoutGrantedByInput, MemberAccessOverrideUncheckedUpdateWithoutGrantedByInput>
    create: XOR<MemberAccessOverrideCreateWithoutGrantedByInput, MemberAccessOverrideUncheckedCreateWithoutGrantedByInput>
  }

  export type MemberAccessOverrideUpdateWithWhereUniqueWithoutGrantedByInput = {
    where: MemberAccessOverrideWhereUniqueInput
    data: XOR<MemberAccessOverrideUpdateWithoutGrantedByInput, MemberAccessOverrideUncheckedUpdateWithoutGrantedByInput>
  }

  export type MemberAccessOverrideUpdateManyWithWhereWithoutGrantedByInput = {
    where: MemberAccessOverrideScalarWhereInput
    data: XOR<MemberAccessOverrideUpdateManyMutationInput, MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByInput>
  }

  export type MemberAccessOverrideScalarWhereInput = {
    AND?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
    OR?: MemberAccessOverrideScalarWhereInput[]
    NOT?: MemberAccessOverrideScalarWhereInput | MemberAccessOverrideScalarWhereInput[]
    id?: StringFilter<"MemberAccessOverride"> | string
    userId?: StringFilter<"MemberAccessOverride"> | string
    feature?: StringFilter<"MemberAccessOverride"> | string
    enabled?: BoolFilter<"MemberAccessOverride"> | boolean
    permissions?: StringNullableListFilter<"MemberAccessOverride">
    reason?: StringFilter<"MemberAccessOverride"> | string
    grantedById?: StringFilter<"MemberAccessOverride"> | string
    grantedAt?: DateTimeFilter<"MemberAccessOverride"> | Date | string
  }

  export type MemberAccessOverrideUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberAccessOverrideWhereUniqueInput
    update: XOR<MemberAccessOverrideUpdateWithoutUserInput, MemberAccessOverrideUncheckedUpdateWithoutUserInput>
    create: XOR<MemberAccessOverrideCreateWithoutUserInput, MemberAccessOverrideUncheckedCreateWithoutUserInput>
  }

  export type MemberAccessOverrideUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberAccessOverrideWhereUniqueInput
    data: XOR<MemberAccessOverrideUpdateWithoutUserInput, MemberAccessOverrideUncheckedUpdateWithoutUserInput>
  }

  export type MemberAccessOverrideUpdateManyWithWhereWithoutUserInput = {
    where: MemberAccessOverrideScalarWhereInput
    data: XOR<MemberAccessOverrideUpdateManyMutationInput, MemberAccessOverrideUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberAccessUpsertWithWhereUniqueWithoutGrantedByInput = {
    where: MemberAccessWhereUniqueInput
    update: XOR<MemberAccessUpdateWithoutGrantedByInput, MemberAccessUncheckedUpdateWithoutGrantedByInput>
    create: XOR<MemberAccessCreateWithoutGrantedByInput, MemberAccessUncheckedCreateWithoutGrantedByInput>
  }

  export type MemberAccessUpdateWithWhereUniqueWithoutGrantedByInput = {
    where: MemberAccessWhereUniqueInput
    data: XOR<MemberAccessUpdateWithoutGrantedByInput, MemberAccessUncheckedUpdateWithoutGrantedByInput>
  }

  export type MemberAccessUpdateManyWithWhereWithoutGrantedByInput = {
    where: MemberAccessScalarWhereInput
    data: XOR<MemberAccessUpdateManyMutationInput, MemberAccessUncheckedUpdateManyWithoutGrantedByInput>
  }

  export type MemberAccessScalarWhereInput = {
    AND?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
    OR?: MemberAccessScalarWhereInput[]
    NOT?: MemberAccessScalarWhereInput | MemberAccessScalarWhereInput[]
    id?: StringFilter<"MemberAccess"> | string
    userId?: StringFilter<"MemberAccess"> | string
    feature?: EnumFeatureAccessKeyFilter<"MemberAccess"> | $Enums.FeatureAccessKey
    enabled?: BoolFilter<"MemberAccess"> | boolean
    permissions?: StringNullableListFilter<"MemberAccess">
    grantedById?: StringNullableFilter<"MemberAccess"> | string | null
    grantedAt?: DateTimeNullableFilter<"MemberAccess"> | Date | string | null
    createdAt?: DateTimeFilter<"MemberAccess"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAccess"> | Date | string
  }

  export type MemberAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberAccessWhereUniqueInput
    update: XOR<MemberAccessUpdateWithoutUserInput, MemberAccessUncheckedUpdateWithoutUserInput>
    create: XOR<MemberAccessCreateWithoutUserInput, MemberAccessUncheckedCreateWithoutUserInput>
  }

  export type MemberAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberAccessWhereUniqueInput
    data: XOR<MemberAccessUpdateWithoutUserInput, MemberAccessUncheckedUpdateWithoutUserInput>
  }

  export type MemberAccessUpdateManyWithWhereWithoutUserInput = {
    where: MemberAccessScalarWhereInput
    data: XOR<MemberAccessUpdateManyMutationInput, MemberAccessUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshTokenHash?: StringFilter<"Session"> | string
    device?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    ipAddress?: StringFilter<"Session"> | string
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ResourceDownloadLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ResourceDownloadLogWhereUniqueInput
    update: XOR<ResourceDownloadLogUpdateWithoutUserInput, ResourceDownloadLogUncheckedUpdateWithoutUserInput>
    create: XOR<ResourceDownloadLogCreateWithoutUserInput, ResourceDownloadLogUncheckedCreateWithoutUserInput>
  }

  export type ResourceDownloadLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ResourceDownloadLogWhereUniqueInput
    data: XOR<ResourceDownloadLogUpdateWithoutUserInput, ResourceDownloadLogUncheckedUpdateWithoutUserInput>
  }

  export type ResourceDownloadLogUpdateManyWithWhereWithoutUserInput = {
    where: ResourceDownloadLogScalarWhereInput
    data: XOR<ResourceDownloadLogUpdateManyMutationInput, ResourceDownloadLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ResourceDownloadLogScalarWhereInput = {
    AND?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
    OR?: ResourceDownloadLogScalarWhereInput[]
    NOT?: ResourceDownloadLogScalarWhereInput | ResourceDownloadLogScalarWhereInput[]
    id?: StringFilter<"ResourceDownloadLog"> | string
    resourceId?: StringFilter<"ResourceDownloadLog"> | string
    userId?: StringFilter<"ResourceDownloadLog"> | string
    downloadedAt?: DateTimeFilter<"ResourceDownloadLog"> | Date | string
    ipAddress?: StringFilter<"ResourceDownloadLog"> | string
  }

  export type ResourceUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutAuthorInput, ResourceUncheckedUpdateWithoutAuthorInput>
    create: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutAuthorInput, ResourceUncheckedUpdateWithoutAuthorInput>
  }

  export type ResourceUpdateManyWithWhereWithoutAuthorInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    slug?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    categoryId?: StringFilter<"Resource"> | string
    thumbnailUrl?: StringNullableFilter<"Resource"> | string | null
    visibility?: EnumVisibilityFilter<"Resource"> | $Enums.Visibility
    featured?: BoolFilter<"Resource"> | boolean
    downloadCount?: IntFilter<"Resource"> | number
    viewCount?: IntFilter<"Resource"> | number
    createdById?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type CampaignRunUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: CampaignRunWhereUniqueInput
    update: XOR<CampaignRunUpdateWithoutInitiatorInput, CampaignRunUncheckedUpdateWithoutInitiatorInput>
    create: XOR<CampaignRunCreateWithoutInitiatorInput, CampaignRunUncheckedCreateWithoutInitiatorInput>
  }

  export type CampaignRunUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: CampaignRunWhereUniqueInput
    data: XOR<CampaignRunUpdateWithoutInitiatorInput, CampaignRunUncheckedUpdateWithoutInitiatorInput>
  }

  export type CampaignRunUpdateManyWithWhereWithoutInitiatorInput = {
    where: CampaignRunScalarWhereInput
    data: XOR<CampaignRunUpdateManyMutationInput, CampaignRunUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type CampaignRunScalarWhereInput = {
    AND?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
    OR?: CampaignRunScalarWhereInput[]
    NOT?: CampaignRunScalarWhereInput | CampaignRunScalarWhereInput[]
    id?: StringFilter<"CampaignRun"> | string
    campaignId?: StringFilter<"CampaignRun"> | string
    initiatedBy?: StringFilter<"CampaignRun"> | string
    startedAt?: DateTimeFilter<"CampaignRun"> | Date | string
    endedAt?: DateTimeNullableFilter<"CampaignRun"> | Date | string | null
    status?: EnumCampaignStatusFilter<"CampaignRun"> | $Enums.CampaignStatus
    summary?: StringNullableFilter<"CampaignRun"> | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    evolutionConfigId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    channel?: EnumCampaignChannelFilter<"Campaign"> | $Enums.CampaignChannel
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    segmentId?: StringFilter<"Campaign"> | string
    templateId?: StringFilter<"Campaign"> | string
    externalId?: StringNullableFilter<"Campaign"> | string | null
    maxMessagesPerMinute?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type ContactSegmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactSegmentWhereUniqueInput
    update: XOR<ContactSegmentUpdateWithoutUserInput, ContactSegmentUncheckedUpdateWithoutUserInput>
    create: XOR<ContactSegmentCreateWithoutUserInput, ContactSegmentUncheckedCreateWithoutUserInput>
  }

  export type ContactSegmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactSegmentWhereUniqueInput
    data: XOR<ContactSegmentUpdateWithoutUserInput, ContactSegmentUncheckedUpdateWithoutUserInput>
  }

  export type ContactSegmentUpdateManyWithWhereWithoutUserInput = {
    where: ContactSegmentScalarWhereInput
    data: XOR<ContactSegmentUpdateManyMutationInput, ContactSegmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactSegmentScalarWhereInput = {
    AND?: ContactSegmentScalarWhereInput | ContactSegmentScalarWhereInput[]
    OR?: ContactSegmentScalarWhereInput[]
    NOT?: ContactSegmentScalarWhereInput | ContactSegmentScalarWhereInput[]
    id?: StringFilter<"ContactSegment"> | string
    userId?: StringFilter<"ContactSegment"> | string
    name?: StringFilter<"ContactSegment"> | string
    description?: StringFilter<"ContactSegment"> | string
    importSource?: EnumContactImportSourceFilter<"ContactSegment"> | $Enums.ContactImportSource
    totalContacts?: IntFilter<"ContactSegment"> | number
    createdAt?: DateTimeFilter<"ContactSegment"> | Date | string
  }

  export type EvolutionApiConfigUpsertWithoutUserInput = {
    update: XOR<EvolutionApiConfigUpdateWithoutUserInput, EvolutionApiConfigUncheckedUpdateWithoutUserInput>
    create: XOR<EvolutionApiConfigCreateWithoutUserInput, EvolutionApiConfigUncheckedCreateWithoutUserInput>
    where?: EvolutionApiConfigWhereInput
  }

  export type EvolutionApiConfigUpdateToOneWithWhereWithoutUserInput = {
    where?: EvolutionApiConfigWhereInput
    data: XOR<EvolutionApiConfigUpdateWithoutUserInput, EvolutionApiConfigUncheckedUpdateWithoutUserInput>
  }

  export type EvolutionApiConfigUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutEvolutionConfigNestedInput
  }

  export type EvolutionApiConfigUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutEvolutionConfigNestedInput
  }

  export type MessageTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    update: XOR<MessageTemplateUpdateWithoutUserInput, MessageTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput>
  }

  export type MessageTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    data: XOR<MessageTemplateUpdateWithoutUserInput, MessageTemplateUncheckedUpdateWithoutUserInput>
  }

  export type MessageTemplateUpdateManyWithWhereWithoutUserInput = {
    where: MessageTemplateScalarWhereInput
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageTemplateScalarWhereInput = {
    AND?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    OR?: MessageTemplateScalarWhereInput[]
    NOT?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    userId?: StringFilter<"MessageTemplate"> | string
    title?: StringFilter<"MessageTemplate"> | string
    body?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMemberAccessGrantsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMemberAccessGrantsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMemberAccessGrantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberAccessGrantsInput, UserUncheckedCreateWithoutMemberAccessGrantsInput>
  }

  export type UserCreateWithoutMemberAccessesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMemberAccessesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMemberAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberAccessesInput, UserUncheckedCreateWithoutMemberAccessesInput>
  }

  export type UserUpsertWithoutMemberAccessGrantsInput = {
    update: XOR<UserUpdateWithoutMemberAccessGrantsInput, UserUncheckedUpdateWithoutMemberAccessGrantsInput>
    create: XOR<UserCreateWithoutMemberAccessGrantsInput, UserUncheckedCreateWithoutMemberAccessGrantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberAccessGrantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberAccessGrantsInput, UserUncheckedUpdateWithoutMemberAccessGrantsInput>
  }

  export type UserUpdateWithoutMemberAccessGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberAccessGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMemberAccessesInput = {
    update: XOR<UserUpdateWithoutMemberAccessesInput, UserUncheckedUpdateWithoutMemberAccessesInput>
    create: XOR<UserCreateWithoutMemberAccessesInput, UserUncheckedCreateWithoutMemberAccessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberAccessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberAccessesInput, UserUncheckedUpdateWithoutMemberAccessesInput>
  }

  export type UserUpdateWithoutMemberAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedBannersInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedBannersInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedBannersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBannersInput, UserUncheckedCreateWithoutCreatedBannersInput>
  }

  export type UserUpsertWithoutCreatedBannersInput = {
    update: XOR<UserUpdateWithoutCreatedBannersInput, UserUncheckedUpdateWithoutCreatedBannersInput>
    create: XOR<UserCreateWithoutCreatedBannersInput, UserUncheckedCreateWithoutCreatedBannersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBannersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBannersInput, UserUncheckedUpdateWithoutCreatedBannersInput>
  }

  export type UserUpdateWithoutCreatedBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeatureTogglesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeatureTogglesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeatureTogglesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeatureTogglesCreatedInput, UserUncheckedCreateWithoutFeatureTogglesCreatedInput>
  }

  export type UserUpsertWithoutFeatureTogglesCreatedInput = {
    update: XOR<UserUpdateWithoutFeatureTogglesCreatedInput, UserUncheckedUpdateWithoutFeatureTogglesCreatedInput>
    create: XOR<UserCreateWithoutFeatureTogglesCreatedInput, UserUncheckedCreateWithoutFeatureTogglesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeatureTogglesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeatureTogglesCreatedInput, UserUncheckedUpdateWithoutFeatureTogglesCreatedInput>
  }

  export type UserUpdateWithoutFeatureTogglesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeatureTogglesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOverridesGrantedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOverridesGrantedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOverridesGrantedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOverridesGrantedInput, UserUncheckedCreateWithoutOverridesGrantedInput>
  }

  export type UserCreateWithoutAccessOverridesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccessOverridesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccessOverridesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessOverridesInput, UserUncheckedCreateWithoutAccessOverridesInput>
  }

  export type UserUpsertWithoutOverridesGrantedInput = {
    update: XOR<UserUpdateWithoutOverridesGrantedInput, UserUncheckedUpdateWithoutOverridesGrantedInput>
    create: XOR<UserCreateWithoutOverridesGrantedInput, UserUncheckedCreateWithoutOverridesGrantedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOverridesGrantedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOverridesGrantedInput, UserUncheckedUpdateWithoutOverridesGrantedInput>
  }

  export type UserUpdateWithoutOverridesGrantedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOverridesGrantedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAccessOverridesInput = {
    update: XOR<UserUpdateWithoutAccessOverridesInput, UserUncheckedUpdateWithoutAccessOverridesInput>
    create: XOR<UserCreateWithoutAccessOverridesInput, UserUncheckedCreateWithoutAccessOverridesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccessOverridesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccessOverridesInput, UserUncheckedUpdateWithoutAccessOverridesInput>
  }

  export type UserUpdateWithoutAccessOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccessOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvitationsAcceptedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsAcceptedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsAcceptedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
  }

  export type UserCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
  }

  export type UserUpsertWithoutInvitationsAcceptedInput = {
    update: XOR<UserUpdateWithoutInvitationsAcceptedInput, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
    create: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsAcceptedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsAcceptedInput, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
  }

  export type UserUpdateWithoutInvitationsAcceptedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsAcceptedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseModuleCreateWithoutCourseInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModule?: CourseModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: CourseModuleCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
    dependentModules?: CourseModuleUncheckedCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleCreateManyCourseInputEnvelope = {
    data: CourseModuleCreateManyCourseInput | CourseModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseProgressCreateWithoutCourseInput = {
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseProgressesInput
  }

  export type CourseProgressUncheckedCreateWithoutCourseInput = {
    userId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseProgressCreateOrConnectWithoutCourseInput = {
    where: CourseProgressWhereUniqueInput
    create: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type CourseProgressCreateManyCourseInputEnvelope = {
    data: CourseProgressCreateManyCourseInput | CourseProgressCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseRecommendationCreateWithoutCourseInput = {
    id?: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUncheckedCreateWithoutCourseInput = {
    id?: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationCreateOrConnectWithoutCourseInput = {
    where: CourseRecommendationWhereUniqueInput
    create: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput>
  }

  export type CourseRecommendationCreateManyCourseInputEnvelope = {
    data: CourseRecommendationCreateManyCourseInput | CourseRecommendationCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCoursesAuthoredInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesAuthoredInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesAuthoredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesAuthoredInput, UserUncheckedCreateWithoutCoursesAuthoredInput>
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutCourseInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleScalarWhereInput = {
    AND?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    OR?: CourseModuleScalarWhereInput[]
    NOT?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    order?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    durationMinutes?: IntFilter<"CourseModule"> | number
    dripDaysAfter?: IntNullableFilter<"CourseModule"> | number | null
    dripReleaseAt?: DateTimeNullableFilter<"CourseModule"> | Date | string | null
    dripAfterModuleId?: StringNullableFilter<"CourseModule"> | string | null
  }

  export type CourseProgressUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseProgressWhereUniqueInput
    update: XOR<CourseProgressUpdateWithoutCourseInput, CourseProgressUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseProgressCreateWithoutCourseInput, CourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type CourseProgressUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseProgressWhereUniqueInput
    data: XOR<CourseProgressUpdateWithoutCourseInput, CourseProgressUncheckedUpdateWithoutCourseInput>
  }

  export type CourseProgressUpdateManyWithWhereWithoutCourseInput = {
    where: CourseProgressScalarWhereInput
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseRecommendationUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseRecommendationWhereUniqueInput
    update: XOR<CourseRecommendationUpdateWithoutCourseInput, CourseRecommendationUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseRecommendationCreateWithoutCourseInput, CourseRecommendationUncheckedCreateWithoutCourseInput>
  }

  export type CourseRecommendationUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseRecommendationWhereUniqueInput
    data: XOR<CourseRecommendationUpdateWithoutCourseInput, CourseRecommendationUncheckedUpdateWithoutCourseInput>
  }

  export type CourseRecommendationUpdateManyWithWhereWithoutCourseInput = {
    where: CourseRecommendationScalarWhereInput
    data: XOR<CourseRecommendationUpdateManyMutationInput, CourseRecommendationUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseRecommendationScalarWhereInput = {
    AND?: CourseRecommendationScalarWhereInput | CourseRecommendationScalarWhereInput[]
    OR?: CourseRecommendationScalarWhereInput[]
    NOT?: CourseRecommendationScalarWhereInput | CourseRecommendationScalarWhereInput[]
    id?: StringFilter<"CourseRecommendation"> | string
    courseId?: StringFilter<"CourseRecommendation"> | string
    reason?: StringFilter<"CourseRecommendation"> | string
    badge?: EnumRecommendationBadgeNullableFilter<"CourseRecommendation"> | $Enums.RecommendationBadge | null
  }

  export type UserUpsertWithoutCoursesAuthoredInput = {
    update: XOR<UserUpdateWithoutCoursesAuthoredInput, UserUncheckedUpdateWithoutCoursesAuthoredInput>
    create: XOR<UserCreateWithoutCoursesAuthoredInput, UserUncheckedCreateWithoutCoursesAuthoredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesAuthoredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesAuthoredInput, UserUncheckedUpdateWithoutCoursesAuthoredInput>
  }

  export type UserUpdateWithoutCoursesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    progresses?: CourseProgressCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationCreateNestedManyWithoutCourseInput
    author?: UserCreateNestedOneWithoutCoursesAuthoredInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    progresses?: CourseProgressUncheckedCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type CourseModuleCreateWithoutDependentModulesInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    course: CourseCreateNestedOneWithoutModulesInput
    dripAfterModule?: CourseModuleCreateNestedOneWithoutDependentModulesInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutDependentModulesInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutDependentModulesInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutDependentModulesInput, CourseModuleUncheckedCreateWithoutDependentModulesInput>
  }

  export type CourseModuleCreateWithoutDripAfterModuleInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    course: CourseCreateNestedOneWithoutModulesInput
    dependentModules?: CourseModuleCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutDripAfterModuleInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dependentModules?: CourseModuleUncheckedCreateNestedManyWithoutDripAfterModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutDripAfterModuleInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput>
  }

  export type CourseModuleCreateManyDripAfterModuleInputEnvelope = {
    data: CourseModuleCreateManyDripAfterModuleInput | CourseModuleCreateManyDripAfterModuleInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutModuleInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutModuleInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonCreateManyModuleInputEnvelope = {
    data: LessonCreateManyModuleInput | LessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    progresses?: CourseProgressUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUpdateManyWithoutCourseNestedInput
    author?: UserUpdateOneWithoutCoursesAuthoredNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    progresses?: CourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseModuleUpsertWithoutDependentModulesInput = {
    update: XOR<CourseModuleUpdateWithoutDependentModulesInput, CourseModuleUncheckedUpdateWithoutDependentModulesInput>
    create: XOR<CourseModuleCreateWithoutDependentModulesInput, CourseModuleUncheckedCreateWithoutDependentModulesInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutDependentModulesInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutDependentModulesInput, CourseModuleUncheckedUpdateWithoutDependentModulesInput>
  }

  export type CourseModuleUpdateWithoutDependentModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    dripAfterModule?: CourseModuleUpdateOneWithoutDependentModulesNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutDependentModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutDripAfterModuleInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutDripAfterModuleInput, CourseModuleUncheckedUpdateWithoutDripAfterModuleInput>
    create: XOR<CourseModuleCreateWithoutDripAfterModuleInput, CourseModuleUncheckedCreateWithoutDripAfterModuleInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutDripAfterModuleInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutDripAfterModuleInput, CourseModuleUncheckedUpdateWithoutDripAfterModuleInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutDripAfterModuleInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutDripAfterModuleInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    moduleId?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    title?: StringFilter<"Lesson"> | string
    summary?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    content?: JsonFilter<"Lesson">
    durationMinutes?: IntFilter<"Lesson"> | number
    isPreview?: BoolFilter<"Lesson"> | boolean
    releaseAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
  }

  export type LessonCommentCreateWithoutLessonInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyCreateNestedManyWithoutCommentInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
  }

  export type LessonCommentUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type LessonCommentCreateOrConnectWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput>
  }

  export type LessonCommentCreateManyLessonInputEnvelope = {
    data: LessonCommentCreateManyLessonInput | LessonCommentCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressAggregateCreateWithoutLessonInput = {
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonProgressAggregateInput
  }

  export type LessonProgressAggregateUncheckedCreateWithoutLessonInput = {
    userId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressAggregateCreateOrConnectWithoutLessonInput = {
    where: LessonProgressAggregateWhereUniqueInput
    create: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressAggregateCreateManyLessonInputEnvelope = {
    data: LessonProgressAggregateCreateManyLessonInput | LessonProgressAggregateCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressEventCreateWithoutLessonInput = {
    id?: string
    occurredAt: Date | string
    positionSec: number
    user: UserCreateNestedOneWithoutLessonProgressEventInput
  }

  export type LessonProgressEventUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonProgressEventCreateOrConnectWithoutLessonInput = {
    where: LessonProgressEventWhereUniqueInput
    create: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressEventCreateManyLessonInputEnvelope = {
    data: LessonProgressEventCreateManyLessonInput | LessonProgressEventCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonRatingCreateWithoutLessonInput = {
    id?: string
    value: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLessonRatingInput
  }

  export type LessonRatingUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    value: number
    createdAt?: Date | string
  }

  export type LessonRatingCreateOrConnectWithoutLessonInput = {
    where: LessonRatingWhereUniqueInput
    create: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput>
  }

  export type LessonRatingCreateManyLessonInputEnvelope = {
    data: LessonRatingCreateManyLessonInput | LessonRatingCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleCreateWithoutLessonsInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    course: CourseCreateNestedOneWithoutModulesInput
    dripAfterModule?: CourseModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: CourseModuleCreateNestedManyWithoutDripAfterModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutLessonsInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
    dependentModules?: CourseModuleUncheckedCreateNestedManyWithoutDripAfterModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutLessonsInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutLessonInput, LessonCommentUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutLessonInput, LessonCommentUncheckedUpdateWithoutLessonInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutLessonInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonProgressAggregateUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressAggregateWhereUniqueInput
    update: XOR<LessonProgressAggregateUpdateWithoutLessonInput, LessonProgressAggregateUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonProgressAggregateCreateWithoutLessonInput, LessonProgressAggregateUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressAggregateUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressAggregateWhereUniqueInput
    data: XOR<LessonProgressAggregateUpdateWithoutLessonInput, LessonProgressAggregateUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressAggregateUpdateManyWithWhereWithoutLessonInput = {
    where: LessonProgressAggregateScalarWhereInput
    data: XOR<LessonProgressAggregateUpdateManyMutationInput, LessonProgressAggregateUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonProgressEventUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressEventWhereUniqueInput
    update: XOR<LessonProgressEventUpdateWithoutLessonInput, LessonProgressEventUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonProgressEventCreateWithoutLessonInput, LessonProgressEventUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressEventUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressEventWhereUniqueInput
    data: XOR<LessonProgressEventUpdateWithoutLessonInput, LessonProgressEventUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressEventUpdateManyWithWhereWithoutLessonInput = {
    where: LessonProgressEventScalarWhereInput
    data: XOR<LessonProgressEventUpdateManyMutationInput, LessonProgressEventUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonRatingUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonRatingWhereUniqueInput
    update: XOR<LessonRatingUpdateWithoutLessonInput, LessonRatingUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonRatingCreateWithoutLessonInput, LessonRatingUncheckedCreateWithoutLessonInput>
  }

  export type LessonRatingUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonRatingWhereUniqueInput
    data: XOR<LessonRatingUpdateWithoutLessonInput, LessonRatingUncheckedUpdateWithoutLessonInput>
  }

  export type LessonRatingUpdateManyWithWhereWithoutLessonInput = {
    where: LessonRatingScalarWhereInput
    data: XOR<LessonRatingUpdateManyMutationInput, LessonRatingUncheckedUpdateManyWithoutLessonInput>
  }

  export type CourseModuleUpsertWithoutLessonsInput = {
    update: XOR<CourseModuleUpdateWithoutLessonsInput, CourseModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutLessonsInput, CourseModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseModuleUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    dripAfterModule?: CourseModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: CourseModuleUpdateManyWithoutDripAfterModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
    dependentModules?: CourseModuleUncheckedUpdateManyWithoutDripAfterModuleNestedInput
  }

  export type CourseCreateWithoutProgressesInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationCreateNestedManyWithoutCourseInput
    author?: UserCreateNestedOneWithoutCoursesAuthoredInput
  }

  export type CourseUncheckedCreateWithoutProgressesInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    recommendations?: CourseRecommendationUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProgressesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProgressesInput, CourseUncheckedCreateWithoutProgressesInput>
  }

  export type UserCreateWithoutCourseProgressesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseProgressesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseProgressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseProgressesInput, UserUncheckedCreateWithoutCourseProgressesInput>
  }

  export type CourseUpsertWithoutProgressesInput = {
    update: XOR<CourseUpdateWithoutProgressesInput, CourseUncheckedUpdateWithoutProgressesInput>
    create: XOR<CourseCreateWithoutProgressesInput, CourseUncheckedCreateWithoutProgressesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutProgressesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutProgressesInput, CourseUncheckedUpdateWithoutProgressesInput>
  }

  export type CourseUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUpdateManyWithoutCourseNestedInput
    author?: UserUpdateOneWithoutCoursesAuthoredNestedInput
  }

  export type CourseUncheckedUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutCourseProgressesInput = {
    update: XOR<UserUpdateWithoutCourseProgressesInput, UserUncheckedUpdateWithoutCourseProgressesInput>
    create: XOR<UserCreateWithoutCourseProgressesInput, UserUncheckedCreateWithoutCourseProgressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseProgressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseProgressesInput, UserUncheckedUpdateWithoutCourseProgressesInput>
  }

  export type UserUpdateWithoutCourseProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCommentReplyCreateWithoutCommentInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput
    parentReply?: LessonCommentReplyCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentReplyCreateNestedManyWithoutParentReplyInput
    user: UserCreateNestedOneWithoutLessonCommentRepliesInput
  }

  export type LessonCommentReplyUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyCreateOrConnectWithoutCommentInput = {
    where: LessonCommentReplyWhereUniqueInput
    create: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type LessonCommentReplyCreateManyCommentInputEnvelope = {
    data: LessonCommentReplyCreateManyCommentInput | LessonCommentReplyCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutCommentsInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    progressAggregates?: LessonProgressAggregateCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingCreateNestedManyWithoutLessonInput
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutCommentsInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    progressAggregates?: LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCommentsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutModeratedLessonCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModeratedLessonCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModeratedLessonCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModeratedLessonCommentsInput, UserUncheckedCreateWithoutModeratedLessonCommentsInput>
  }

  export type UserCreateWithoutLessonCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
  }

  export type LessonCommentReplyUpsertWithWhereUniqueWithoutCommentInput = {
    where: LessonCommentReplyWhereUniqueInput
    update: XOR<LessonCommentReplyUpdateWithoutCommentInput, LessonCommentReplyUncheckedUpdateWithoutCommentInput>
    create: XOR<LessonCommentReplyCreateWithoutCommentInput, LessonCommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type LessonCommentReplyUpdateWithWhereUniqueWithoutCommentInput = {
    where: LessonCommentReplyWhereUniqueInput
    data: XOR<LessonCommentReplyUpdateWithoutCommentInput, LessonCommentReplyUncheckedUpdateWithoutCommentInput>
  }

  export type LessonCommentReplyUpdateManyWithWhereWithoutCommentInput = {
    where: LessonCommentReplyScalarWhereInput
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyWithoutCommentInput>
  }

  export type LessonUpsertWithoutCommentsInput = {
    update: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type LessonUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressAggregates?: LessonProgressAggregateUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUpdateManyWithoutLessonNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressAggregates?: LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutModeratedLessonCommentsInput = {
    update: XOR<UserUpdateWithoutModeratedLessonCommentsInput, UserUncheckedUpdateWithoutModeratedLessonCommentsInput>
    create: XOR<UserCreateWithoutModeratedLessonCommentsInput, UserUncheckedCreateWithoutModeratedLessonCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModeratedLessonCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModeratedLessonCommentsInput, UserUncheckedUpdateWithoutModeratedLessonCommentsInput>
  }

  export type UserUpdateWithoutModeratedLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModeratedLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutLessonCommentsInput = {
    update: XOR<UserUpdateWithoutLessonCommentsInput, UserUncheckedUpdateWithoutLessonCommentsInput>
    create: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonCommentsInput, UserUncheckedUpdateWithoutLessonCommentsInput>
  }

  export type UserUpdateWithoutLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCommentCreateWithoutRepliesInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    lesson: LessonCreateNestedOneWithoutCommentsInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
  }

  export type LessonCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    lessonId: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentCreateOrConnectWithoutRepliesInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
  }

  export type UserCreateWithoutModeratedLessonCommentRepliesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModeratedLessonCommentRepliesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModeratedLessonCommentRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModeratedLessonCommentRepliesInput, UserUncheckedCreateWithoutModeratedLessonCommentRepliesInput>
  }

  export type LessonCommentReplyCreateWithoutRepliesInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    comment: LessonCommentCreateNestedOneWithoutRepliesInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput
    parentReply?: LessonCommentReplyCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutLessonCommentRepliesInput
  }

  export type LessonCommentReplyUncheckedCreateWithoutRepliesInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentReplyCreateOrConnectWithoutRepliesInput = {
    where: LessonCommentReplyWhereUniqueInput
    create: XOR<LessonCommentReplyCreateWithoutRepliesInput, LessonCommentReplyUncheckedCreateWithoutRepliesInput>
  }

  export type LessonCommentReplyCreateWithoutParentReplyInput = {
    id?: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    comment: LessonCommentCreateNestedOneWithoutRepliesInput
    moderatedBy?: UserCreateNestedOneWithoutModeratedLessonCommentRepliesInput
    replies?: LessonCommentReplyCreateNestedManyWithoutParentReplyInput
    user: UserCreateNestedOneWithoutLessonCommentRepliesInput
  }

  export type LessonCommentReplyUncheckedCreateWithoutParentReplyInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
    replies?: LessonCommentReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type LessonCommentReplyCreateOrConnectWithoutParentReplyInput = {
    where: LessonCommentReplyWhereUniqueInput
    create: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput>
  }

  export type LessonCommentReplyCreateManyParentReplyInputEnvelope = {
    data: LessonCommentReplyCreateManyParentReplyInput | LessonCommentReplyCreateManyParentReplyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLessonCommentRepliesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonCommentRepliesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonCommentRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonCommentRepliesInput, UserUncheckedCreateWithoutLessonCommentRepliesInput>
  }

  export type LessonCommentUpsertWithoutRepliesInput = {
    update: XOR<LessonCommentUpdateWithoutRepliesInput, LessonCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    where?: LessonCommentWhereInput
  }

  export type LessonCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: LessonCommentWhereInput
    data: XOR<LessonCommentUpdateWithoutRepliesInput, LessonCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type LessonCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type UserUpsertWithoutModeratedLessonCommentRepliesInput = {
    update: XOR<UserUpdateWithoutModeratedLessonCommentRepliesInput, UserUncheckedUpdateWithoutModeratedLessonCommentRepliesInput>
    create: XOR<UserCreateWithoutModeratedLessonCommentRepliesInput, UserUncheckedCreateWithoutModeratedLessonCommentRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModeratedLessonCommentRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModeratedLessonCommentRepliesInput, UserUncheckedUpdateWithoutModeratedLessonCommentRepliesInput>
  }

  export type UserUpdateWithoutModeratedLessonCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModeratedLessonCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCommentReplyUpsertWithoutRepliesInput = {
    update: XOR<LessonCommentReplyUpdateWithoutRepliesInput, LessonCommentReplyUncheckedUpdateWithoutRepliesInput>
    create: XOR<LessonCommentReplyCreateWithoutRepliesInput, LessonCommentReplyUncheckedCreateWithoutRepliesInput>
    where?: LessonCommentReplyWhereInput
  }

  export type LessonCommentReplyUpdateToOneWithWhereWithoutRepliesInput = {
    where?: LessonCommentReplyWhereInput
    data: XOR<LessonCommentReplyUpdateWithoutRepliesInput, LessonCommentReplyUncheckedUpdateWithoutRepliesInput>
  }

  export type LessonCommentReplyUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: LessonCommentUpdateOneRequiredWithoutRepliesNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput
    parentReply?: LessonCommentReplyUpdateOneWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentReplyUpsertWithWhereUniqueWithoutParentReplyInput = {
    where: LessonCommentReplyWhereUniqueInput
    update: XOR<LessonCommentReplyUpdateWithoutParentReplyInput, LessonCommentReplyUncheckedUpdateWithoutParentReplyInput>
    create: XOR<LessonCommentReplyCreateWithoutParentReplyInput, LessonCommentReplyUncheckedCreateWithoutParentReplyInput>
  }

  export type LessonCommentReplyUpdateWithWhereUniqueWithoutParentReplyInput = {
    where: LessonCommentReplyWhereUniqueInput
    data: XOR<LessonCommentReplyUpdateWithoutParentReplyInput, LessonCommentReplyUncheckedUpdateWithoutParentReplyInput>
  }

  export type LessonCommentReplyUpdateManyWithWhereWithoutParentReplyInput = {
    where: LessonCommentReplyScalarWhereInput
    data: XOR<LessonCommentReplyUpdateManyMutationInput, LessonCommentReplyUncheckedUpdateManyWithoutParentReplyInput>
  }

  export type UserUpsertWithoutLessonCommentRepliesInput = {
    update: XOR<UserUpdateWithoutLessonCommentRepliesInput, UserUncheckedUpdateWithoutLessonCommentRepliesInput>
    create: XOR<UserCreateWithoutLessonCommentRepliesInput, UserUncheckedCreateWithoutLessonCommentRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonCommentRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonCommentRepliesInput, UserUncheckedUpdateWithoutLessonCommentRepliesInput>
  }

  export type UserUpdateWithoutLessonCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseCreateWithoutRecommendationsInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressCreateNestedManyWithoutCourseInput
    author?: UserCreateNestedOneWithoutCoursesAuthoredInput
  }

  export type CourseUncheckedCreateWithoutRecommendationsInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progresses?: CourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutRecommendationsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutRecommendationsInput, CourseUncheckedCreateWithoutRecommendationsInput>
  }

  export type CourseUpsertWithoutRecommendationsInput = {
    update: XOR<CourseUpdateWithoutRecommendationsInput, CourseUncheckedUpdateWithoutRecommendationsInput>
    create: XOR<CourseCreateWithoutRecommendationsInput, CourseUncheckedCreateWithoutRecommendationsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutRecommendationsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutRecommendationsInput, CourseUncheckedUpdateWithoutRecommendationsInput>
  }

  export type CourseUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUpdateManyWithoutCourseNestedInput
    author?: UserUpdateOneWithoutCoursesAuthoredNestedInput
  }

  export type CourseUncheckedUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonCreateWithoutRatingsInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventCreateNestedManyWithoutLessonInput
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutRatingsInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutRatingsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutRatingsInput, LessonUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutLessonRatingInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonRatingInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonRatingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonRatingInput, UserUncheckedCreateWithoutLessonRatingInput>
  }

  export type LessonUpsertWithoutRatingsInput = {
    update: XOR<LessonUpdateWithoutRatingsInput, LessonUncheckedUpdateWithoutRatingsInput>
    create: XOR<LessonCreateWithoutRatingsInput, LessonUncheckedCreateWithoutRatingsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutRatingsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutRatingsInput, LessonUncheckedUpdateWithoutRatingsInput>
  }

  export type LessonUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUpdateManyWithoutLessonNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutLessonRatingInput = {
    update: XOR<UserUpdateWithoutLessonRatingInput, UserUncheckedUpdateWithoutLessonRatingInput>
    create: XOR<UserCreateWithoutLessonRatingInput, UserUncheckedCreateWithoutLessonRatingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonRatingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonRatingInput, UserUncheckedUpdateWithoutLessonRatingInput>
  }

  export type UserUpdateWithoutLessonRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCreateWithoutProgressEventsInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingCreateNestedManyWithoutLessonInput
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutProgressEventsInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    progressAggregates?: LessonProgressAggregateUncheckedCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutProgressEventsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressEventsInput, LessonUncheckedCreateWithoutProgressEventsInput>
  }

  export type UserCreateWithoutLessonProgressEventInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonProgressEventInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonProgressEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonProgressEventInput, UserUncheckedCreateWithoutLessonProgressEventInput>
  }

  export type LessonUpsertWithoutProgressEventsInput = {
    update: XOR<LessonUpdateWithoutProgressEventsInput, LessonUncheckedUpdateWithoutProgressEventsInput>
    create: XOR<LessonCreateWithoutProgressEventsInput, LessonUncheckedCreateWithoutProgressEventsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressEventsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressEventsInput, LessonUncheckedUpdateWithoutProgressEventsInput>
  }

  export type LessonUpdateWithoutProgressEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUpdateManyWithoutLessonNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutLessonProgressEventInput = {
    update: XOR<UserUpdateWithoutLessonProgressEventInput, UserUncheckedUpdateWithoutLessonProgressEventInput>
    create: XOR<UserCreateWithoutLessonProgressEventInput, UserUncheckedCreateWithoutLessonProgressEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonProgressEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonProgressEventInput, UserUncheckedUpdateWithoutLessonProgressEventInput>
  }

  export type UserUpdateWithoutLessonProgressEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonProgressEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCreateWithoutProgressAggregatesInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingCreateNestedManyWithoutLessonInput
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutProgressAggregatesInput = {
    id?: string
    moduleId: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    progressEvents?: LessonProgressEventUncheckedCreateNestedManyWithoutLessonInput
    ratings?: LessonRatingUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutProgressAggregatesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressAggregatesInput, LessonUncheckedCreateWithoutProgressAggregatesInput>
  }

  export type UserCreateWithoutLessonProgressAggregateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonProgressAggregateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonProgressAggregateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonProgressAggregateInput, UserUncheckedCreateWithoutLessonProgressAggregateInput>
  }

  export type LessonUpsertWithoutProgressAggregatesInput = {
    update: XOR<LessonUpdateWithoutProgressAggregatesInput, LessonUncheckedUpdateWithoutProgressAggregatesInput>
    create: XOR<LessonCreateWithoutProgressAggregatesInput, LessonUncheckedCreateWithoutProgressAggregatesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressAggregatesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressAggregatesInput, LessonUncheckedUpdateWithoutProgressAggregatesInput>
  }

  export type LessonUpdateWithoutProgressAggregatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUpdateManyWithoutLessonNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressAggregatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutLessonProgressAggregateInput = {
    update: XOR<UserUpdateWithoutLessonProgressAggregateInput, UserUncheckedUpdateWithoutLessonProgressAggregateInput>
    create: XOR<UserCreateWithoutLessonProgressAggregateInput, UserUncheckedCreateWithoutLessonProgressAggregateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonProgressAggregateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonProgressAggregateInput, UserUncheckedUpdateWithoutLessonProgressAggregateInput>
  }

  export type UserUpdateWithoutLessonProgressAggregateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonProgressAggregateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutEvolutionConfigInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutEvolutionConfigInput = {
    id?: string
    userId: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEvolutionConfigInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput>
  }

  export type CampaignCreateManyEvolutionConfigInputEnvelope = {
    data: CampaignCreateManyEvolutionConfigInput | CampaignCreateManyEvolutionConfigInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEvolutionConfigInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvolutionConfigInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvolutionConfigInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvolutionConfigInput, UserUncheckedCreateWithoutEvolutionConfigInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutEvolutionConfigInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutEvolutionConfigInput, CampaignUncheckedUpdateWithoutEvolutionConfigInput>
    create: XOR<CampaignCreateWithoutEvolutionConfigInput, CampaignUncheckedCreateWithoutEvolutionConfigInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutEvolutionConfigInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutEvolutionConfigInput, CampaignUncheckedUpdateWithoutEvolutionConfigInput>
  }

  export type CampaignUpdateManyWithWhereWithoutEvolutionConfigInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutEvolutionConfigInput>
  }

  export type UserUpsertWithoutEvolutionConfigInput = {
    update: XOR<UserUpdateWithoutEvolutionConfigInput, UserUncheckedUpdateWithoutEvolutionConfigInput>
    create: XOR<UserCreateWithoutEvolutionConfigInput, UserUncheckedCreateWithoutEvolutionConfigInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvolutionConfigInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvolutionConfigInput, UserUncheckedUpdateWithoutEvolutionConfigInput>
  }

  export type UserUpdateWithoutEvolutionConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvolutionConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutSegmentInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutSegmentInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSegmentInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput>
  }

  export type CampaignCreateManySegmentInputEnvelope = {
    data: CampaignCreateManySegmentInput | CampaignCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutContactSegmentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactSegmentsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactSegmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactSegmentsInput, UserUncheckedCreateWithoutContactSegmentsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutSegmentInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutSegmentInput, CampaignUncheckedUpdateWithoutSegmentInput>
    create: XOR<CampaignCreateWithoutSegmentInput, CampaignUncheckedCreateWithoutSegmentInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutSegmentInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutSegmentInput, CampaignUncheckedUpdateWithoutSegmentInput>
  }

  export type CampaignUpdateManyWithWhereWithoutSegmentInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutSegmentInput>
  }

  export type UserUpsertWithoutContactSegmentsInput = {
    update: XOR<UserUpdateWithoutContactSegmentsInput, UserUncheckedUpdateWithoutContactSegmentsInput>
    create: XOR<UserCreateWithoutContactSegmentsInput, UserUncheckedCreateWithoutContactSegmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactSegmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactSegmentsInput, UserUncheckedUpdateWithoutContactSegmentsInput>
  }

  export type UserUpdateWithoutContactSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignCreateManyTemplateInputEnvelope = {
    data: CampaignCreateManyTemplateInput | CampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMessageTemplatesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageTemplatesInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserUpsertWithoutMessageTemplatesInput = {
    update: XOR<UserUpdateWithoutMessageTemplatesInput, UserUncheckedUpdateWithoutMessageTemplatesInput>
    create: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageTemplatesInput, UserUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type UserUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CampaignMetricsCreateWithoutCampaignInput = {
    totalMessages?: number
    delivered?: number
    failed?: number
    pending?: number
    averageDeliveryMs?: number
    lastUpdatedAt?: Date | string
  }

  export type CampaignMetricsUncheckedCreateWithoutCampaignInput = {
    totalMessages?: number
    delivered?: number
    failed?: number
    pending?: number
    averageDeliveryMs?: number
    lastUpdatedAt?: Date | string
  }

  export type CampaignMetricsCreateOrConnectWithoutCampaignInput = {
    where: CampaignMetricsWhereUniqueInput
    create: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRunCreateWithoutCampaignInput = {
    id?: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
    initiator: UserCreateNestedOneWithoutCampaignRunsInitiatedInput
  }

  export type CampaignRunUncheckedCreateWithoutCampaignInput = {
    id?: string
    initiatedBy: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignRunCreateOrConnectWithoutCampaignInput = {
    where: CampaignRunWhereUniqueInput
    create: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRunCreateManyCampaignInputEnvelope = {
    data: CampaignRunCreateManyCampaignInput | CampaignRunCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTimelinePointCreateWithoutCampaignInput = {
    id?: string
    timestamp: Date | string
    delivered?: number
    failed?: number
  }

  export type CampaignTimelinePointUncheckedCreateWithoutCampaignInput = {
    id?: string
    timestamp: Date | string
    delivered?: number
    failed?: number
  }

  export type CampaignTimelinePointCreateOrConnectWithoutCampaignInput = {
    where: CampaignTimelinePointWhereUniqueInput
    create: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTimelinePointCreateManyCampaignInputEnvelope = {
    data: CampaignTimelinePointCreateManyCampaignInput | CampaignTimelinePointCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EvolutionApiConfigCreateWithoutCampaignsInput = {
    id?: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEvolutionConfigInput
  }

  export type EvolutionApiConfigUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    baseUrl: string
    apiKeyEncrypted: Bytes
    connectedAt?: Date | string | null
    lastHealthCheckAt?: Date | string | null
    status: $Enums.EvolutionConnectionStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvolutionApiConfigCreateOrConnectWithoutCampaignsInput = {
    where: EvolutionApiConfigWhereUniqueInput
    create: XOR<EvolutionApiConfigCreateWithoutCampaignsInput, EvolutionApiConfigUncheckedCreateWithoutCampaignsInput>
  }

  export type ContactSegmentCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutContactSegmentsInput
  }

  export type ContactSegmentUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
  }

  export type ContactSegmentCreateOrConnectWithoutCampaignsInput = {
    where: ContactSegmentWhereUniqueInput
    create: XOR<ContactSegmentCreateWithoutCampaignsInput, ContactSegmentUncheckedCreateWithoutCampaignsInput>
  }

  export type MessageTemplateCreateWithoutCampaignsInput = {
    id?: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessageTemplatesInput
  }

  export type MessageTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateOrConnectWithoutCampaignsInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutCampaignsInput, MessageTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignMetricsUpsertWithoutCampaignInput = {
    update: XOR<CampaignMetricsUpdateWithoutCampaignInput, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
    where?: CampaignMetricsWhereInput
  }

  export type CampaignMetricsUpdateToOneWithWhereWithoutCampaignInput = {
    where?: CampaignMetricsWhereInput
    data: XOR<CampaignMetricsUpdateWithoutCampaignInput, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMetricsUpdateWithoutCampaignInput = {
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMetricsUncheckedUpdateWithoutCampaignInput = {
    totalMessages?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    averageDeliveryMs?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRunUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRunWhereUniqueInput
    update: XOR<CampaignRunUpdateWithoutCampaignInput, CampaignRunUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignRunCreateWithoutCampaignInput, CampaignRunUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRunUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRunWhereUniqueInput
    data: XOR<CampaignRunUpdateWithoutCampaignInput, CampaignRunUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignRunUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignRunScalarWhereInput
    data: XOR<CampaignRunUpdateManyMutationInput, CampaignRunUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignTimelinePointUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTimelinePointWhereUniqueInput
    update: XOR<CampaignTimelinePointUpdateWithoutCampaignInput, CampaignTimelinePointUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTimelinePointCreateWithoutCampaignInput, CampaignTimelinePointUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTimelinePointUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTimelinePointWhereUniqueInput
    data: XOR<CampaignTimelinePointUpdateWithoutCampaignInput, CampaignTimelinePointUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignTimelinePointUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignTimelinePointScalarWhereInput
    data: XOR<CampaignTimelinePointUpdateManyMutationInput, CampaignTimelinePointUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignTimelinePointScalarWhereInput = {
    AND?: CampaignTimelinePointScalarWhereInput | CampaignTimelinePointScalarWhereInput[]
    OR?: CampaignTimelinePointScalarWhereInput[]
    NOT?: CampaignTimelinePointScalarWhereInput | CampaignTimelinePointScalarWhereInput[]
    id?: StringFilter<"CampaignTimelinePoint"> | string
    campaignId?: StringFilter<"CampaignTimelinePoint"> | string
    timestamp?: DateTimeFilter<"CampaignTimelinePoint"> | Date | string
    delivered?: IntFilter<"CampaignTimelinePoint"> | number
    failed?: IntFilter<"CampaignTimelinePoint"> | number
  }

  export type EvolutionApiConfigUpsertWithoutCampaignsInput = {
    update: XOR<EvolutionApiConfigUpdateWithoutCampaignsInput, EvolutionApiConfigUncheckedUpdateWithoutCampaignsInput>
    create: XOR<EvolutionApiConfigCreateWithoutCampaignsInput, EvolutionApiConfigUncheckedCreateWithoutCampaignsInput>
    where?: EvolutionApiConfigWhereInput
  }

  export type EvolutionApiConfigUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: EvolutionApiConfigWhereInput
    data: XOR<EvolutionApiConfigUpdateWithoutCampaignsInput, EvolutionApiConfigUncheckedUpdateWithoutCampaignsInput>
  }

  export type EvolutionApiConfigUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEvolutionConfigNestedInput
  }

  export type EvolutionApiConfigUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastHealthCheckAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEvolutionConnectionStatusFieldUpdateOperationsInput | $Enums.EvolutionConnectionStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSegmentUpsertWithoutCampaignsInput = {
    update: XOR<ContactSegmentUpdateWithoutCampaignsInput, ContactSegmentUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ContactSegmentCreateWithoutCampaignsInput, ContactSegmentUncheckedCreateWithoutCampaignsInput>
    where?: ContactSegmentWhereInput
  }

  export type ContactSegmentUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ContactSegmentWhereInput
    data: XOR<ContactSegmentUpdateWithoutCampaignsInput, ContactSegmentUncheckedUpdateWithoutCampaignsInput>
  }

  export type ContactSegmentUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactSegmentsNestedInput
  }

  export type ContactSegmentUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpsertWithoutCampaignsInput = {
    update: XOR<MessageTemplateUpdateWithoutCampaignsInput, MessageTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<MessageTemplateCreateWithoutCampaignsInput, MessageTemplateUncheckedCreateWithoutCampaignsInput>
    where?: MessageTemplateWhereInput
  }

  export type MessageTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: MessageTemplateWhereInput
    data: XOR<MessageTemplateUpdateWithoutCampaignsInput, MessageTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type MessageTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutRunsInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutRunsInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRunsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRunsInput, CampaignUncheckedCreateWithoutRunsInput>
  }

  export type UserCreateWithoutCampaignRunsInitiatedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignRunsInitiatedInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignRunsInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignRunsInitiatedInput, UserUncheckedCreateWithoutCampaignRunsInitiatedInput>
  }

  export type CampaignUpsertWithoutRunsInput = {
    update: XOR<CampaignUpdateWithoutRunsInput, CampaignUncheckedUpdateWithoutRunsInput>
    create: XOR<CampaignCreateWithoutRunsInput, CampaignUncheckedCreateWithoutRunsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRunsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRunsInput, CampaignUncheckedUpdateWithoutRunsInput>
  }

  export type CampaignUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCampaignRunsInitiatedInput = {
    update: XOR<UserUpdateWithoutCampaignRunsInitiatedInput, UserUncheckedUpdateWithoutCampaignRunsInitiatedInput>
    create: XOR<UserCreateWithoutCampaignRunsInitiatedInput, UserUncheckedCreateWithoutCampaignRunsInitiatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignRunsInitiatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignRunsInitiatedInput, UserUncheckedUpdateWithoutCampaignRunsInitiatedInput>
  }

  export type UserUpdateWithoutCampaignRunsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignRunsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutMetricsInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
    timeline?: CampaignTimelinePointUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMetricsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
  }

  export type CampaignUpsertWithoutMetricsInput = {
    update: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMetricsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type CampaignUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutTimelineInput = {
    id?: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunCreateNestedManyWithoutCampaignInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutCampaignsInput
    segment: ContactSegmentCreateNestedOneWithoutCampaignsInput
    template: MessageTemplateCreateNestedOneWithoutCampaignsInput
    user: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutTimelineInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: CampaignMetricsUncheckedCreateNestedOneWithoutCampaignInput
    runs?: CampaignRunUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTimelineInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTimelineInput, CampaignUncheckedCreateWithoutTimelineInput>
  }

  export type CampaignUpsertWithoutTimelineInput = {
    update: XOR<CampaignUpdateWithoutTimelineInput, CampaignUncheckedUpdateWithoutTimelineInput>
    create: XOR<CampaignCreateWithoutTimelineInput, CampaignUncheckedCreateWithoutTimelineInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTimelineInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTimelineInput, CampaignUncheckedUpdateWithoutTimelineInput>
  }

  export type CampaignUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ResourceCreateWithoutCategoryInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentCreateNestedManyWithoutResourceInput
    author: UserCreateNestedOneWithoutResourcesAuthoredInput
  }

  export type ResourceUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetUncheckedCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutCategoryInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput>
  }

  export type ResourceCreateManyCategoryInputEnvelope = {
    data: ResourceCreateManyCategoryInput | ResourceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ResourceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutCategoryInput, ResourceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ResourceCreateWithoutCategoryInput, ResourceUncheckedCreateWithoutCategoryInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutCategoryInput, ResourceUncheckedUpdateWithoutCategoryInput>
  }

  export type ResourceUpdateManyWithWhereWithoutCategoryInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ResourceTagAssignmentCreateWithoutTagInput = {
    resource: ResourceCreateNestedOneWithoutTagsInput
  }

  export type ResourceTagAssignmentUncheckedCreateWithoutTagInput = {
    resourceId: string
  }

  export type ResourceTagAssignmentCreateOrConnectWithoutTagInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    create: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput>
  }

  export type ResourceTagAssignmentCreateManyTagInputEnvelope = {
    data: ResourceTagAssignmentCreateManyTagInput | ResourceTagAssignmentCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ResourceTagAssignmentUpsertWithWhereUniqueWithoutTagInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    update: XOR<ResourceTagAssignmentUpdateWithoutTagInput, ResourceTagAssignmentUncheckedUpdateWithoutTagInput>
    create: XOR<ResourceTagAssignmentCreateWithoutTagInput, ResourceTagAssignmentUncheckedCreateWithoutTagInput>
  }

  export type ResourceTagAssignmentUpdateWithWhereUniqueWithoutTagInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    data: XOR<ResourceTagAssignmentUpdateWithoutTagInput, ResourceTagAssignmentUncheckedUpdateWithoutTagInput>
  }

  export type ResourceTagAssignmentUpdateManyWithWhereWithoutTagInput = {
    where: ResourceTagAssignmentScalarWhereInput
    data: XOR<ResourceTagAssignmentUpdateManyMutationInput, ResourceTagAssignmentUncheckedUpdateManyWithoutTagInput>
  }

  export type ResourceTagAssignmentScalarWhereInput = {
    AND?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
    OR?: ResourceTagAssignmentScalarWhereInput[]
    NOT?: ResourceTagAssignmentScalarWhereInput | ResourceTagAssignmentScalarWhereInput[]
    resourceId?: StringFilter<"ResourceTagAssignment"> | string
    tagId?: StringFilter<"ResourceTagAssignment"> | string
  }

  export type ResourceAssetCreateWithoutResourceInput = {
    id?: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ResourceAssetUncheckedCreateWithoutResourceInput = {
    id?: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ResourceAssetCreateOrConnectWithoutResourceInput = {
    where: ResourceAssetWhereUniqueInput
    create: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput>
  }

  export type ResourceAssetCreateManyResourceInputEnvelope = {
    data: ResourceAssetCreateManyResourceInput | ResourceAssetCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceDownloadLogCreateWithoutResourceInput = {
    id?: string
    downloadedAt?: Date | string
    ipAddress: string
    user: UserCreateNestedOneWithoutResourceDownloadLogsInput
  }

  export type ResourceDownloadLogUncheckedCreateWithoutResourceInput = {
    id?: string
    userId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceDownloadLogCreateOrConnectWithoutResourceInput = {
    where: ResourceDownloadLogWhereUniqueInput
    create: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput>
  }

  export type ResourceDownloadLogCreateManyResourceInputEnvelope = {
    data: ResourceDownloadLogCreateManyResourceInput | ResourceDownloadLogCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceTagAssignmentCreateWithoutResourceInput = {
    tag: ResourceTagCreateNestedOneWithoutTagAssignmentsInput
  }

  export type ResourceTagAssignmentUncheckedCreateWithoutResourceInput = {
    tagId: string
  }

  export type ResourceTagAssignmentCreateOrConnectWithoutResourceInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    create: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput>
  }

  export type ResourceTagAssignmentCreateManyResourceInputEnvelope = {
    data: ResourceTagAssignmentCreateManyResourceInput | ResourceTagAssignmentCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCategoryCreateWithoutResourcesInput = {
    id?: string
    name: string
    description: string
    icon: string
    order: number
    createdAt?: Date | string
  }

  export type ResourceCategoryUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    description: string
    icon: string
    order: number
    createdAt?: Date | string
  }

  export type ResourceCategoryCreateOrConnectWithoutResourcesInput = {
    where: ResourceCategoryWhereUniqueInput
    create: XOR<ResourceCategoryCreateWithoutResourcesInput, ResourceCategoryUncheckedCreateWithoutResourcesInput>
  }

  export type UserCreateWithoutResourcesAuthoredInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogCreateNestedManyWithoutUserInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResourcesAuthoredInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedCreateNestedManyWithoutUserInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResourcesAuthoredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesAuthoredInput, UserUncheckedCreateWithoutResourcesAuthoredInput>
  }

  export type ResourceAssetUpsertWithWhereUniqueWithoutResourceInput = {
    where: ResourceAssetWhereUniqueInput
    update: XOR<ResourceAssetUpdateWithoutResourceInput, ResourceAssetUncheckedUpdateWithoutResourceInput>
    create: XOR<ResourceAssetCreateWithoutResourceInput, ResourceAssetUncheckedCreateWithoutResourceInput>
  }

  export type ResourceAssetUpdateWithWhereUniqueWithoutResourceInput = {
    where: ResourceAssetWhereUniqueInput
    data: XOR<ResourceAssetUpdateWithoutResourceInput, ResourceAssetUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceAssetUpdateManyWithWhereWithoutResourceInput = {
    where: ResourceAssetScalarWhereInput
    data: XOR<ResourceAssetUpdateManyMutationInput, ResourceAssetUncheckedUpdateManyWithoutResourceInput>
  }

  export type ResourceAssetScalarWhereInput = {
    AND?: ResourceAssetScalarWhereInput | ResourceAssetScalarWhereInput[]
    OR?: ResourceAssetScalarWhereInput[]
    NOT?: ResourceAssetScalarWhereInput | ResourceAssetScalarWhereInput[]
    id?: StringFilter<"ResourceAsset"> | string
    resourceId?: StringFilter<"ResourceAsset"> | string
    fileUrl?: StringFilter<"ResourceAsset"> | string
    fileName?: StringFilter<"ResourceAsset"> | string
    mimeType?: StringFilter<"ResourceAsset"> | string
    sizeBytes?: IntFilter<"ResourceAsset"> | number
    createdAt?: DateTimeFilter<"ResourceAsset"> | Date | string
  }

  export type ResourceDownloadLogUpsertWithWhereUniqueWithoutResourceInput = {
    where: ResourceDownloadLogWhereUniqueInput
    update: XOR<ResourceDownloadLogUpdateWithoutResourceInput, ResourceDownloadLogUncheckedUpdateWithoutResourceInput>
    create: XOR<ResourceDownloadLogCreateWithoutResourceInput, ResourceDownloadLogUncheckedCreateWithoutResourceInput>
  }

  export type ResourceDownloadLogUpdateWithWhereUniqueWithoutResourceInput = {
    where: ResourceDownloadLogWhereUniqueInput
    data: XOR<ResourceDownloadLogUpdateWithoutResourceInput, ResourceDownloadLogUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceDownloadLogUpdateManyWithWhereWithoutResourceInput = {
    where: ResourceDownloadLogScalarWhereInput
    data: XOR<ResourceDownloadLogUpdateManyMutationInput, ResourceDownloadLogUncheckedUpdateManyWithoutResourceInput>
  }

  export type ResourceTagAssignmentUpsertWithWhereUniqueWithoutResourceInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    update: XOR<ResourceTagAssignmentUpdateWithoutResourceInput, ResourceTagAssignmentUncheckedUpdateWithoutResourceInput>
    create: XOR<ResourceTagAssignmentCreateWithoutResourceInput, ResourceTagAssignmentUncheckedCreateWithoutResourceInput>
  }

  export type ResourceTagAssignmentUpdateWithWhereUniqueWithoutResourceInput = {
    where: ResourceTagAssignmentWhereUniqueInput
    data: XOR<ResourceTagAssignmentUpdateWithoutResourceInput, ResourceTagAssignmentUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceTagAssignmentUpdateManyWithWhereWithoutResourceInput = {
    where: ResourceTagAssignmentScalarWhereInput
    data: XOR<ResourceTagAssignmentUpdateManyMutationInput, ResourceTagAssignmentUncheckedUpdateManyWithoutResourceInput>
  }

  export type ResourceCategoryUpsertWithoutResourcesInput = {
    update: XOR<ResourceCategoryUpdateWithoutResourcesInput, ResourceCategoryUncheckedUpdateWithoutResourcesInput>
    create: XOR<ResourceCategoryCreateWithoutResourcesInput, ResourceCategoryUncheckedCreateWithoutResourcesInput>
    where?: ResourceCategoryWhereInput
  }

  export type ResourceCategoryUpdateToOneWithWhereWithoutResourcesInput = {
    where?: ResourceCategoryWhereInput
    data: XOR<ResourceCategoryUpdateWithoutResourcesInput, ResourceCategoryUncheckedUpdateWithoutResourcesInput>
  }

  export type ResourceCategoryUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCategoryUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutResourcesAuthoredInput = {
    update: XOR<UserUpdateWithoutResourcesAuthoredInput, UserUncheckedUpdateWithoutResourcesAuthoredInput>
    create: XOR<UserCreateWithoutResourcesAuthoredInput, UserUncheckedCreateWithoutResourcesAuthoredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesAuthoredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesAuthoredInput, UserUncheckedUpdateWithoutResourcesAuthoredInput>
  }

  export type UserUpdateWithoutResourcesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUpdateManyWithoutUserNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourceDownloadLogs?: ResourceDownloadLogUncheckedUpdateManyWithoutUserNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResourceCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogCreateNestedManyWithoutResourceInput
    category: ResourceCategoryCreateNestedOneWithoutResourcesInput
    author: UserCreateNestedOneWithoutResourcesAuthoredInput
  }

  export type ResourceUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetUncheckedCreateNestedManyWithoutResourceInput
    downloads?: ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutTagsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutTagsInput, ResourceUncheckedCreateWithoutTagsInput>
  }

  export type ResourceTagCreateWithoutTagAssignmentsInput = {
    id?: string
    name: string
  }

  export type ResourceTagUncheckedCreateWithoutTagAssignmentsInput = {
    id?: string
    name: string
  }

  export type ResourceTagCreateOrConnectWithoutTagAssignmentsInput = {
    where: ResourceTagWhereUniqueInput
    create: XOR<ResourceTagCreateWithoutTagAssignmentsInput, ResourceTagUncheckedCreateWithoutTagAssignmentsInput>
  }

  export type ResourceUpsertWithoutTagsInput = {
    update: XOR<ResourceUpdateWithoutTagsInput, ResourceUncheckedUpdateWithoutTagsInput>
    create: XOR<ResourceCreateWithoutTagsInput, ResourceUncheckedCreateWithoutTagsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutTagsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutTagsInput, ResourceUncheckedUpdateWithoutTagsInput>
  }

  export type ResourceUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUpdateManyWithoutResourceNestedInput
    category?: ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput
    author?: UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput
  }

  export type ResourceUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceTagUpsertWithoutTagAssignmentsInput = {
    update: XOR<ResourceTagUpdateWithoutTagAssignmentsInput, ResourceTagUncheckedUpdateWithoutTagAssignmentsInput>
    create: XOR<ResourceTagCreateWithoutTagAssignmentsInput, ResourceTagUncheckedCreateWithoutTagAssignmentsInput>
    where?: ResourceTagWhereInput
  }

  export type ResourceTagUpdateToOneWithWhereWithoutTagAssignmentsInput = {
    where?: ResourceTagWhereInput
    data: XOR<ResourceTagUpdateWithoutTagAssignmentsInput, ResourceTagUncheckedUpdateWithoutTagAssignmentsInput>
  }

  export type ResourceTagUpdateWithoutTagAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagUncheckedUpdateWithoutTagAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceCreateWithoutAssetsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    downloads?: ResourceDownloadLogCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentCreateNestedManyWithoutResourceInput
    category: ResourceCategoryCreateNestedOneWithoutResourcesInput
    author: UserCreateNestedOneWithoutResourcesAuthoredInput
  }

  export type ResourceUncheckedCreateWithoutAssetsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    downloads?: ResourceDownloadLogUncheckedCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutAssetsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutAssetsInput, ResourceUncheckedCreateWithoutAssetsInput>
  }

  export type ResourceUpsertWithoutAssetsInput = {
    update: XOR<ResourceUpdateWithoutAssetsInput, ResourceUncheckedUpdateWithoutAssetsInput>
    create: XOR<ResourceCreateWithoutAssetsInput, ResourceUncheckedCreateWithoutAssetsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutAssetsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutAssetsInput, ResourceUncheckedUpdateWithoutAssetsInput>
  }

  export type ResourceUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloads?: ResourceDownloadLogUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUpdateManyWithoutResourceNestedInput
    category?: ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput
    author?: UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput
  }

  export type ResourceUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloads?: ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateWithoutDownloadsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentCreateNestedManyWithoutResourceInput
    category: ResourceCategoryCreateNestedOneWithoutResourcesInput
    author: UserCreateNestedOneWithoutResourcesAuthoredInput
  }

  export type ResourceUncheckedCreateWithoutDownloadsInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: ResourceAssetUncheckedCreateNestedManyWithoutResourceInput
    tags?: ResourceTagAssignmentUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutDownloadsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutDownloadsInput, ResourceUncheckedCreateWithoutDownloadsInput>
  }

  export type UserCreateWithoutResourceDownloadLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResourceDownloadLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    profileDisplayName: string
    profileAvatarUrl?: string | null
    profileBio?: string | null
    profileTimezone: string
    profileBadges?: UserCreateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseProgresses?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    coursesAuthored?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutModeratedByInput
    lessonCommentReplies?: LessonCommentReplyUncheckedCreateNestedManyWithoutUserInput
    moderatedLessonComments?: LessonCommentUncheckedCreateNestedManyWithoutModeratedByInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedCreateNestedManyWithoutUserInput
    LessonProgressEvent?: LessonProgressEventUncheckedCreateNestedManyWithoutUserInput
    LessonRating?: LessonRatingUncheckedCreateNestedManyWithoutUserInput
    featureTogglesCreated?: FeatureToggleUncheckedCreateNestedManyWithoutCreatedByInput
    createdBanners?: HeroBannerUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsAccepted?: InvitationUncheckedCreateNestedManyWithoutAcceptedByInput
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput
    overridesGranted?: MemberAccessOverrideUncheckedCreateNestedManyWithoutGrantedByInput
    accessOverrides?: MemberAccessOverrideUncheckedCreateNestedManyWithoutUserInput
    memberAccessGrants?: MemberAccessUncheckedCreateNestedManyWithoutGrantedByInput
    memberAccesses?: MemberAccessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resourcesAuthored?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    campaignRunsInitiated?: CampaignRunUncheckedCreateNestedManyWithoutInitiatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    contactSegments?: ContactSegmentUncheckedCreateNestedManyWithoutUserInput
    evolutionConfig?: EvolutionApiConfigUncheckedCreateNestedOneWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResourceDownloadLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourceDownloadLogsInput, UserUncheckedCreateWithoutResourceDownloadLogsInput>
  }

  export type ResourceUpsertWithoutDownloadsInput = {
    update: XOR<ResourceUpdateWithoutDownloadsInput, ResourceUncheckedUpdateWithoutDownloadsInput>
    create: XOR<ResourceCreateWithoutDownloadsInput, ResourceUncheckedCreateWithoutDownloadsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutDownloadsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutDownloadsInput, ResourceUncheckedUpdateWithoutDownloadsInput>
  }

  export type ResourceUpdateWithoutDownloadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUpdateManyWithoutResourceNestedInput
    category?: ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput
    author?: UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput
  }

  export type ResourceUncheckedUpdateWithoutDownloadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserUpsertWithoutResourceDownloadLogsInput = {
    update: XOR<UserUpdateWithoutResourceDownloadLogsInput, UserUncheckedUpdateWithoutResourceDownloadLogsInput>
    create: XOR<UserCreateWithoutResourceDownloadLogsInput, UserUncheckedCreateWithoutResourceDownloadLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourceDownloadLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourceDownloadLogsInput, UserUncheckedUpdateWithoutResourceDownloadLogsInput>
  }

  export type UserUpdateWithoutResourceDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResourceDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileDisplayName?: StringFieldUpdateOperationsInput | string
    profileAvatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileBio?: NullableStringFieldUpdateOperationsInput | string | null
    profileTimezone?: StringFieldUpdateOperationsInput | string
    profileBadges?: UserUpdateprofileBadgesInput | string[]
    profileSocialLinks?: JsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseProgresses?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    coursesAuthored?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    moderatedLessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonCommentReplies?: LessonCommentReplyUncheckedUpdateManyWithoutUserNestedInput
    moderatedLessonComments?: LessonCommentUncheckedUpdateManyWithoutModeratedByNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressAggregate?: LessonProgressAggregateUncheckedUpdateManyWithoutUserNestedInput
    LessonProgressEvent?: LessonProgressEventUncheckedUpdateManyWithoutUserNestedInput
    LessonRating?: LessonRatingUncheckedUpdateManyWithoutUserNestedInput
    featureTogglesCreated?: FeatureToggleUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBanners?: HeroBannerUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsAccepted?: InvitationUncheckedUpdateManyWithoutAcceptedByNestedInput
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput
    overridesGranted?: MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByNestedInput
    accessOverrides?: MemberAccessOverrideUncheckedUpdateManyWithoutUserNestedInput
    memberAccessGrants?: MemberAccessUncheckedUpdateManyWithoutGrantedByNestedInput
    memberAccesses?: MemberAccessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resourcesAuthored?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    campaignRunsInitiated?: CampaignRunUncheckedUpdateManyWithoutInitiatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    contactSegments?: ContactSegmentUncheckedUpdateManyWithoutUserNestedInput
    evolutionConfig?: EvolutionApiConfigUncheckedUpdateOneWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseProgressCreateManyUserInput = {
    courseId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseCreateManyAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle: string
    description: string
    coverImage?: string | null
    level: $Enums.CourseLevel
    status: $Enums.CourseStatus
    visibility: $Enums.Visibility
    estimatedDurationMinutes?: number
    totalLessons?: number
    tags?: CourseCreatetagsInput | string[]
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isFeatured?: boolean
    recommendationScore?: number
  }

  export type LessonCommentReplyCreateManyModeratedByInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentReplyCreateManyUserInput = {
    id?: string
    commentId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentCreateManyModeratedByInput = {
    id?: string
    lessonId: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentCreateManyUserInput = {
    id?: string
    lessonId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
  }

  export type LessonProgressAggregateCreateManyUserInput = {
    lessonId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressEventCreateManyUserInput = {
    id?: string
    lessonId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonRatingCreateManyUserInput = {
    id?: string
    lessonId: string
    value: number
    createdAt?: Date | string
  }

  export type FeatureToggleCreateManyCreatedByInput = {
    id?: string
    featureKey: string
    description: string
    status: $Enums.FeatureToggleStatus
    rolloutPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    primaryCtaLabel: string
    primaryCtaHref: string
    primaryCtaExternal?: boolean
    secondaryCtaLabel?: string | null
    secondaryCtaHref?: string | null
    secondaryCtaExternal?: boolean | null
    imageUrl: string
    order: number
    status: $Enums.BannerStatus
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyAcceptedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    invitedById: string
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationCreateManyInvitedByInput = {
    id?: string
    code: string
    email: string
    role: $Enums.UserRole
    status?: $Enums.InvitationStatus
    grantedAccess?: InvitationCreategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt: Date | string
    acceptedById?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MemberAccessOverrideCreateManyGrantedByInput = {
    id?: string
    userId: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedAt?: Date | string
  }

  export type MemberAccessOverrideCreateManyUserInput = {
    id?: string
    feature: string
    enabled?: boolean
    permissions?: MemberAccessOverrideCreatepermissionsInput | string[]
    reason: string
    grantedById: string
    grantedAt?: Date | string
  }

  export type MemberAccessCreateManyGrantedByInput = {
    id?: string
    userId: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAccessCreateManyUserInput = {
    id?: string
    feature: $Enums.FeatureAccessKey
    enabled?: boolean
    permissions?: MemberAccessCreatepermissionsInput | string[]
    grantedById?: string | null
    grantedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshTokenHash: string
    device?: string
    userAgent: string
    ipAddress: string
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ResourceDownloadLogCreateManyUserInput = {
    id?: string
    resourceId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceCreateManyAuthorInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    categoryId: string
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignRunCreateManyInitiatorInput = {
    id?: string
    campaignId: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSegmentCreateManyUserInput = {
    id?: string
    name: string
    description: string
    importSource: $Enums.ContactImportSource
    totalContacts?: number
    createdAt?: Date | string
  }

  export type MessageTemplateCreateManyUserInput = {
    id?: string
    title: string
    body: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateWithoutUserInput = {
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutProgressesNestedInput
  }

  export type CourseProgressUncheckedUpdateWithoutUserInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyWithoutUserInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progresses?: CourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    recommendations?: CourseRecommendationUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    estimatedDurationMinutes?: IntFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    tags?: CourseUpdatetagsInput | string[]
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    recommendationScore?: FloatFieldUpdateOperationsInput | number
  }

  export type LessonCommentReplyUpdateWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: LessonCommentUpdateOneRequiredWithoutRepliesNestedInput
    parentReply?: LessonCommentReplyUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentReplyUpdateManyWithoutParentReplyNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: LessonCommentUpdateOneRequiredWithoutRepliesNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput
    parentReply?: LessonCommentReplyUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentUpdateWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUpdateManyWithoutCommentNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutModeratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type LessonCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUpdateManyWithoutCommentNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentsNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type LessonProgressAggregateUpdateWithoutUserInput = {
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutProgressAggregatesNestedInput
  }

  export type LessonProgressAggregateUncheckedUpdateWithoutUserInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressAggregateUncheckedUpdateManyWithoutUserInput = {
    lessonId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
    lesson?: LessonUpdateOneRequiredWithoutProgressEventsNestedInput
  }

  export type LessonProgressEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type LessonRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureToggleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumFeatureToggleStatusFieldUpdateOperationsInput | $Enums.FeatureToggleStatus
    rolloutPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    primaryCtaLabel?: StringFieldUpdateOperationsInput | string
    primaryCtaHref?: StringFieldUpdateOperationsInput | string
    primaryCtaExternal?: BoolFieldUpdateOperationsInput | boolean
    secondaryCtaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaHref?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryCtaExternal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumBannerStatusFieldUpdateOperationsInput | $Enums.BannerStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutAcceptedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
  }

  export type InvitationUncheckedUpdateWithoutAcceptedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    invitedById?: StringFieldUpdateOperationsInput | string
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutAcceptedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    invitedById?: StringFieldUpdateOperationsInput | string
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedBy?: UserUpdateOneWithoutInvitationsAcceptedNestedInput
  }

  export type InvitationUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    grantedAccess?: InvitationUpdategrantedAccessInput | $Enums.FeatureAccessKey[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccessOverridesNestedInput
  }

  export type MemberAccessOverrideUncheckedUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideUncheckedUpdateManyWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: UserUpdateOneRequiredWithoutOverridesGrantedNestedInput
  }

  export type MemberAccessOverrideUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessOverrideUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessOverrideUpdatepermissionsInput | string[]
    reason?: StringFieldUpdateOperationsInput | string
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberAccessesNestedInput
  }

  export type MemberAccessUncheckedUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessUncheckedUpdateManyWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: UserUpdateOneWithoutMemberAccessGrantsNestedInput
  }

  export type MemberAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedById?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: EnumFeatureAccessKeyFieldUpdateOperationsInput | $Enums.FeatureAccessKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    permissions?: MemberAccessUpdatepermissionsInput | string[]
    grantedById?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceDownloadLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    resource?: ResourceUpdateOneRequiredWithoutDownloadsNestedInput
  }

  export type ResourceDownloadLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceDownloadLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUpdateManyWithoutResourceNestedInput
    category?: ResourceCategoryUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    categoryId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRunUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: CampaignUpdateOneRequiredWithoutRunsNestedInput
  }

  export type CampaignRunUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignRunUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSegmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutSegmentNestedInput
  }

  export type ContactSegmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type ContactSegmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    importSource?: EnumContactImportSourceFieldUpdateOperationsInput | $Enums.ContactImportSource
    totalContacts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type MessageTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseModuleCreateManyCourseInput = {
    id?: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
    dripAfterModuleId?: string | null
  }

  export type CourseProgressCreateManyCourseInput = {
    userId: string
    completedLessonIds?: CourseProgressCreatecompletedLessonIdsInput | string[]
    percentage?: number
    lastLessonId?: string | null
    updatedAt?: Date | string
  }

  export type CourseRecommendationCreateManyCourseInput = {
    id?: string
    reason: string
    badge?: $Enums.RecommendationBadge | null
  }

  export type CourseModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModule?: CourseModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: CourseModuleUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
    dependentModules?: CourseModuleUncheckedUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dripAfterModuleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseProgressUpdateWithoutCourseInput = {
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseProgressesNestedInput
  }

  export type CourseProgressUncheckedUpdateWithoutCourseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyWithoutCourseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    completedLessonIds?: CourseProgressUpdatecompletedLessonIdsInput | string[]
    percentage?: FloatFieldUpdateOperationsInput | number
    lastLessonId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRecommendationUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type CourseRecommendationUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumRecommendationBadgeFieldUpdateOperationsInput | $Enums.RecommendationBadge | null
  }

  export type CourseModuleCreateManyDripAfterModuleInput = {
    id?: string
    courseId: string
    order: number
    title: string
    description: string
    durationMinutes: number
    dripDaysAfter?: number | null
    dripReleaseAt?: Date | string | null
  }

  export type LessonCreateManyModuleInput = {
    id?: string
    order: number
    title: string
    summary: string
    type: $Enums.LessonType
    content: JsonNullValueInput | InputJsonValue
    durationMinutes: number
    isPreview?: boolean
    releaseAt?: Date | string | null
  }

  export type CourseModuleUpdateWithoutDripAfterModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    dependentModules?: CourseModuleUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutDripAfterModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dependentModules?: CourseModuleUncheckedUpdateManyWithoutDripAfterModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateManyWithoutDripAfterModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    dripDaysAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dripReleaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    progressAggregates?: LessonProgressAggregateUncheckedUpdateManyWithoutLessonNestedInput
    progressEvents?: LessonProgressEventUncheckedUpdateManyWithoutLessonNestedInput
    ratings?: LessonRatingUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    content?: JsonNullValueInput | InputJsonValue
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    releaseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCommentCreateManyLessonInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingModeration?: boolean
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
  }

  export type LessonProgressAggregateCreateManyLessonInput = {
    userId: string
    lastPositionSec?: number
    percentage?: number
    updatedAt?: Date | string
  }

  export type LessonProgressEventCreateManyLessonInput = {
    id?: string
    userId: string
    occurredAt: Date | string
    positionSec: number
  }

  export type LessonRatingCreateManyLessonInput = {
    id?: string
    userId: string
    value: number
    createdAt?: Date | string
  }

  export type LessonCommentUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUpdateManyWithoutCommentNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
  }

  export type LessonProgressAggregateUpdateWithoutLessonInput = {
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonProgressAggregateNestedInput
  }

  export type LessonProgressAggregateUncheckedUpdateWithoutLessonInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressAggregateUncheckedUpdateManyWithoutLessonInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastPositionSec?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressEventUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLessonProgressEventNestedInput
  }

  export type LessonProgressEventUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressEventUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionSec?: IntFieldUpdateOperationsInput | number
  }

  export type LessonRatingUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonRatingNestedInput
  }

  export type LessonRatingUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonRatingUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentReplyCreateManyCommentInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    parentReplyId?: string | null
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentReplyUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput
    parentReply?: LessonCommentReplyUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentReplyUpdateManyWithoutParentReplyNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentReplyCreateManyParentReplyInput = {
    id?: string
    commentId: string
    userId: string
    body: string
    createdAt?: Date | string
    moderatedAt?: Date | string | null
    moderatedById?: string | null
    moderationStatus?: $Enums.LessonCommentModerationStatus
    pendingModeration?: boolean
    updatedAt?: Date | string
  }

  export type LessonCommentReplyUpdateWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: LessonCommentUpdateOneRequiredWithoutRepliesNestedInput
    moderatedBy?: UserUpdateOneWithoutModeratedLessonCommentRepliesNestedInput
    replies?: LessonCommentReplyUpdateManyWithoutParentReplyNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentRepliesNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type LessonCommentReplyUncheckedUpdateManyWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedById?: NullableStringFieldUpdateOperationsInput | string | null
    moderationStatus?: EnumLessonCommentModerationStatusFieldUpdateOperationsInput | $Enums.LessonCommentModerationStatus
    pendingModeration?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyEvolutionConfigInput = {
    id?: string
    userId: string
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutEvolutionConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEvolutionConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutEvolutionConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManySegmentInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    templateId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    template?: MessageTemplateUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyTemplateInput = {
    id?: string
    userId: string
    evolutionConfigId?: string | null
    name: string
    description: string
    channel: $Enums.CampaignChannel
    status: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    segmentId: string
    externalId?: string | null
    maxMessagesPerMinute?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUpdateManyWithoutCampaignNestedInput
    evolutionConfig?: EvolutionApiConfigUpdateOneWithoutCampaignsNestedInput
    segment?: ContactSegmentUpdateOneRequiredWithoutCampaignsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: CampaignMetricsUncheckedUpdateOneWithoutCampaignNestedInput
    runs?: CampaignRunUncheckedUpdateManyWithoutCampaignNestedInput
    timeline?: CampaignTimelinePointUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    evolutionConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: EnumCampaignChannelFieldUpdateOperationsInput | $Enums.CampaignChannel
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segmentId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessagesPerMinute?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRunCreateManyCampaignInput = {
    id?: string
    initiatedBy: string
    startedAt: Date | string
    endedAt?: Date | string | null
    status: $Enums.CampaignStatus
    summary?: string | null
  }

  export type CampaignTimelinePointCreateManyCampaignInput = {
    id?: string
    timestamp: Date | string
    delivered?: number
    failed?: number
  }

  export type CampaignRunUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    initiator?: UserUpdateOneRequiredWithoutCampaignRunsInitiatedNestedInput
  }

  export type CampaignRunUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignRunUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignTimelinePointUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignTimelinePointUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignTimelinePointUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: IntFieldUpdateOperationsInput | number
    failed?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceCreateManyCategoryInput = {
    id?: string
    slug: string
    title: string
    description: string
    type: $Enums.ResourceType
    thumbnailUrl?: string | null
    visibility: $Enums.Visibility
    featured?: boolean
    downloadCount?: number
    viewCount?: number
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUpdateManyWithoutResourceNestedInput
    author?: UserUpdateOneRequiredWithoutResourcesAuthoredNestedInput
  }

  export type ResourceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: ResourceAssetUncheckedUpdateManyWithoutResourceNestedInput
    downloads?: ResourceDownloadLogUncheckedUpdateManyWithoutResourceNestedInput
    tags?: ResourceTagAssignmentUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    featured?: BoolFieldUpdateOperationsInput | boolean
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceTagAssignmentCreateManyTagInput = {
    resourceId: string
  }

  export type ResourceTagAssignmentUpdateWithoutTagInput = {
    resource?: ResourceUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ResourceTagAssignmentUncheckedUpdateWithoutTagInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagAssignmentUncheckedUpdateManyWithoutTagInput = {
    resourceId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceAssetCreateManyResourceInput = {
    id?: string
    fileUrl: string
    fileName: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ResourceDownloadLogCreateManyResourceInput = {
    id?: string
    userId: string
    downloadedAt?: Date | string
    ipAddress: string
  }

  export type ResourceTagAssignmentCreateManyResourceInput = {
    tagId: string
  }

  export type ResourceAssetUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceAssetUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceAssetUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceDownloadLogUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutResourceDownloadLogsNestedInput
  }

  export type ResourceDownloadLogUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceDownloadLogUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagAssignmentUpdateWithoutResourceInput = {
    tag?: ResourceTagUpdateOneRequiredWithoutTagAssignmentsNestedInput
  }

  export type ResourceTagAssignmentUncheckedUpdateWithoutResourceInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceTagAssignmentUncheckedUpdateManyWithoutResourceInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}